(function (global, factory) {
  try {
    globalThis
  }catch(e)
  {
    var globalThis
  }
  console.log('it got here...')
  console.log('I can see globalThis', globalThis)
  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports, require('util/types'), require('node:http'), require('node:https'), require('node:zlib'), require('node:stream'), require('node:buffer'), require('node:util'), require('node:url'), require('node:net'), require('node:fs'), require('node:path'), require('stream'), require('util'), require('fs')) :
  typeof define === 'function' && define.amd ? define(['exports', 'util/types', 'node:http', 'node:https', 'node:zlib', 'node:stream', 'node:buffer', 'node:util', 'node:url', 'node:net', 'node:fs', 'node:path', 'stream', 'util', 'fs'], factory) :
  (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global.awe = {}, global.types, global.http, global.https, global.zlib, global.Stream, global.node_buffer, global.node_util, global.node_url, global.node_net, null, null, global.stream, global.util, global.fs));
})(this, (function (exports, types, http, https, zlib, Stream, node_buffer, node_util, node_url, node_net, node_fs, node_path, stream, util, fs) { 'use strict';

  function _interopDefaultLegacy (e) { return e && typeof e === 'object' && 'default' in e ? e : { 'default': e }; }

  var http__default = /*#__PURE__*/_interopDefaultLegacy(http);
  var https__default = /*#__PURE__*/_interopDefaultLegacy(https);
  var zlib__default = /*#__PURE__*/_interopDefaultLegacy(zlib);
  var Stream__default = /*#__PURE__*/_interopDefaultLegacy(Stream);
  var stream__default = /*#__PURE__*/_interopDefaultLegacy(stream);
  var util__default = /*#__PURE__*/_interopDefaultLegacy(util);
  var fs__default = /*#__PURE__*/_interopDefaultLegacy(fs);

  const dict = {
    upperLetters: ['A','B','C','D','E','F','G','H','I','J','K','L','M','N','O','P','Q','R','S','T','U','V','W','X','Y','Z'],
    lowerLetters: ['a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'],
    numbers: [0,1,2,3,4,5,6,7,8,9]
  };

  function anonymize(toAnonymize)
  {
    let changes = 0;
    const result = toAnonymize
      .split('')
      .map(char => {
        let toReturn;
        const type = getTypeDict(char);

        if(type)
          toReturn = type[getRandomInt(type.length -1)];
        else toReturn = char;

        if(toReturn !== char) changes++;
        return toReturn
      })
      .join('');

    if(changes < toAnonymize.length/2) return Array.from({length: result.length}).fill('*').join('')
    
    return result
  }

  function getRandomInt(max) {
    return Math.floor(Math.random() * Math.floor(max));
  }

  function getTypeDict(char)
  {
    const type = char.charCodeAt();

    if( type > 47 && type < 58 ) return dict.numbers
    if( type > 64 && type < 91 ) return dict.upperLetters 
    if( type > 96 && type < 123 ) return dict.lowerLetters

    return undefined
  }

  var commonjsGlobal = typeof globalThis !== 'undefined' ? globalThis : typeof window !== 'undefined' ? window : typeof global !== 'undefined' ? global : typeof self !== 'undefined' ? self : {};

  var lodash = {exports: {}};

  /**
   * @license
   * Lodash <https://lodash.com/>
   * Copyright OpenJS Foundation and other contributors <https://openjsf.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  (function (module, exports) {
  (function() {

  	  /** Used as a safe reference for `undefined` in pre-ES5 environments. */
  	  var undefined$1;

  	  /** Used as the semantic version number. */
  	  var VERSION = '4.17.21';

  	  /** Used as the size to enable large array optimizations. */
  	  var LARGE_ARRAY_SIZE = 200;

  	  /** Error message constants. */
  	  var CORE_ERROR_TEXT = 'Unsupported core-js use. Try https://npms.io/search?q=ponyfill.',
  	      FUNC_ERROR_TEXT = 'Expected a function',
  	      INVALID_TEMPL_VAR_ERROR_TEXT = 'Invalid `variable` option passed into `_.template`';

  	  /** Used to stand-in for `undefined` hash values. */
  	  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  	  /** Used as the maximum memoize cache size. */
  	  var MAX_MEMOIZE_SIZE = 500;

  	  /** Used as the internal argument placeholder. */
  	  var PLACEHOLDER = '__lodash_placeholder__';

  	  /** Used to compose bitmasks for cloning. */
  	  var CLONE_DEEP_FLAG = 1,
  	      CLONE_FLAT_FLAG = 2,
  	      CLONE_SYMBOLS_FLAG = 4;

  	  /** Used to compose bitmasks for value comparisons. */
  	  var COMPARE_PARTIAL_FLAG = 1,
  	      COMPARE_UNORDERED_FLAG = 2;

  	  /** Used to compose bitmasks for function metadata. */
  	  var WRAP_BIND_FLAG = 1,
  	      WRAP_BIND_KEY_FLAG = 2,
  	      WRAP_CURRY_BOUND_FLAG = 4,
  	      WRAP_CURRY_FLAG = 8,
  	      WRAP_CURRY_RIGHT_FLAG = 16,
  	      WRAP_PARTIAL_FLAG = 32,
  	      WRAP_PARTIAL_RIGHT_FLAG = 64,
  	      WRAP_ARY_FLAG = 128,
  	      WRAP_REARG_FLAG = 256,
  	      WRAP_FLIP_FLAG = 512;

  	  /** Used as default options for `_.truncate`. */
  	  var DEFAULT_TRUNC_LENGTH = 30,
  	      DEFAULT_TRUNC_OMISSION = '...';

  	  /** Used to detect hot functions by number of calls within a span of milliseconds. */
  	  var HOT_COUNT = 800,
  	      HOT_SPAN = 16;

  	  /** Used to indicate the type of lazy iteratees. */
  	  var LAZY_FILTER_FLAG = 1,
  	      LAZY_MAP_FLAG = 2,
  	      LAZY_WHILE_FLAG = 3;

  	  /** Used as references for various `Number` constants. */
  	  var INFINITY = 1 / 0,
  	      MAX_SAFE_INTEGER = 9007199254740991,
  	      MAX_INTEGER = 1.7976931348623157e+308,
  	      NAN = 0 / 0;

  	  /** Used as references for the maximum length and index of an array. */
  	  var MAX_ARRAY_LENGTH = 4294967295,
  	      MAX_ARRAY_INDEX = MAX_ARRAY_LENGTH - 1,
  	      HALF_MAX_ARRAY_LENGTH = MAX_ARRAY_LENGTH >>> 1;

  	  /** Used to associate wrap methods with their bit flags. */
  	  var wrapFlags = [
  	    ['ary', WRAP_ARY_FLAG],
  	    ['bind', WRAP_BIND_FLAG],
  	    ['bindKey', WRAP_BIND_KEY_FLAG],
  	    ['curry', WRAP_CURRY_FLAG],
  	    ['curryRight', WRAP_CURRY_RIGHT_FLAG],
  	    ['flip', WRAP_FLIP_FLAG],
  	    ['partial', WRAP_PARTIAL_FLAG],
  	    ['partialRight', WRAP_PARTIAL_RIGHT_FLAG],
  	    ['rearg', WRAP_REARG_FLAG]
  	  ];

  	  /** `Object#toString` result references. */
  	  var argsTag = '[object Arguments]',
  	      arrayTag = '[object Array]',
  	      asyncTag = '[object AsyncFunction]',
  	      boolTag = '[object Boolean]',
  	      dateTag = '[object Date]',
  	      domExcTag = '[object DOMException]',
  	      errorTag = '[object Error]',
  	      funcTag = '[object Function]',
  	      genTag = '[object GeneratorFunction]',
  	      mapTag = '[object Map]',
  	      numberTag = '[object Number]',
  	      nullTag = '[object Null]',
  	      objectTag = '[object Object]',
  	      promiseTag = '[object Promise]',
  	      proxyTag = '[object Proxy]',
  	      regexpTag = '[object RegExp]',
  	      setTag = '[object Set]',
  	      stringTag = '[object String]',
  	      symbolTag = '[object Symbol]',
  	      undefinedTag = '[object Undefined]',
  	      weakMapTag = '[object WeakMap]',
  	      weakSetTag = '[object WeakSet]';

  	  var arrayBufferTag = '[object ArrayBuffer]',
  	      dataViewTag = '[object DataView]',
  	      float32Tag = '[object Float32Array]',
  	      float64Tag = '[object Float64Array]',
  	      int8Tag = '[object Int8Array]',
  	      int16Tag = '[object Int16Array]',
  	      int32Tag = '[object Int32Array]',
  	      uint8Tag = '[object Uint8Array]',
  	      uint8ClampedTag = '[object Uint8ClampedArray]',
  	      uint16Tag = '[object Uint16Array]',
  	      uint32Tag = '[object Uint32Array]';

  	  /** Used to match empty string literals in compiled template source. */
  	  var reEmptyStringLeading = /\b__p \+= '';/g,
  	      reEmptyStringMiddle = /\b(__p \+=) '' \+/g,
  	      reEmptyStringTrailing = /(__e\(.*?\)|\b__t\)) \+\n'';/g;

  	  /** Used to match HTML entities and HTML characters. */
  	  var reEscapedHtml = /&(?:amp|lt|gt|quot|#39);/g,
  	      reUnescapedHtml = /[&<>"']/g,
  	      reHasEscapedHtml = RegExp(reEscapedHtml.source),
  	      reHasUnescapedHtml = RegExp(reUnescapedHtml.source);

  	  /** Used to match template delimiters. */
  	  var reEscape = /<%-([\s\S]+?)%>/g,
  	      reEvaluate = /<%([\s\S]+?)%>/g,
  	      reInterpolate = /<%=([\s\S]+?)%>/g;

  	  /** Used to match property names within property paths. */
  	  var reIsDeepProp = /\.|\[(?:[^[\]]*|(["'])(?:(?!\1)[^\\]|\\.)*?\1)\]/,
  	      reIsPlainProp = /^\w*$/,
  	      rePropName = /[^.[\]]+|\[(?:(-?\d+(?:\.\d+)?)|(["'])((?:(?!\2)[^\\]|\\.)*?)\2)\]|(?=(?:\.|\[\])(?:\.|\[\]|$))/g;

  	  /**
  	   * Used to match `RegExp`
  	   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
  	   */
  	  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g,
  	      reHasRegExpChar = RegExp(reRegExpChar.source);

  	  /** Used to match leading whitespace. */
  	  var reTrimStart = /^\s+/;

  	  /** Used to match a single whitespace character. */
  	  var reWhitespace = /\s/;

  	  /** Used to match wrap detail comments. */
  	  var reWrapComment = /\{(?:\n\/\* \[wrapped with .+\] \*\/)?\n?/,
  	      reWrapDetails = /\{\n\/\* \[wrapped with (.+)\] \*/,
  	      reSplitDetails = /,? & /;

  	  /** Used to match words composed of alphanumeric characters. */
  	  var reAsciiWord = /[^\x00-\x2f\x3a-\x40\x5b-\x60\x7b-\x7f]+/g;

  	  /**
  	   * Used to validate the `validate` option in `_.template` variable.
  	   *
  	   * Forbids characters which could potentially change the meaning of the function argument definition:
  	   * - "()," (modification of function parameters)
  	   * - "=" (default value)
  	   * - "[]{}" (destructuring of function parameters)
  	   * - "/" (beginning of a comment)
  	   * - whitespace
  	   */
  	  var reForbiddenIdentifierChars = /[()=,{}\[\]\/\s]/;

  	  /** Used to match backslashes in property paths. */
  	  var reEscapeChar = /\\(\\)?/g;

  	  /**
  	   * Used to match
  	   * [ES template delimiters](http://ecma-international.org/ecma-262/7.0/#sec-template-literal-lexical-components).
  	   */
  	  var reEsTemplate = /\$\{([^\\}]*(?:\\.[^\\}]*)*)\}/g;

  	  /** Used to match `RegExp` flags from their coerced string values. */
  	  var reFlags = /\w*$/;

  	  /** Used to detect bad signed hexadecimal string values. */
  	  var reIsBadHex = /^[-+]0x[0-9a-f]+$/i;

  	  /** Used to detect binary string values. */
  	  var reIsBinary = /^0b[01]+$/i;

  	  /** Used to detect host constructors (Safari). */
  	  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  	  /** Used to detect octal string values. */
  	  var reIsOctal = /^0o[0-7]+$/i;

  	  /** Used to detect unsigned integer values. */
  	  var reIsUint = /^(?:0|[1-9]\d*)$/;

  	  /** Used to match Latin Unicode letters (excluding mathematical operators). */
  	  var reLatin = /[\xc0-\xd6\xd8-\xf6\xf8-\xff\u0100-\u017f]/g;

  	  /** Used to ensure capturing order of template delimiters. */
  	  var reNoMatch = /($^)/;

  	  /** Used to match unescaped characters in compiled string literals. */
  	  var reUnescapedString = /['\n\r\u2028\u2029\\]/g;

  	  /** Used to compose unicode character classes. */
  	  var rsAstralRange = '\\ud800-\\udfff',
  	      rsComboMarksRange = '\\u0300-\\u036f',
  	      reComboHalfMarksRange = '\\ufe20-\\ufe2f',
  	      rsComboSymbolsRange = '\\u20d0-\\u20ff',
  	      rsComboRange = rsComboMarksRange + reComboHalfMarksRange + rsComboSymbolsRange,
  	      rsDingbatRange = '\\u2700-\\u27bf',
  	      rsLowerRange = 'a-z\\xdf-\\xf6\\xf8-\\xff',
  	      rsMathOpRange = '\\xac\\xb1\\xd7\\xf7',
  	      rsNonCharRange = '\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf',
  	      rsPunctuationRange = '\\u2000-\\u206f',
  	      rsSpaceRange = ' \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000',
  	      rsUpperRange = 'A-Z\\xc0-\\xd6\\xd8-\\xde',
  	      rsVarRange = '\\ufe0e\\ufe0f',
  	      rsBreakRange = rsMathOpRange + rsNonCharRange + rsPunctuationRange + rsSpaceRange;

  	  /** Used to compose unicode capture groups. */
  	  var rsApos = "['\u2019]",
  	      rsAstral = '[' + rsAstralRange + ']',
  	      rsBreak = '[' + rsBreakRange + ']',
  	      rsCombo = '[' + rsComboRange + ']',
  	      rsDigits = '\\d+',
  	      rsDingbat = '[' + rsDingbatRange + ']',
  	      rsLower = '[' + rsLowerRange + ']',
  	      rsMisc = '[^' + rsAstralRange + rsBreakRange + rsDigits + rsDingbatRange + rsLowerRange + rsUpperRange + ']',
  	      rsFitz = '\\ud83c[\\udffb-\\udfff]',
  	      rsModifier = '(?:' + rsCombo + '|' + rsFitz + ')',
  	      rsNonAstral = '[^' + rsAstralRange + ']',
  	      rsRegional = '(?:\\ud83c[\\udde6-\\uddff]){2}',
  	      rsSurrPair = '[\\ud800-\\udbff][\\udc00-\\udfff]',
  	      rsUpper = '[' + rsUpperRange + ']',
  	      rsZWJ = '\\u200d';

  	  /** Used to compose unicode regexes. */
  	  var rsMiscLower = '(?:' + rsLower + '|' + rsMisc + ')',
  	      rsMiscUpper = '(?:' + rsUpper + '|' + rsMisc + ')',
  	      rsOptContrLower = '(?:' + rsApos + '(?:d|ll|m|re|s|t|ve))?',
  	      rsOptContrUpper = '(?:' + rsApos + '(?:D|LL|M|RE|S|T|VE))?',
  	      reOptMod = rsModifier + '?',
  	      rsOptVar = '[' + rsVarRange + ']?',
  	      rsOptJoin = '(?:' + rsZWJ + '(?:' + [rsNonAstral, rsRegional, rsSurrPair].join('|') + ')' + rsOptVar + reOptMod + ')*',
  	      rsOrdLower = '\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])',
  	      rsOrdUpper = '\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])',
  	      rsSeq = rsOptVar + reOptMod + rsOptJoin,
  	      rsEmoji = '(?:' + [rsDingbat, rsRegional, rsSurrPair].join('|') + ')' + rsSeq,
  	      rsSymbol = '(?:' + [rsNonAstral + rsCombo + '?', rsCombo, rsRegional, rsSurrPair, rsAstral].join('|') + ')';

  	  /** Used to match apostrophes. */
  	  var reApos = RegExp(rsApos, 'g');

  	  /**
  	   * Used to match [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks) and
  	   * [combining diacritical marks for symbols](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks_for_Symbols).
  	   */
  	  var reComboMark = RegExp(rsCombo, 'g');

  	  /** Used to match [string symbols](https://mathiasbynens.be/notes/javascript-unicode). */
  	  var reUnicode = RegExp(rsFitz + '(?=' + rsFitz + ')|' + rsSymbol + rsSeq, 'g');

  	  /** Used to match complex or compound words. */
  	  var reUnicodeWord = RegExp([
  	    rsUpper + '?' + rsLower + '+' + rsOptContrLower + '(?=' + [rsBreak, rsUpper, '$'].join('|') + ')',
  	    rsMiscUpper + '+' + rsOptContrUpper + '(?=' + [rsBreak, rsUpper + rsMiscLower, '$'].join('|') + ')',
  	    rsUpper + '?' + rsMiscLower + '+' + rsOptContrLower,
  	    rsUpper + '+' + rsOptContrUpper,
  	    rsOrdUpper,
  	    rsOrdLower,
  	    rsDigits,
  	    rsEmoji
  	  ].join('|'), 'g');

  	  /** Used to detect strings with [zero-width joiners or code points from the astral planes](http://eev.ee/blog/2015/09/12/dark-corners-of-unicode/). */
  	  var reHasUnicode = RegExp('[' + rsZWJ + rsAstralRange  + rsComboRange + rsVarRange + ']');

  	  /** Used to detect strings that need a more robust regexp to match words. */
  	  var reHasUnicodeWord = /[a-z][A-Z]|[A-Z]{2}[a-z]|[0-9][a-zA-Z]|[a-zA-Z][0-9]|[^a-zA-Z0-9 ]/;

  	  /** Used to assign default `context` object properties. */
  	  var contextProps = [
  	    'Array', 'Buffer', 'DataView', 'Date', 'Error', 'Float32Array', 'Float64Array',
  	    'Function', 'Int8Array', 'Int16Array', 'Int32Array', 'Map', 'Math', 'Object',
  	    'Promise', 'RegExp', 'Set', 'String', 'Symbol', 'TypeError', 'Uint8Array',
  	    'Uint8ClampedArray', 'Uint16Array', 'Uint32Array', 'WeakMap',
  	    '_', 'clearTimeout', 'isFinite', 'parseInt', 'setTimeout'
  	  ];

  	  /** Used to make template sourceURLs easier to identify. */
  	  var templateCounter = -1;

  	  /** Used to identify `toStringTag` values of typed arrays. */
  	  var typedArrayTags = {};
  	  typedArrayTags[float32Tag] = typedArrayTags[float64Tag] =
  	  typedArrayTags[int8Tag] = typedArrayTags[int16Tag] =
  	  typedArrayTags[int32Tag] = typedArrayTags[uint8Tag] =
  	  typedArrayTags[uint8ClampedTag] = typedArrayTags[uint16Tag] =
  	  typedArrayTags[uint32Tag] = true;
  	  typedArrayTags[argsTag] = typedArrayTags[arrayTag] =
  	  typedArrayTags[arrayBufferTag] = typedArrayTags[boolTag] =
  	  typedArrayTags[dataViewTag] = typedArrayTags[dateTag] =
  	  typedArrayTags[errorTag] = typedArrayTags[funcTag] =
  	  typedArrayTags[mapTag] = typedArrayTags[numberTag] =
  	  typedArrayTags[objectTag] = typedArrayTags[regexpTag] =
  	  typedArrayTags[setTag] = typedArrayTags[stringTag] =
  	  typedArrayTags[weakMapTag] = false;

  	  /** Used to identify `toStringTag` values supported by `_.clone`. */
  	  var cloneableTags = {};
  	  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  	  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  	  cloneableTags[boolTag] = cloneableTags[dateTag] =
  	  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  	  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  	  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  	  cloneableTags[numberTag] = cloneableTags[objectTag] =
  	  cloneableTags[regexpTag] = cloneableTags[setTag] =
  	  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  	  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  	  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  	  cloneableTags[errorTag] = cloneableTags[funcTag] =
  	  cloneableTags[weakMapTag] = false;

  	  /** Used to map Latin Unicode letters to basic Latin letters. */
  	  var deburredLetters = {
  	    // Latin-1 Supplement block.
  	    '\xc0': 'A',  '\xc1': 'A', '\xc2': 'A', '\xc3': 'A', '\xc4': 'A', '\xc5': 'A',
  	    '\xe0': 'a',  '\xe1': 'a', '\xe2': 'a', '\xe3': 'a', '\xe4': 'a', '\xe5': 'a',
  	    '\xc7': 'C',  '\xe7': 'c',
  	    '\xd0': 'D',  '\xf0': 'd',
  	    '\xc8': 'E',  '\xc9': 'E', '\xca': 'E', '\xcb': 'E',
  	    '\xe8': 'e',  '\xe9': 'e', '\xea': 'e', '\xeb': 'e',
  	    '\xcc': 'I',  '\xcd': 'I', '\xce': 'I', '\xcf': 'I',
  	    '\xec': 'i',  '\xed': 'i', '\xee': 'i', '\xef': 'i',
  	    '\xd1': 'N',  '\xf1': 'n',
  	    '\xd2': 'O',  '\xd3': 'O', '\xd4': 'O', '\xd5': 'O', '\xd6': 'O', '\xd8': 'O',
  	    '\xf2': 'o',  '\xf3': 'o', '\xf4': 'o', '\xf5': 'o', '\xf6': 'o', '\xf8': 'o',
  	    '\xd9': 'U',  '\xda': 'U', '\xdb': 'U', '\xdc': 'U',
  	    '\xf9': 'u',  '\xfa': 'u', '\xfb': 'u', '\xfc': 'u',
  	    '\xdd': 'Y',  '\xfd': 'y', '\xff': 'y',
  	    '\xc6': 'Ae', '\xe6': 'ae',
  	    '\xde': 'Th', '\xfe': 'th',
  	    '\xdf': 'ss',
  	    // Latin Extended-A block.
  	    '\u0100': 'A',  '\u0102': 'A', '\u0104': 'A',
  	    '\u0101': 'a',  '\u0103': 'a', '\u0105': 'a',
  	    '\u0106': 'C',  '\u0108': 'C', '\u010a': 'C', '\u010c': 'C',
  	    '\u0107': 'c',  '\u0109': 'c', '\u010b': 'c', '\u010d': 'c',
  	    '\u010e': 'D',  '\u0110': 'D', '\u010f': 'd', '\u0111': 'd',
  	    '\u0112': 'E',  '\u0114': 'E', '\u0116': 'E', '\u0118': 'E', '\u011a': 'E',
  	    '\u0113': 'e',  '\u0115': 'e', '\u0117': 'e', '\u0119': 'e', '\u011b': 'e',
  	    '\u011c': 'G',  '\u011e': 'G', '\u0120': 'G', '\u0122': 'G',
  	    '\u011d': 'g',  '\u011f': 'g', '\u0121': 'g', '\u0123': 'g',
  	    '\u0124': 'H',  '\u0126': 'H', '\u0125': 'h', '\u0127': 'h',
  	    '\u0128': 'I',  '\u012a': 'I', '\u012c': 'I', '\u012e': 'I', '\u0130': 'I',
  	    '\u0129': 'i',  '\u012b': 'i', '\u012d': 'i', '\u012f': 'i', '\u0131': 'i',
  	    '\u0134': 'J',  '\u0135': 'j',
  	    '\u0136': 'K',  '\u0137': 'k', '\u0138': 'k',
  	    '\u0139': 'L',  '\u013b': 'L', '\u013d': 'L', '\u013f': 'L', '\u0141': 'L',
  	    '\u013a': 'l',  '\u013c': 'l', '\u013e': 'l', '\u0140': 'l', '\u0142': 'l',
  	    '\u0143': 'N',  '\u0145': 'N', '\u0147': 'N', '\u014a': 'N',
  	    '\u0144': 'n',  '\u0146': 'n', '\u0148': 'n', '\u014b': 'n',
  	    '\u014c': 'O',  '\u014e': 'O', '\u0150': 'O',
  	    '\u014d': 'o',  '\u014f': 'o', '\u0151': 'o',
  	    '\u0154': 'R',  '\u0156': 'R', '\u0158': 'R',
  	    '\u0155': 'r',  '\u0157': 'r', '\u0159': 'r',
  	    '\u015a': 'S',  '\u015c': 'S', '\u015e': 'S', '\u0160': 'S',
  	    '\u015b': 's',  '\u015d': 's', '\u015f': 's', '\u0161': 's',
  	    '\u0162': 'T',  '\u0164': 'T', '\u0166': 'T',
  	    '\u0163': 't',  '\u0165': 't', '\u0167': 't',
  	    '\u0168': 'U',  '\u016a': 'U', '\u016c': 'U', '\u016e': 'U', '\u0170': 'U', '\u0172': 'U',
  	    '\u0169': 'u',  '\u016b': 'u', '\u016d': 'u', '\u016f': 'u', '\u0171': 'u', '\u0173': 'u',
  	    '\u0174': 'W',  '\u0175': 'w',
  	    '\u0176': 'Y',  '\u0177': 'y', '\u0178': 'Y',
  	    '\u0179': 'Z',  '\u017b': 'Z', '\u017d': 'Z',
  	    '\u017a': 'z',  '\u017c': 'z', '\u017e': 'z',
  	    '\u0132': 'IJ', '\u0133': 'ij',
  	    '\u0152': 'Oe', '\u0153': 'oe',
  	    '\u0149': "'n", '\u017f': 's'
  	  };

  	  /** Used to map characters to HTML entities. */
  	  var htmlEscapes = {
  	    '&': '&amp;',
  	    '<': '&lt;',
  	    '>': '&gt;',
  	    '"': '&quot;',
  	    "'": '&#39;'
  	  };

  	  /** Used to map HTML entities to characters. */
  	  var htmlUnescapes = {
  	    '&amp;': '&',
  	    '&lt;': '<',
  	    '&gt;': '>',
  	    '&quot;': '"',
  	    '&#39;': "'"
  	  };

  	  /** Used to escape characters for inclusion in compiled string literals. */
  	  var stringEscapes = {
  	    '\\': '\\',
  	    "'": "'",
  	    '\n': 'n',
  	    '\r': 'r',
  	    '\u2028': 'u2028',
  	    '\u2029': 'u2029'
  	  };

  	  /** Built-in method references without a dependency on `root`. */
  	  var freeParseFloat = parseFloat,
  	      freeParseInt = parseInt;

  	  /** Detect free variable `global` from Node.js. */
  	  var freeGlobal = typeof commonjsGlobal == 'object' && commonjsGlobal && commonjsGlobal.Object === Object && commonjsGlobal;

  	  /** Detect free variable `self`. */
  	  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  	  /** Used as a reference to the global object. */
  	  var root = freeGlobal || freeSelf || Function('return this')();

  	  /** Detect free variable `exports`. */
  	  var freeExports = exports && !exports.nodeType && exports;

  	  /** Detect free variable `module`. */
  	  var freeModule = freeExports && 'object' == 'object' && module && !module.nodeType && module;

  	  /** Detect the popular CommonJS extension `module.exports`. */
  	  var moduleExports = freeModule && freeModule.exports === freeExports;

  	  /** Detect free variable `process` from Node.js. */
  	  var freeProcess = moduleExports && freeGlobal.process;

  	  /** Used to access faster Node.js helpers. */
  	  var nodeUtil = (function() {
  	    try {
  	      // Use `util.types` for Node.js 10+.
  	      var types = freeModule && freeModule.require && freeModule.require('util').types;

  	      if (types) {
  	        return types;
  	      }

  	      // Legacy `process.binding('util')` for Node.js < 10.
  	      return freeProcess && freeProcess.binding && freeProcess.binding('util');
  	    } catch (e) {}
  	  }());

  	  /* Node.js helper references. */
  	  var nodeIsArrayBuffer = nodeUtil && nodeUtil.isArrayBuffer,
  	      nodeIsDate = nodeUtil && nodeUtil.isDate,
  	      nodeIsMap = nodeUtil && nodeUtil.isMap,
  	      nodeIsRegExp = nodeUtil && nodeUtil.isRegExp,
  	      nodeIsSet = nodeUtil && nodeUtil.isSet,
  	      nodeIsTypedArray = nodeUtil && nodeUtil.isTypedArray;

  	  /*--------------------------------------------------------------------------*/

  	  /**
  	   * A faster alternative to `Function#apply`, this function invokes `func`
  	   * with the `this` binding of `thisArg` and the arguments of `args`.
  	   *
  	   * @private
  	   * @param {Function} func The function to invoke.
  	   * @param {*} thisArg The `this` binding of `func`.
  	   * @param {Array} args The arguments to invoke `func` with.
  	   * @returns {*} Returns the result of `func`.
  	   */
  	  function apply(func, thisArg, args) {
  	    switch (args.length) {
  	      case 0: return func.call(thisArg);
  	      case 1: return func.call(thisArg, args[0]);
  	      case 2: return func.call(thisArg, args[0], args[1]);
  	      case 3: return func.call(thisArg, args[0], args[1], args[2]);
  	    }
  	    return func.apply(thisArg, args);
  	  }

  	  /**
  	   * A specialized version of `baseAggregator` for arrays.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} setter The function to set `accumulator` values.
  	   * @param {Function} iteratee The iteratee to transform keys.
  	   * @param {Object} accumulator The initial aggregated object.
  	   * @returns {Function} Returns `accumulator`.
  	   */
  	  function arrayAggregator(array, setter, iteratee, accumulator) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length;

  	    while (++index < length) {
  	      var value = array[index];
  	      setter(accumulator, value, iteratee(value), array);
  	    }
  	    return accumulator;
  	  }

  	  /**
  	   * A specialized version of `_.forEach` for arrays without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Array} Returns `array`.
  	   */
  	  function arrayEach(array, iteratee) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length;

  	    while (++index < length) {
  	      if (iteratee(array[index], index, array) === false) {
  	        break;
  	      }
  	    }
  	    return array;
  	  }

  	  /**
  	   * A specialized version of `_.forEachRight` for arrays without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Array} Returns `array`.
  	   */
  	  function arrayEachRight(array, iteratee) {
  	    var length = array == null ? 0 : array.length;

  	    while (length--) {
  	      if (iteratee(array[length], length, array) === false) {
  	        break;
  	      }
  	    }
  	    return array;
  	  }

  	  /**
  	   * A specialized version of `_.every` for arrays without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} predicate The function invoked per iteration.
  	   * @returns {boolean} Returns `true` if all elements pass the predicate check,
  	   *  else `false`.
  	   */
  	  function arrayEvery(array, predicate) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length;

  	    while (++index < length) {
  	      if (!predicate(array[index], index, array)) {
  	        return false;
  	      }
  	    }
  	    return true;
  	  }

  	  /**
  	   * A specialized version of `_.filter` for arrays without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} predicate The function invoked per iteration.
  	   * @returns {Array} Returns the new filtered array.
  	   */
  	  function arrayFilter(array, predicate) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length,
  	        resIndex = 0,
  	        result = [];

  	    while (++index < length) {
  	      var value = array[index];
  	      if (predicate(value, index, array)) {
  	        result[resIndex++] = value;
  	      }
  	    }
  	    return result;
  	  }

  	  /**
  	   * A specialized version of `_.includes` for arrays without support for
  	   * specifying an index to search from.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to inspect.
  	   * @param {*} target The value to search for.
  	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
  	   */
  	  function arrayIncludes(array, value) {
  	    var length = array == null ? 0 : array.length;
  	    return !!length && baseIndexOf(array, value, 0) > -1;
  	  }

  	  /**
  	   * This function is like `arrayIncludes` except that it accepts a comparator.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to inspect.
  	   * @param {*} target The value to search for.
  	   * @param {Function} comparator The comparator invoked per element.
  	   * @returns {boolean} Returns `true` if `target` is found, else `false`.
  	   */
  	  function arrayIncludesWith(array, value, comparator) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length;

  	    while (++index < length) {
  	      if (comparator(value, array[index])) {
  	        return true;
  	      }
  	    }
  	    return false;
  	  }

  	  /**
  	   * A specialized version of `_.map` for arrays without support for iteratee
  	   * shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Array} Returns the new mapped array.
  	   */
  	  function arrayMap(array, iteratee) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length,
  	        result = Array(length);

  	    while (++index < length) {
  	      result[index] = iteratee(array[index], index, array);
  	    }
  	    return result;
  	  }

  	  /**
  	   * Appends the elements of `values` to `array`.
  	   *
  	   * @private
  	   * @param {Array} array The array to modify.
  	   * @param {Array} values The values to append.
  	   * @returns {Array} Returns `array`.
  	   */
  	  function arrayPush(array, values) {
  	    var index = -1,
  	        length = values.length,
  	        offset = array.length;

  	    while (++index < length) {
  	      array[offset + index] = values[index];
  	    }
  	    return array;
  	  }

  	  /**
  	   * A specialized version of `_.reduce` for arrays without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @param {*} [accumulator] The initial value.
  	   * @param {boolean} [initAccum] Specify using the first element of `array` as
  	   *  the initial value.
  	   * @returns {*} Returns the accumulated value.
  	   */
  	  function arrayReduce(array, iteratee, accumulator, initAccum) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length;

  	    if (initAccum && length) {
  	      accumulator = array[++index];
  	    }
  	    while (++index < length) {
  	      accumulator = iteratee(accumulator, array[index], index, array);
  	    }
  	    return accumulator;
  	  }

  	  /**
  	   * A specialized version of `_.reduceRight` for arrays without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @param {*} [accumulator] The initial value.
  	   * @param {boolean} [initAccum] Specify using the last element of `array` as
  	   *  the initial value.
  	   * @returns {*} Returns the accumulated value.
  	   */
  	  function arrayReduceRight(array, iteratee, accumulator, initAccum) {
  	    var length = array == null ? 0 : array.length;
  	    if (initAccum && length) {
  	      accumulator = array[--length];
  	    }
  	    while (length--) {
  	      accumulator = iteratee(accumulator, array[length], length, array);
  	    }
  	    return accumulator;
  	  }

  	  /**
  	   * A specialized version of `_.some` for arrays without support for iteratee
  	   * shorthands.
  	   *
  	   * @private
  	   * @param {Array} [array] The array to iterate over.
  	   * @param {Function} predicate The function invoked per iteration.
  	   * @returns {boolean} Returns `true` if any element passes the predicate check,
  	   *  else `false`.
  	   */
  	  function arraySome(array, predicate) {
  	    var index = -1,
  	        length = array == null ? 0 : array.length;

  	    while (++index < length) {
  	      if (predicate(array[index], index, array)) {
  	        return true;
  	      }
  	    }
  	    return false;
  	  }

  	  /**
  	   * Gets the size of an ASCII `string`.
  	   *
  	   * @private
  	   * @param {string} string The string inspect.
  	   * @returns {number} Returns the string size.
  	   */
  	  var asciiSize = baseProperty('length');

  	  /**
  	   * Converts an ASCII `string` to an array.
  	   *
  	   * @private
  	   * @param {string} string The string to convert.
  	   * @returns {Array} Returns the converted array.
  	   */
  	  function asciiToArray(string) {
  	    return string.split('');
  	  }

  	  /**
  	   * Splits an ASCII `string` into an array of its words.
  	   *
  	   * @private
  	   * @param {string} The string to inspect.
  	   * @returns {Array} Returns the words of `string`.
  	   */
  	  function asciiWords(string) {
  	    return string.match(reAsciiWord) || [];
  	  }

  	  /**
  	   * The base implementation of methods like `_.findKey` and `_.findLastKey`,
  	   * without support for iteratee shorthands, which iterates over `collection`
  	   * using `eachFunc`.
  	   *
  	   * @private
  	   * @param {Array|Object} collection The collection to inspect.
  	   * @param {Function} predicate The function invoked per iteration.
  	   * @param {Function} eachFunc The function to iterate over `collection`.
  	   * @returns {*} Returns the found element or its key, else `undefined`.
  	   */
  	  function baseFindKey(collection, predicate, eachFunc) {
  	    var result;
  	    eachFunc(collection, function(value, key, collection) {
  	      if (predicate(value, key, collection)) {
  	        result = key;
  	        return false;
  	      }
  	    });
  	    return result;
  	  }

  	  /**
  	   * The base implementation of `_.findIndex` and `_.findLastIndex` without
  	   * support for iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} array The array to inspect.
  	   * @param {Function} predicate The function invoked per iteration.
  	   * @param {number} fromIndex The index to search from.
  	   * @param {boolean} [fromRight] Specify iterating from right to left.
  	   * @returns {number} Returns the index of the matched value, else `-1`.
  	   */
  	  function baseFindIndex(array, predicate, fromIndex, fromRight) {
  	    var length = array.length,
  	        index = fromIndex + (fromRight ? 1 : -1);

  	    while ((fromRight ? index-- : ++index < length)) {
  	      if (predicate(array[index], index, array)) {
  	        return index;
  	      }
  	    }
  	    return -1;
  	  }

  	  /**
  	   * The base implementation of `_.indexOf` without `fromIndex` bounds checks.
  	   *
  	   * @private
  	   * @param {Array} array The array to inspect.
  	   * @param {*} value The value to search for.
  	   * @param {number} fromIndex The index to search from.
  	   * @returns {number} Returns the index of the matched value, else `-1`.
  	   */
  	  function baseIndexOf(array, value, fromIndex) {
  	    return value === value
  	      ? strictIndexOf(array, value, fromIndex)
  	      : baseFindIndex(array, baseIsNaN, fromIndex);
  	  }

  	  /**
  	   * This function is like `baseIndexOf` except that it accepts a comparator.
  	   *
  	   * @private
  	   * @param {Array} array The array to inspect.
  	   * @param {*} value The value to search for.
  	   * @param {number} fromIndex The index to search from.
  	   * @param {Function} comparator The comparator invoked per element.
  	   * @returns {number} Returns the index of the matched value, else `-1`.
  	   */
  	  function baseIndexOfWith(array, value, fromIndex, comparator) {
  	    var index = fromIndex - 1,
  	        length = array.length;

  	    while (++index < length) {
  	      if (comparator(array[index], value)) {
  	        return index;
  	      }
  	    }
  	    return -1;
  	  }

  	  /**
  	   * The base implementation of `_.isNaN` without support for number objects.
  	   *
  	   * @private
  	   * @param {*} value The value to check.
  	   * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
  	   */
  	  function baseIsNaN(value) {
  	    return value !== value;
  	  }

  	  /**
  	   * The base implementation of `_.mean` and `_.meanBy` without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} array The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {number} Returns the mean.
  	   */
  	  function baseMean(array, iteratee) {
  	    var length = array == null ? 0 : array.length;
  	    return length ? (baseSum(array, iteratee) / length) : NAN;
  	  }

  	  /**
  	   * The base implementation of `_.property` without support for deep paths.
  	   *
  	   * @private
  	   * @param {string} key The key of the property to get.
  	   * @returns {Function} Returns the new accessor function.
  	   */
  	  function baseProperty(key) {
  	    return function(object) {
  	      return object == null ? undefined$1 : object[key];
  	    };
  	  }

  	  /**
  	   * The base implementation of `_.propertyOf` without support for deep paths.
  	   *
  	   * @private
  	   * @param {Object} object The object to query.
  	   * @returns {Function} Returns the new accessor function.
  	   */
  	  function basePropertyOf(object) {
  	    return function(key) {
  	      return object == null ? undefined$1 : object[key];
  	    };
  	  }

  	  /**
  	   * The base implementation of `_.reduce` and `_.reduceRight`, without support
  	   * for iteratee shorthands, which iterates over `collection` using `eachFunc`.
  	   *
  	   * @private
  	   * @param {Array|Object} collection The collection to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @param {*} accumulator The initial value.
  	   * @param {boolean} initAccum Specify using the first or last element of
  	   *  `collection` as the initial value.
  	   * @param {Function} eachFunc The function to iterate over `collection`.
  	   * @returns {*} Returns the accumulated value.
  	   */
  	  function baseReduce(collection, iteratee, accumulator, initAccum, eachFunc) {
  	    eachFunc(collection, function(value, index, collection) {
  	      accumulator = initAccum
  	        ? (initAccum = false, value)
  	        : iteratee(accumulator, value, index, collection);
  	    });
  	    return accumulator;
  	  }

  	  /**
  	   * The base implementation of `_.sortBy` which uses `comparer` to define the
  	   * sort order of `array` and replaces criteria objects with their corresponding
  	   * values.
  	   *
  	   * @private
  	   * @param {Array} array The array to sort.
  	   * @param {Function} comparer The function to define sort order.
  	   * @returns {Array} Returns `array`.
  	   */
  	  function baseSortBy(array, comparer) {
  	    var length = array.length;

  	    array.sort(comparer);
  	    while (length--) {
  	      array[length] = array[length].value;
  	    }
  	    return array;
  	  }

  	  /**
  	   * The base implementation of `_.sum` and `_.sumBy` without support for
  	   * iteratee shorthands.
  	   *
  	   * @private
  	   * @param {Array} array The array to iterate over.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {number} Returns the sum.
  	   */
  	  function baseSum(array, iteratee) {
  	    var result,
  	        index = -1,
  	        length = array.length;

  	    while (++index < length) {
  	      var current = iteratee(array[index]);
  	      if (current !== undefined$1) {
  	        result = result === undefined$1 ? current : (result + current);
  	      }
  	    }
  	    return result;
  	  }

  	  /**
  	   * The base implementation of `_.times` without support for iteratee shorthands
  	   * or max array length checks.
  	   *
  	   * @private
  	   * @param {number} n The number of times to invoke `iteratee`.
  	   * @param {Function} iteratee The function invoked per iteration.
  	   * @returns {Array} Returns the array of results.
  	   */
  	  function baseTimes(n, iteratee) {
  	    var index = -1,
  	        result = Array(n);

  	    while (++index < n) {
  	      result[index] = iteratee(index);
  	    }
  	    return result;
  	  }

  	  /**
  	   * The base implementation of `_.toPairs` and `_.toPairsIn` which creates an array
  	   * of key-value pairs for `object` corresponding to the property names of `props`.
  	   *
  	   * @private
  	   * @param {Object} object The object to query.
  	   * @param {Array} props The property names to get values for.
  	   * @returns {Object} Returns the key-value pairs.
  	   */
  	  function baseToPairs(object, props) {
  	    return arrayMap(props, function(key) {
  	      return [key, object[key]];
  	    });
  	  }

  	  /**
  	   * The base implementation of `_.trim`.
  	   *
  	   * @private
  	   * @param {string} string The string to trim.
  	   * @returns {string} Returns the trimmed string.
  	   */
  	  function baseTrim(string) {
  	    return string
  	      ? string.slice(0, trimmedEndIndex(string) + 1).replace(reTrimStart, '')
  	      : string;
  	  }

  	  /**
  	   * The base implementation of `_.unary` without support for storing metadata.
  	   *
  	   * @private
  	   * @param {Function} func The function to cap arguments for.
  	   * @returns {Function} Returns the new capped function.
  	   */
  	  function baseUnary(func) {
  	    return function(value) {
  	      return func(value);
  	    };
  	  }

  	  /**
  	   * The base implementation of `_.values` and `_.valuesIn` which creates an
  	   * array of `object` property values corresponding to the property names
  	   * of `props`.
  	   *
  	   * @private
  	   * @param {Object} object The object to query.
  	   * @param {Array} props The property names to get values for.
  	   * @returns {Object} Returns the array of property values.
  	   */
  	  function baseValues(object, props) {
  	    return arrayMap(props, function(key) {
  	      return object[key];
  	    });
  	  }

  	  /**
  	   * Checks if a `cache` value for `key` exists.
  	   *
  	   * @private
  	   * @param {Object} cache The cache to query.
  	   * @param {string} key The key of the entry to check.
  	   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	   */
  	  function cacheHas(cache, key) {
  	    return cache.has(key);
  	  }

  	  /**
  	   * Used by `_.trim` and `_.trimStart` to get the index of the first string symbol
  	   * that is not found in the character symbols.
  	   *
  	   * @private
  	   * @param {Array} strSymbols The string symbols to inspect.
  	   * @param {Array} chrSymbols The character symbols to find.
  	   * @returns {number} Returns the index of the first unmatched string symbol.
  	   */
  	  function charsStartIndex(strSymbols, chrSymbols) {
  	    var index = -1,
  	        length = strSymbols.length;

  	    while (++index < length && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  	    return index;
  	  }

  	  /**
  	   * Used by `_.trim` and `_.trimEnd` to get the index of the last string symbol
  	   * that is not found in the character symbols.
  	   *
  	   * @private
  	   * @param {Array} strSymbols The string symbols to inspect.
  	   * @param {Array} chrSymbols The character symbols to find.
  	   * @returns {number} Returns the index of the last unmatched string symbol.
  	   */
  	  function charsEndIndex(strSymbols, chrSymbols) {
  	    var index = strSymbols.length;

  	    while (index-- && baseIndexOf(chrSymbols, strSymbols[index], 0) > -1) {}
  	    return index;
  	  }

  	  /**
  	   * Gets the number of `placeholder` occurrences in `array`.
  	   *
  	   * @private
  	   * @param {Array} array The array to inspect.
  	   * @param {*} placeholder The placeholder to search for.
  	   * @returns {number} Returns the placeholder count.
  	   */
  	  function countHolders(array, placeholder) {
  	    var length = array.length,
  	        result = 0;

  	    while (length--) {
  	      if (array[length] === placeholder) {
  	        ++result;
  	      }
  	    }
  	    return result;
  	  }

  	  /**
  	   * Used by `_.deburr` to convert Latin-1 Supplement and Latin Extended-A
  	   * letters to basic Latin letters.
  	   *
  	   * @private
  	   * @param {string} letter The matched letter to deburr.
  	   * @returns {string} Returns the deburred letter.
  	   */
  	  var deburrLetter = basePropertyOf(deburredLetters);

  	  /**
  	   * Used by `_.escape` to convert characters to HTML entities.
  	   *
  	   * @private
  	   * @param {string} chr The matched character to escape.
  	   * @returns {string} Returns the escaped character.
  	   */
  	  var escapeHtmlChar = basePropertyOf(htmlEscapes);

  	  /**
  	   * Used by `_.template` to escape characters for inclusion in compiled string literals.
  	   *
  	   * @private
  	   * @param {string} chr The matched character to escape.
  	   * @returns {string} Returns the escaped character.
  	   */
  	  function escapeStringChar(chr) {
  	    return '\\' + stringEscapes[chr];
  	  }

  	  /**
  	   * Gets the value at `key` of `object`.
  	   *
  	   * @private
  	   * @param {Object} [object] The object to query.
  	   * @param {string} key The key of the property to get.
  	   * @returns {*} Returns the property value.
  	   */
  	  function getValue(object, key) {
  	    return object == null ? undefined$1 : object[key];
  	  }

  	  /**
  	   * Checks if `string` contains Unicode symbols.
  	   *
  	   * @private
  	   * @param {string} string The string to inspect.
  	   * @returns {boolean} Returns `true` if a symbol is found, else `false`.
  	   */
  	  function hasUnicode(string) {
  	    return reHasUnicode.test(string);
  	  }

  	  /**
  	   * Checks if `string` contains a word composed of Unicode symbols.
  	   *
  	   * @private
  	   * @param {string} string The string to inspect.
  	   * @returns {boolean} Returns `true` if a word is found, else `false`.
  	   */
  	  function hasUnicodeWord(string) {
  	    return reHasUnicodeWord.test(string);
  	  }

  	  /**
  	   * Converts `iterator` to an array.
  	   *
  	   * @private
  	   * @param {Object} iterator The iterator to convert.
  	   * @returns {Array} Returns the converted array.
  	   */
  	  function iteratorToArray(iterator) {
  	    var data,
  	        result = [];

  	    while (!(data = iterator.next()).done) {
  	      result.push(data.value);
  	    }
  	    return result;
  	  }

  	  /**
  	   * Converts `map` to its key-value pairs.
  	   *
  	   * @private
  	   * @param {Object} map The map to convert.
  	   * @returns {Array} Returns the key-value pairs.
  	   */
  	  function mapToArray(map) {
  	    var index = -1,
  	        result = Array(map.size);

  	    map.forEach(function(value, key) {
  	      result[++index] = [key, value];
  	    });
  	    return result;
  	  }

  	  /**
  	   * Creates a unary function that invokes `func` with its argument transformed.
  	   *
  	   * @private
  	   * @param {Function} func The function to wrap.
  	   * @param {Function} transform The argument transform.
  	   * @returns {Function} Returns the new function.
  	   */
  	  function overArg(func, transform) {
  	    return function(arg) {
  	      return func(transform(arg));
  	    };
  	  }

  	  /**
  	   * Replaces all `placeholder` elements in `array` with an internal placeholder
  	   * and returns an array of their indexes.
  	   *
  	   * @private
  	   * @param {Array} array The array to modify.
  	   * @param {*} placeholder The placeholder to replace.
  	   * @returns {Array} Returns the new array of placeholder indexes.
  	   */
  	  function replaceHolders(array, placeholder) {
  	    var index = -1,
  	        length = array.length,
  	        resIndex = 0,
  	        result = [];

  	    while (++index < length) {
  	      var value = array[index];
  	      if (value === placeholder || value === PLACEHOLDER) {
  	        array[index] = PLACEHOLDER;
  	        result[resIndex++] = index;
  	      }
  	    }
  	    return result;
  	  }

  	  /**
  	   * Converts `set` to an array of its values.
  	   *
  	   * @private
  	   * @param {Object} set The set to convert.
  	   * @returns {Array} Returns the values.
  	   */
  	  function setToArray(set) {
  	    var index = -1,
  	        result = Array(set.size);

  	    set.forEach(function(value) {
  	      result[++index] = value;
  	    });
  	    return result;
  	  }

  	  /**
  	   * Converts `set` to its value-value pairs.
  	   *
  	   * @private
  	   * @param {Object} set The set to convert.
  	   * @returns {Array} Returns the value-value pairs.
  	   */
  	  function setToPairs(set) {
  	    var index = -1,
  	        result = Array(set.size);

  	    set.forEach(function(value) {
  	      result[++index] = [value, value];
  	    });
  	    return result;
  	  }

  	  /**
  	   * A specialized version of `_.indexOf` which performs strict equality
  	   * comparisons of values, i.e. `===`.
  	   *
  	   * @private
  	   * @param {Array} array The array to inspect.
  	   * @param {*} value The value to search for.
  	   * @param {number} fromIndex The index to search from.
  	   * @returns {number} Returns the index of the matched value, else `-1`.
  	   */
  	  function strictIndexOf(array, value, fromIndex) {
  	    var index = fromIndex - 1,
  	        length = array.length;

  	    while (++index < length) {
  	      if (array[index] === value) {
  	        return index;
  	      }
  	    }
  	    return -1;
  	  }

  	  /**
  	   * A specialized version of `_.lastIndexOf` which performs strict equality
  	   * comparisons of values, i.e. `===`.
  	   *
  	   * @private
  	   * @param {Array} array The array to inspect.
  	   * @param {*} value The value to search for.
  	   * @param {number} fromIndex The index to search from.
  	   * @returns {number} Returns the index of the matched value, else `-1`.
  	   */
  	  function strictLastIndexOf(array, value, fromIndex) {
  	    var index = fromIndex + 1;
  	    while (index--) {
  	      if (array[index] === value) {
  	        return index;
  	      }
  	    }
  	    return index;
  	  }

  	  /**
  	   * Gets the number of symbols in `string`.
  	   *
  	   * @private
  	   * @param {string} string The string to inspect.
  	   * @returns {number} Returns the string size.
  	   */
  	  function stringSize(string) {
  	    return hasUnicode(string)
  	      ? unicodeSize(string)
  	      : asciiSize(string);
  	  }

  	  /**
  	   * Converts `string` to an array.
  	   *
  	   * @private
  	   * @param {string} string The string to convert.
  	   * @returns {Array} Returns the converted array.
  	   */
  	  function stringToArray(string) {
  	    return hasUnicode(string)
  	      ? unicodeToArray(string)
  	      : asciiToArray(string);
  	  }

  	  /**
  	   * Used by `_.trim` and `_.trimEnd` to get the index of the last non-whitespace
  	   * character of `string`.
  	   *
  	   * @private
  	   * @param {string} string The string to inspect.
  	   * @returns {number} Returns the index of the last non-whitespace character.
  	   */
  	  function trimmedEndIndex(string) {
  	    var index = string.length;

  	    while (index-- && reWhitespace.test(string.charAt(index))) {}
  	    return index;
  	  }

  	  /**
  	   * Used by `_.unescape` to convert HTML entities to characters.
  	   *
  	   * @private
  	   * @param {string} chr The matched character to unescape.
  	   * @returns {string} Returns the unescaped character.
  	   */
  	  var unescapeHtmlChar = basePropertyOf(htmlUnescapes);

  	  /**
  	   * Gets the size of a Unicode `string`.
  	   *
  	   * @private
  	   * @param {string} string The string inspect.
  	   * @returns {number} Returns the string size.
  	   */
  	  function unicodeSize(string) {
  	    var result = reUnicode.lastIndex = 0;
  	    while (reUnicode.test(string)) {
  	      ++result;
  	    }
  	    return result;
  	  }

  	  /**
  	   * Converts a Unicode `string` to an array.
  	   *
  	   * @private
  	   * @param {string} string The string to convert.
  	   * @returns {Array} Returns the converted array.
  	   */
  	  function unicodeToArray(string) {
  	    return string.match(reUnicode) || [];
  	  }

  	  /**
  	   * Splits a Unicode `string` into an array of its words.
  	   *
  	   * @private
  	   * @param {string} The string to inspect.
  	   * @returns {Array} Returns the words of `string`.
  	   */
  	  function unicodeWords(string) {
  	    return string.match(reUnicodeWord) || [];
  	  }

  	  /*--------------------------------------------------------------------------*/

  	  /**
  	   * Create a new pristine `lodash` function using the `context` object.
  	   *
  	   * @static
  	   * @memberOf _
  	   * @since 1.1.0
  	   * @category Util
  	   * @param {Object} [context=root] The context object.
  	   * @returns {Function} Returns a new `lodash` function.
  	   * @example
  	   *
  	   * _.mixin({ 'foo': _.constant('foo') });
  	   *
  	   * var lodash = _.runInContext();
  	   * lodash.mixin({ 'bar': lodash.constant('bar') });
  	   *
  	   * _.isFunction(_.foo);
  	   * // => true
  	   * _.isFunction(_.bar);
  	   * // => false
  	   *
  	   * lodash.isFunction(lodash.foo);
  	   * // => false
  	   * lodash.isFunction(lodash.bar);
  	   * // => true
  	   *
  	   * // Create a suped-up `defer` in Node.js.
  	   * var defer = _.runInContext({ 'setTimeout': setImmediate }).defer;
  	   */
  	  var runInContext = (function runInContext(context) {
  	    context = context == null ? root : _.defaults(root.Object(), context, _.pick(root, contextProps));

  	    /** Built-in constructor references. */
  	    var Array = context.Array,
  	        Date = context.Date,
  	        Error = context.Error,
  	        Function = context.Function,
  	        Math = context.Math,
  	        Object = context.Object,
  	        RegExp = context.RegExp,
  	        String = context.String,
  	        TypeError = context.TypeError;

  	    /** Used for built-in method references. */
  	    var arrayProto = Array.prototype,
  	        funcProto = Function.prototype,
  	        objectProto = Object.prototype;

  	    /** Used to detect overreaching core-js shims. */
  	    var coreJsData = context['__core-js_shared__'];

  	    /** Used to resolve the decompiled source of functions. */
  	    var funcToString = funcProto.toString;

  	    /** Used to check objects for own properties. */
  	    var hasOwnProperty = objectProto.hasOwnProperty;

  	    /** Used to generate unique IDs. */
  	    var idCounter = 0;

  	    /** Used to detect methods masquerading as native. */
  	    var maskSrcKey = (function() {
  	      var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
  	      return uid ? ('Symbol(src)_1.' + uid) : '';
  	    }());

  	    /**
  	     * Used to resolve the
  	     * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
  	     * of values.
  	     */
  	    var nativeObjectToString = objectProto.toString;

  	    /** Used to infer the `Object` constructor. */
  	    var objectCtorString = funcToString.call(Object);

  	    /** Used to restore the original `_` reference in `_.noConflict`. */
  	    var oldDash = root._;

  	    /** Used to detect if a method is native. */
  	    var reIsNative = RegExp('^' +
  	      funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
  	      .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  	    );

  	    /** Built-in value references. */
  	    var Buffer = moduleExports ? context.Buffer : undefined$1,
  	        Symbol = context.Symbol,
  	        Uint8Array = context.Uint8Array,
  	        allocUnsafe = Buffer ? Buffer.allocUnsafe : undefined$1,
  	        getPrototype = overArg(Object.getPrototypeOf, Object),
  	        objectCreate = Object.create,
  	        propertyIsEnumerable = objectProto.propertyIsEnumerable,
  	        splice = arrayProto.splice,
  	        spreadableSymbol = Symbol ? Symbol.isConcatSpreadable : undefined$1,
  	        symIterator = Symbol ? Symbol.iterator : undefined$1,
  	        symToStringTag = Symbol ? Symbol.toStringTag : undefined$1;

  	    var defineProperty = (function() {
  	      try {
  	        var func = getNative(Object, 'defineProperty');
  	        func({}, '', {});
  	        return func;
  	      } catch (e) {}
  	    }());

  	    /** Mocked built-ins. */
  	    var ctxClearTimeout = context.clearTimeout !== root.clearTimeout && context.clearTimeout,
  	        ctxNow = Date && Date.now !== root.Date.now && Date.now,
  	        ctxSetTimeout = context.setTimeout !== root.setTimeout && context.setTimeout;

  	    /* Built-in method references for those with the same name as other `lodash` methods. */
  	    var nativeCeil = Math.ceil,
  	        nativeFloor = Math.floor,
  	        nativeGetSymbols = Object.getOwnPropertySymbols,
  	        nativeIsBuffer = Buffer ? Buffer.isBuffer : undefined$1,
  	        nativeIsFinite = context.isFinite,
  	        nativeJoin = arrayProto.join,
  	        nativeKeys = overArg(Object.keys, Object),
  	        nativeMax = Math.max,
  	        nativeMin = Math.min,
  	        nativeNow = Date.now,
  	        nativeParseInt = context.parseInt,
  	        nativeRandom = Math.random,
  	        nativeReverse = arrayProto.reverse;

  	    /* Built-in method references that are verified to be native. */
  	    var DataView = getNative(context, 'DataView'),
  	        Map = getNative(context, 'Map'),
  	        Promise = getNative(context, 'Promise'),
  	        Set = getNative(context, 'Set'),
  	        WeakMap = getNative(context, 'WeakMap'),
  	        nativeCreate = getNative(Object, 'create');

  	    /** Used to store function metadata. */
  	    var metaMap = WeakMap && new WeakMap;

  	    /** Used to lookup unminified function names. */
  	    var realNames = {};

  	    /** Used to detect maps, sets, and weakmaps. */
  	    var dataViewCtorString = toSource(DataView),
  	        mapCtorString = toSource(Map),
  	        promiseCtorString = toSource(Promise),
  	        setCtorString = toSource(Set),
  	        weakMapCtorString = toSource(WeakMap);

  	    /** Used to convert symbols to primitives and strings. */
  	    var symbolProto = Symbol ? Symbol.prototype : undefined$1,
  	        symbolValueOf = symbolProto ? symbolProto.valueOf : undefined$1,
  	        symbolToString = symbolProto ? symbolProto.toString : undefined$1;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates a `lodash` object which wraps `value` to enable implicit method
  	     * chain sequences. Methods that operate on and return arrays, collections,
  	     * and functions can be chained together. Methods that retrieve a single value
  	     * or may return a primitive value will automatically end the chain sequence
  	     * and return the unwrapped value. Otherwise, the value must be unwrapped
  	     * with `_#value`.
  	     *
  	     * Explicit chain sequences, which must be unwrapped with `_#value`, may be
  	     * enabled using `_.chain`.
  	     *
  	     * The execution of chained methods is lazy, that is, it's deferred until
  	     * `_#value` is implicitly or explicitly called.
  	     *
  	     * Lazy evaluation allows several methods to support shortcut fusion.
  	     * Shortcut fusion is an optimization to merge iteratee calls; this avoids
  	     * the creation of intermediate arrays and can greatly reduce the number of
  	     * iteratee executions. Sections of a chain sequence qualify for shortcut
  	     * fusion if the section is applied to an array and iteratees accept only
  	     * one argument. The heuristic for whether a section qualifies for shortcut
  	     * fusion is subject to change.
  	     *
  	     * Chaining is supported in custom builds as long as the `_#value` method is
  	     * directly or indirectly included in the build.
  	     *
  	     * In addition to lodash methods, wrappers have `Array` and `String` methods.
  	     *
  	     * The wrapper `Array` methods are:
  	     * `concat`, `join`, `pop`, `push`, `shift`, `sort`, `splice`, and `unshift`
  	     *
  	     * The wrapper `String` methods are:
  	     * `replace` and `split`
  	     *
  	     * The wrapper methods that support shortcut fusion are:
  	     * `at`, `compact`, `drop`, `dropRight`, `dropWhile`, `filter`, `find`,
  	     * `findLast`, `head`, `initial`, `last`, `map`, `reject`, `reverse`, `slice`,
  	     * `tail`, `take`, `takeRight`, `takeRightWhile`, `takeWhile`, and `toArray`
  	     *
  	     * The chainable wrapper methods are:
  	     * `after`, `ary`, `assign`, `assignIn`, `assignInWith`, `assignWith`, `at`,
  	     * `before`, `bind`, `bindAll`, `bindKey`, `castArray`, `chain`, `chunk`,
  	     * `commit`, `compact`, `concat`, `conforms`, `constant`, `countBy`, `create`,
  	     * `curry`, `debounce`, `defaults`, `defaultsDeep`, `defer`, `delay`,
  	     * `difference`, `differenceBy`, `differenceWith`, `drop`, `dropRight`,
  	     * `dropRightWhile`, `dropWhile`, `extend`, `extendWith`, `fill`, `filter`,
  	     * `flatMap`, `flatMapDeep`, `flatMapDepth`, `flatten`, `flattenDeep`,
  	     * `flattenDepth`, `flip`, `flow`, `flowRight`, `fromPairs`, `functions`,
  	     * `functionsIn`, `groupBy`, `initial`, `intersection`, `intersectionBy`,
  	     * `intersectionWith`, `invert`, `invertBy`, `invokeMap`, `iteratee`, `keyBy`,
  	     * `keys`, `keysIn`, `map`, `mapKeys`, `mapValues`, `matches`, `matchesProperty`,
  	     * `memoize`, `merge`, `mergeWith`, `method`, `methodOf`, `mixin`, `negate`,
  	     * `nthArg`, `omit`, `omitBy`, `once`, `orderBy`, `over`, `overArgs`,
  	     * `overEvery`, `overSome`, `partial`, `partialRight`, `partition`, `pick`,
  	     * `pickBy`, `plant`, `property`, `propertyOf`, `pull`, `pullAll`, `pullAllBy`,
  	     * `pullAllWith`, `pullAt`, `push`, `range`, `rangeRight`, `rearg`, `reject`,
  	     * `remove`, `rest`, `reverse`, `sampleSize`, `set`, `setWith`, `shuffle`,
  	     * `slice`, `sort`, `sortBy`, `splice`, `spread`, `tail`, `take`, `takeRight`,
  	     * `takeRightWhile`, `takeWhile`, `tap`, `throttle`, `thru`, `toArray`,
  	     * `toPairs`, `toPairsIn`, `toPath`, `toPlainObject`, `transform`, `unary`,
  	     * `union`, `unionBy`, `unionWith`, `uniq`, `uniqBy`, `uniqWith`, `unset`,
  	     * `unshift`, `unzip`, `unzipWith`, `update`, `updateWith`, `values`,
  	     * `valuesIn`, `without`, `wrap`, `xor`, `xorBy`, `xorWith`, `zip`,
  	     * `zipObject`, `zipObjectDeep`, and `zipWith`
  	     *
  	     * The wrapper methods that are **not** chainable by default are:
  	     * `add`, `attempt`, `camelCase`, `capitalize`, `ceil`, `clamp`, `clone`,
  	     * `cloneDeep`, `cloneDeepWith`, `cloneWith`, `conformsTo`, `deburr`,
  	     * `defaultTo`, `divide`, `each`, `eachRight`, `endsWith`, `eq`, `escape`,
  	     * `escapeRegExp`, `every`, `find`, `findIndex`, `findKey`, `findLast`,
  	     * `findLastIndex`, `findLastKey`, `first`, `floor`, `forEach`, `forEachRight`,
  	     * `forIn`, `forInRight`, `forOwn`, `forOwnRight`, `get`, `gt`, `gte`, `has`,
  	     * `hasIn`, `head`, `identity`, `includes`, `indexOf`, `inRange`, `invoke`,
  	     * `isArguments`, `isArray`, `isArrayBuffer`, `isArrayLike`, `isArrayLikeObject`,
  	     * `isBoolean`, `isBuffer`, `isDate`, `isElement`, `isEmpty`, `isEqual`,
  	     * `isEqualWith`, `isError`, `isFinite`, `isFunction`, `isInteger`, `isLength`,
  	     * `isMap`, `isMatch`, `isMatchWith`, `isNaN`, `isNative`, `isNil`, `isNull`,
  	     * `isNumber`, `isObject`, `isObjectLike`, `isPlainObject`, `isRegExp`,
  	     * `isSafeInteger`, `isSet`, `isString`, `isUndefined`, `isTypedArray`,
  	     * `isWeakMap`, `isWeakSet`, `join`, `kebabCase`, `last`, `lastIndexOf`,
  	     * `lowerCase`, `lowerFirst`, `lt`, `lte`, `max`, `maxBy`, `mean`, `meanBy`,
  	     * `min`, `minBy`, `multiply`, `noConflict`, `noop`, `now`, `nth`, `pad`,
  	     * `padEnd`, `padStart`, `parseInt`, `pop`, `random`, `reduce`, `reduceRight`,
  	     * `repeat`, `result`, `round`, `runInContext`, `sample`, `shift`, `size`,
  	     * `snakeCase`, `some`, `sortedIndex`, `sortedIndexBy`, `sortedLastIndex`,
  	     * `sortedLastIndexBy`, `startCase`, `startsWith`, `stubArray`, `stubFalse`,
  	     * `stubObject`, `stubString`, `stubTrue`, `subtract`, `sum`, `sumBy`,
  	     * `template`, `times`, `toFinite`, `toInteger`, `toJSON`, `toLength`,
  	     * `toLower`, `toNumber`, `toSafeInteger`, `toString`, `toUpper`, `trim`,
  	     * `trimEnd`, `trimStart`, `truncate`, `unescape`, `uniqueId`, `upperCase`,
  	     * `upperFirst`, `value`, and `words`
  	     *
  	     * @name _
  	     * @constructor
  	     * @category Seq
  	     * @param {*} value The value to wrap in a `lodash` instance.
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * function square(n) {
  	     *   return n * n;
  	     * }
  	     *
  	     * var wrapped = _([1, 2, 3]);
  	     *
  	     * // Returns an unwrapped value.
  	     * wrapped.reduce(_.add);
  	     * // => 6
  	     *
  	     * // Returns a wrapped value.
  	     * var squares = wrapped.map(square);
  	     *
  	     * _.isArray(squares);
  	     * // => false
  	     *
  	     * _.isArray(squares.value());
  	     * // => true
  	     */
  	    function lodash(value) {
  	      if (isObjectLike(value) && !isArray(value) && !(value instanceof LazyWrapper)) {
  	        if (value instanceof LodashWrapper) {
  	          return value;
  	        }
  	        if (hasOwnProperty.call(value, '__wrapped__')) {
  	          return wrapperClone(value);
  	        }
  	      }
  	      return new LodashWrapper(value);
  	    }

  	    /**
  	     * The base implementation of `_.create` without support for assigning
  	     * properties to the created object.
  	     *
  	     * @private
  	     * @param {Object} proto The object to inherit from.
  	     * @returns {Object} Returns the new object.
  	     */
  	    var baseCreate = (function() {
  	      function object() {}
  	      return function(proto) {
  	        if (!isObject(proto)) {
  	          return {};
  	        }
  	        if (objectCreate) {
  	          return objectCreate(proto);
  	        }
  	        object.prototype = proto;
  	        var result = new object;
  	        object.prototype = undefined$1;
  	        return result;
  	      };
  	    }());

  	    /**
  	     * The function whose prototype chain sequence wrappers inherit from.
  	     *
  	     * @private
  	     */
  	    function baseLodash() {
  	      // No operation performed.
  	    }

  	    /**
  	     * The base constructor for creating `lodash` wrapper objects.
  	     *
  	     * @private
  	     * @param {*} value The value to wrap.
  	     * @param {boolean} [chainAll] Enable explicit method chain sequences.
  	     */
  	    function LodashWrapper(value, chainAll) {
  	      this.__wrapped__ = value;
  	      this.__actions__ = [];
  	      this.__chain__ = !!chainAll;
  	      this.__index__ = 0;
  	      this.__values__ = undefined$1;
  	    }

  	    /**
  	     * By default, the template delimiters used by lodash are like those in
  	     * embedded Ruby (ERB) as well as ES2015 template strings. Change the
  	     * following template settings to use alternative delimiters.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @type {Object}
  	     */
  	    lodash.templateSettings = {

  	      /**
  	       * Used to detect `data` property values to be HTML-escaped.
  	       *
  	       * @memberOf _.templateSettings
  	       * @type {RegExp}
  	       */
  	      'escape': reEscape,

  	      /**
  	       * Used to detect code to be evaluated.
  	       *
  	       * @memberOf _.templateSettings
  	       * @type {RegExp}
  	       */
  	      'evaluate': reEvaluate,

  	      /**
  	       * Used to detect `data` property values to inject.
  	       *
  	       * @memberOf _.templateSettings
  	       * @type {RegExp}
  	       */
  	      'interpolate': reInterpolate,

  	      /**
  	       * Used to reference the data object in the template text.
  	       *
  	       * @memberOf _.templateSettings
  	       * @type {string}
  	       */
  	      'variable': '',

  	      /**
  	       * Used to import variables into the compiled template.
  	       *
  	       * @memberOf _.templateSettings
  	       * @type {Object}
  	       */
  	      'imports': {

  	        /**
  	         * A reference to the `lodash` function.
  	         *
  	         * @memberOf _.templateSettings.imports
  	         * @type {Function}
  	         */
  	        '_': lodash
  	      }
  	    };

  	    // Ensure wrappers are instances of `baseLodash`.
  	    lodash.prototype = baseLodash.prototype;
  	    lodash.prototype.constructor = lodash;

  	    LodashWrapper.prototype = baseCreate(baseLodash.prototype);
  	    LodashWrapper.prototype.constructor = LodashWrapper;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates a lazy wrapper object which wraps `value` to enable lazy evaluation.
  	     *
  	     * @private
  	     * @constructor
  	     * @param {*} value The value to wrap.
  	     */
  	    function LazyWrapper(value) {
  	      this.__wrapped__ = value;
  	      this.__actions__ = [];
  	      this.__dir__ = 1;
  	      this.__filtered__ = false;
  	      this.__iteratees__ = [];
  	      this.__takeCount__ = MAX_ARRAY_LENGTH;
  	      this.__views__ = [];
  	    }

  	    /**
  	     * Creates a clone of the lazy wrapper object.
  	     *
  	     * @private
  	     * @name clone
  	     * @memberOf LazyWrapper
  	     * @returns {Object} Returns the cloned `LazyWrapper` object.
  	     */
  	    function lazyClone() {
  	      var result = new LazyWrapper(this.__wrapped__);
  	      result.__actions__ = copyArray(this.__actions__);
  	      result.__dir__ = this.__dir__;
  	      result.__filtered__ = this.__filtered__;
  	      result.__iteratees__ = copyArray(this.__iteratees__);
  	      result.__takeCount__ = this.__takeCount__;
  	      result.__views__ = copyArray(this.__views__);
  	      return result;
  	    }

  	    /**
  	     * Reverses the direction of lazy iteration.
  	     *
  	     * @private
  	     * @name reverse
  	     * @memberOf LazyWrapper
  	     * @returns {Object} Returns the new reversed `LazyWrapper` object.
  	     */
  	    function lazyReverse() {
  	      if (this.__filtered__) {
  	        var result = new LazyWrapper(this);
  	        result.__dir__ = -1;
  	        result.__filtered__ = true;
  	      } else {
  	        result = this.clone();
  	        result.__dir__ *= -1;
  	      }
  	      return result;
  	    }

  	    /**
  	     * Extracts the unwrapped value from its lazy wrapper.
  	     *
  	     * @private
  	     * @name value
  	     * @memberOf LazyWrapper
  	     * @returns {*} Returns the unwrapped value.
  	     */
  	    function lazyValue() {
  	      var array = this.__wrapped__.value(),
  	          dir = this.__dir__,
  	          isArr = isArray(array),
  	          isRight = dir < 0,
  	          arrLength = isArr ? array.length : 0,
  	          view = getView(0, arrLength, this.__views__),
  	          start = view.start,
  	          end = view.end,
  	          length = end - start,
  	          index = isRight ? end : (start - 1),
  	          iteratees = this.__iteratees__,
  	          iterLength = iteratees.length,
  	          resIndex = 0,
  	          takeCount = nativeMin(length, this.__takeCount__);

  	      if (!isArr || (!isRight && arrLength == length && takeCount == length)) {
  	        return baseWrapperValue(array, this.__actions__);
  	      }
  	      var result = [];

  	      outer:
  	      while (length-- && resIndex < takeCount) {
  	        index += dir;

  	        var iterIndex = -1,
  	            value = array[index];

  	        while (++iterIndex < iterLength) {
  	          var data = iteratees[iterIndex],
  	              iteratee = data.iteratee,
  	              type = data.type,
  	              computed = iteratee(value);

  	          if (type == LAZY_MAP_FLAG) {
  	            value = computed;
  	          } else if (!computed) {
  	            if (type == LAZY_FILTER_FLAG) {
  	              continue outer;
  	            } else {
  	              break outer;
  	            }
  	          }
  	        }
  	        result[resIndex++] = value;
  	      }
  	      return result;
  	    }

  	    // Ensure `LazyWrapper` is an instance of `baseLodash`.
  	    LazyWrapper.prototype = baseCreate(baseLodash.prototype);
  	    LazyWrapper.prototype.constructor = LazyWrapper;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates a hash object.
  	     *
  	     * @private
  	     * @constructor
  	     * @param {Array} [entries] The key-value pairs to cache.
  	     */
  	    function Hash(entries) {
  	      var index = -1,
  	          length = entries == null ? 0 : entries.length;

  	      this.clear();
  	      while (++index < length) {
  	        var entry = entries[index];
  	        this.set(entry[0], entry[1]);
  	      }
  	    }

  	    /**
  	     * Removes all key-value entries from the hash.
  	     *
  	     * @private
  	     * @name clear
  	     * @memberOf Hash
  	     */
  	    function hashClear() {
  	      this.__data__ = nativeCreate ? nativeCreate(null) : {};
  	      this.size = 0;
  	    }

  	    /**
  	     * Removes `key` and its value from the hash.
  	     *
  	     * @private
  	     * @name delete
  	     * @memberOf Hash
  	     * @param {Object} hash The hash to modify.
  	     * @param {string} key The key of the value to remove.
  	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  	     */
  	    function hashDelete(key) {
  	      var result = this.has(key) && delete this.__data__[key];
  	      this.size -= result ? 1 : 0;
  	      return result;
  	    }

  	    /**
  	     * Gets the hash value for `key`.
  	     *
  	     * @private
  	     * @name get
  	     * @memberOf Hash
  	     * @param {string} key The key of the value to get.
  	     * @returns {*} Returns the entry value.
  	     */
  	    function hashGet(key) {
  	      var data = this.__data__;
  	      if (nativeCreate) {
  	        var result = data[key];
  	        return result === HASH_UNDEFINED ? undefined$1 : result;
  	      }
  	      return hasOwnProperty.call(data, key) ? data[key] : undefined$1;
  	    }

  	    /**
  	     * Checks if a hash value for `key` exists.
  	     *
  	     * @private
  	     * @name has
  	     * @memberOf Hash
  	     * @param {string} key The key of the entry to check.
  	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	     */
  	    function hashHas(key) {
  	      var data = this.__data__;
  	      return nativeCreate ? (data[key] !== undefined$1) : hasOwnProperty.call(data, key);
  	    }

  	    /**
  	     * Sets the hash `key` to `value`.
  	     *
  	     * @private
  	     * @name set
  	     * @memberOf Hash
  	     * @param {string} key The key of the value to set.
  	     * @param {*} value The value to set.
  	     * @returns {Object} Returns the hash instance.
  	     */
  	    function hashSet(key, value) {
  	      var data = this.__data__;
  	      this.size += this.has(key) ? 0 : 1;
  	      data[key] = (nativeCreate && value === undefined$1) ? HASH_UNDEFINED : value;
  	      return this;
  	    }

  	    // Add methods to `Hash`.
  	    Hash.prototype.clear = hashClear;
  	    Hash.prototype['delete'] = hashDelete;
  	    Hash.prototype.get = hashGet;
  	    Hash.prototype.has = hashHas;
  	    Hash.prototype.set = hashSet;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates an list cache object.
  	     *
  	     * @private
  	     * @constructor
  	     * @param {Array} [entries] The key-value pairs to cache.
  	     */
  	    function ListCache(entries) {
  	      var index = -1,
  	          length = entries == null ? 0 : entries.length;

  	      this.clear();
  	      while (++index < length) {
  	        var entry = entries[index];
  	        this.set(entry[0], entry[1]);
  	      }
  	    }

  	    /**
  	     * Removes all key-value entries from the list cache.
  	     *
  	     * @private
  	     * @name clear
  	     * @memberOf ListCache
  	     */
  	    function listCacheClear() {
  	      this.__data__ = [];
  	      this.size = 0;
  	    }

  	    /**
  	     * Removes `key` and its value from the list cache.
  	     *
  	     * @private
  	     * @name delete
  	     * @memberOf ListCache
  	     * @param {string} key The key of the value to remove.
  	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  	     */
  	    function listCacheDelete(key) {
  	      var data = this.__data__,
  	          index = assocIndexOf(data, key);

  	      if (index < 0) {
  	        return false;
  	      }
  	      var lastIndex = data.length - 1;
  	      if (index == lastIndex) {
  	        data.pop();
  	      } else {
  	        splice.call(data, index, 1);
  	      }
  	      --this.size;
  	      return true;
  	    }

  	    /**
  	     * Gets the list cache value for `key`.
  	     *
  	     * @private
  	     * @name get
  	     * @memberOf ListCache
  	     * @param {string} key The key of the value to get.
  	     * @returns {*} Returns the entry value.
  	     */
  	    function listCacheGet(key) {
  	      var data = this.__data__,
  	          index = assocIndexOf(data, key);

  	      return index < 0 ? undefined$1 : data[index][1];
  	    }

  	    /**
  	     * Checks if a list cache value for `key` exists.
  	     *
  	     * @private
  	     * @name has
  	     * @memberOf ListCache
  	     * @param {string} key The key of the entry to check.
  	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	     */
  	    function listCacheHas(key) {
  	      return assocIndexOf(this.__data__, key) > -1;
  	    }

  	    /**
  	     * Sets the list cache `key` to `value`.
  	     *
  	     * @private
  	     * @name set
  	     * @memberOf ListCache
  	     * @param {string} key The key of the value to set.
  	     * @param {*} value The value to set.
  	     * @returns {Object} Returns the list cache instance.
  	     */
  	    function listCacheSet(key, value) {
  	      var data = this.__data__,
  	          index = assocIndexOf(data, key);

  	      if (index < 0) {
  	        ++this.size;
  	        data.push([key, value]);
  	      } else {
  	        data[index][1] = value;
  	      }
  	      return this;
  	    }

  	    // Add methods to `ListCache`.
  	    ListCache.prototype.clear = listCacheClear;
  	    ListCache.prototype['delete'] = listCacheDelete;
  	    ListCache.prototype.get = listCacheGet;
  	    ListCache.prototype.has = listCacheHas;
  	    ListCache.prototype.set = listCacheSet;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates a map cache object to store key-value pairs.
  	     *
  	     * @private
  	     * @constructor
  	     * @param {Array} [entries] The key-value pairs to cache.
  	     */
  	    function MapCache(entries) {
  	      var index = -1,
  	          length = entries == null ? 0 : entries.length;

  	      this.clear();
  	      while (++index < length) {
  	        var entry = entries[index];
  	        this.set(entry[0], entry[1]);
  	      }
  	    }

  	    /**
  	     * Removes all key-value entries from the map.
  	     *
  	     * @private
  	     * @name clear
  	     * @memberOf MapCache
  	     */
  	    function mapCacheClear() {
  	      this.size = 0;
  	      this.__data__ = {
  	        'hash': new Hash,
  	        'map': new (Map || ListCache),
  	        'string': new Hash
  	      };
  	    }

  	    /**
  	     * Removes `key` and its value from the map.
  	     *
  	     * @private
  	     * @name delete
  	     * @memberOf MapCache
  	     * @param {string} key The key of the value to remove.
  	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  	     */
  	    function mapCacheDelete(key) {
  	      var result = getMapData(this, key)['delete'](key);
  	      this.size -= result ? 1 : 0;
  	      return result;
  	    }

  	    /**
  	     * Gets the map value for `key`.
  	     *
  	     * @private
  	     * @name get
  	     * @memberOf MapCache
  	     * @param {string} key The key of the value to get.
  	     * @returns {*} Returns the entry value.
  	     */
  	    function mapCacheGet(key) {
  	      return getMapData(this, key).get(key);
  	    }

  	    /**
  	     * Checks if a map value for `key` exists.
  	     *
  	     * @private
  	     * @name has
  	     * @memberOf MapCache
  	     * @param {string} key The key of the entry to check.
  	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	     */
  	    function mapCacheHas(key) {
  	      return getMapData(this, key).has(key);
  	    }

  	    /**
  	     * Sets the map `key` to `value`.
  	     *
  	     * @private
  	     * @name set
  	     * @memberOf MapCache
  	     * @param {string} key The key of the value to set.
  	     * @param {*} value The value to set.
  	     * @returns {Object} Returns the map cache instance.
  	     */
  	    function mapCacheSet(key, value) {
  	      var data = getMapData(this, key),
  	          size = data.size;

  	      data.set(key, value);
  	      this.size += data.size == size ? 0 : 1;
  	      return this;
  	    }

  	    // Add methods to `MapCache`.
  	    MapCache.prototype.clear = mapCacheClear;
  	    MapCache.prototype['delete'] = mapCacheDelete;
  	    MapCache.prototype.get = mapCacheGet;
  	    MapCache.prototype.has = mapCacheHas;
  	    MapCache.prototype.set = mapCacheSet;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     *
  	     * Creates an array cache object to store unique values.
  	     *
  	     * @private
  	     * @constructor
  	     * @param {Array} [values] The values to cache.
  	     */
  	    function SetCache(values) {
  	      var index = -1,
  	          length = values == null ? 0 : values.length;

  	      this.__data__ = new MapCache;
  	      while (++index < length) {
  	        this.add(values[index]);
  	      }
  	    }

  	    /**
  	     * Adds `value` to the array cache.
  	     *
  	     * @private
  	     * @name add
  	     * @memberOf SetCache
  	     * @alias push
  	     * @param {*} value The value to cache.
  	     * @returns {Object} Returns the cache instance.
  	     */
  	    function setCacheAdd(value) {
  	      this.__data__.set(value, HASH_UNDEFINED);
  	      return this;
  	    }

  	    /**
  	     * Checks if `value` is in the array cache.
  	     *
  	     * @private
  	     * @name has
  	     * @memberOf SetCache
  	     * @param {*} value The value to search for.
  	     * @returns {number} Returns `true` if `value` is found, else `false`.
  	     */
  	    function setCacheHas(value) {
  	      return this.__data__.has(value);
  	    }

  	    // Add methods to `SetCache`.
  	    SetCache.prototype.add = SetCache.prototype.push = setCacheAdd;
  	    SetCache.prototype.has = setCacheHas;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates a stack cache object to store key-value pairs.
  	     *
  	     * @private
  	     * @constructor
  	     * @param {Array} [entries] The key-value pairs to cache.
  	     */
  	    function Stack(entries) {
  	      var data = this.__data__ = new ListCache(entries);
  	      this.size = data.size;
  	    }

  	    /**
  	     * Removes all key-value entries from the stack.
  	     *
  	     * @private
  	     * @name clear
  	     * @memberOf Stack
  	     */
  	    function stackClear() {
  	      this.__data__ = new ListCache;
  	      this.size = 0;
  	    }

  	    /**
  	     * Removes `key` and its value from the stack.
  	     *
  	     * @private
  	     * @name delete
  	     * @memberOf Stack
  	     * @param {string} key The key of the value to remove.
  	     * @returns {boolean} Returns `true` if the entry was removed, else `false`.
  	     */
  	    function stackDelete(key) {
  	      var data = this.__data__,
  	          result = data['delete'](key);

  	      this.size = data.size;
  	      return result;
  	    }

  	    /**
  	     * Gets the stack value for `key`.
  	     *
  	     * @private
  	     * @name get
  	     * @memberOf Stack
  	     * @param {string} key The key of the value to get.
  	     * @returns {*} Returns the entry value.
  	     */
  	    function stackGet(key) {
  	      return this.__data__.get(key);
  	    }

  	    /**
  	     * Checks if a stack value for `key` exists.
  	     *
  	     * @private
  	     * @name has
  	     * @memberOf Stack
  	     * @param {string} key The key of the entry to check.
  	     * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
  	     */
  	    function stackHas(key) {
  	      return this.__data__.has(key);
  	    }

  	    /**
  	     * Sets the stack `key` to `value`.
  	     *
  	     * @private
  	     * @name set
  	     * @memberOf Stack
  	     * @param {string} key The key of the value to set.
  	     * @param {*} value The value to set.
  	     * @returns {Object} Returns the stack cache instance.
  	     */
  	    function stackSet(key, value) {
  	      var data = this.__data__;
  	      if (data instanceof ListCache) {
  	        var pairs = data.__data__;
  	        if (!Map || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
  	          pairs.push([key, value]);
  	          this.size = ++data.size;
  	          return this;
  	        }
  	        data = this.__data__ = new MapCache(pairs);
  	      }
  	      data.set(key, value);
  	      this.size = data.size;
  	      return this;
  	    }

  	    // Add methods to `Stack`.
  	    Stack.prototype.clear = stackClear;
  	    Stack.prototype['delete'] = stackDelete;
  	    Stack.prototype.get = stackGet;
  	    Stack.prototype.has = stackHas;
  	    Stack.prototype.set = stackSet;

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates an array of the enumerable property names of the array-like `value`.
  	     *
  	     * @private
  	     * @param {*} value The value to query.
  	     * @param {boolean} inherited Specify returning inherited property names.
  	     * @returns {Array} Returns the array of property names.
  	     */
  	    function arrayLikeKeys(value, inherited) {
  	      var isArr = isArray(value),
  	          isArg = !isArr && isArguments(value),
  	          isBuff = !isArr && !isArg && isBuffer(value),
  	          isType = !isArr && !isArg && !isBuff && isTypedArray(value),
  	          skipIndexes = isArr || isArg || isBuff || isType,
  	          result = skipIndexes ? baseTimes(value.length, String) : [],
  	          length = result.length;

  	      for (var key in value) {
  	        if ((inherited || hasOwnProperty.call(value, key)) &&
  	            !(skipIndexes && (
  	               // Safari 9 has enumerable `arguments.length` in strict mode.
  	               key == 'length' ||
  	               // Node.js 0.10 has enumerable non-index properties on buffers.
  	               (isBuff && (key == 'offset' || key == 'parent')) ||
  	               // PhantomJS 2 has enumerable non-index properties on typed arrays.
  	               (isType && (key == 'buffer' || key == 'byteLength' || key == 'byteOffset')) ||
  	               // Skip index properties.
  	               isIndex(key, length)
  	            ))) {
  	          result.push(key);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * A specialized version of `_.sample` for arrays.
  	     *
  	     * @private
  	     * @param {Array} array The array to sample.
  	     * @returns {*} Returns the random element.
  	     */
  	    function arraySample(array) {
  	      var length = array.length;
  	      return length ? array[baseRandom(0, length - 1)] : undefined$1;
  	    }

  	    /**
  	     * A specialized version of `_.sampleSize` for arrays.
  	     *
  	     * @private
  	     * @param {Array} array The array to sample.
  	     * @param {number} n The number of elements to sample.
  	     * @returns {Array} Returns the random elements.
  	     */
  	    function arraySampleSize(array, n) {
  	      return shuffleSelf(copyArray(array), baseClamp(n, 0, array.length));
  	    }

  	    /**
  	     * A specialized version of `_.shuffle` for arrays.
  	     *
  	     * @private
  	     * @param {Array} array The array to shuffle.
  	     * @returns {Array} Returns the new shuffled array.
  	     */
  	    function arrayShuffle(array) {
  	      return shuffleSelf(copyArray(array));
  	    }

  	    /**
  	     * This function is like `assignValue` except that it doesn't assign
  	     * `undefined` values.
  	     *
  	     * @private
  	     * @param {Object} object The object to modify.
  	     * @param {string} key The key of the property to assign.
  	     * @param {*} value The value to assign.
  	     */
  	    function assignMergeValue(object, key, value) {
  	      if ((value !== undefined$1 && !eq(object[key], value)) ||
  	          (value === undefined$1 && !(key in object))) {
  	        baseAssignValue(object, key, value);
  	      }
  	    }

  	    /**
  	     * Assigns `value` to `key` of `object` if the existing value is not equivalent
  	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons.
  	     *
  	     * @private
  	     * @param {Object} object The object to modify.
  	     * @param {string} key The key of the property to assign.
  	     * @param {*} value The value to assign.
  	     */
  	    function assignValue(object, key, value) {
  	      var objValue = object[key];
  	      if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
  	          (value === undefined$1 && !(key in object))) {
  	        baseAssignValue(object, key, value);
  	      }
  	    }

  	    /**
  	     * Gets the index at which the `key` is found in `array` of key-value pairs.
  	     *
  	     * @private
  	     * @param {Array} array The array to inspect.
  	     * @param {*} key The key to search for.
  	     * @returns {number} Returns the index of the matched value, else `-1`.
  	     */
  	    function assocIndexOf(array, key) {
  	      var length = array.length;
  	      while (length--) {
  	        if (eq(array[length][0], key)) {
  	          return length;
  	        }
  	      }
  	      return -1;
  	    }

  	    /**
  	     * Aggregates elements of `collection` on `accumulator` with keys transformed
  	     * by `iteratee` and values set by `setter`.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} setter The function to set `accumulator` values.
  	     * @param {Function} iteratee The iteratee to transform keys.
  	     * @param {Object} accumulator The initial aggregated object.
  	     * @returns {Function} Returns `accumulator`.
  	     */
  	    function baseAggregator(collection, setter, iteratee, accumulator) {
  	      baseEach(collection, function(value, key, collection) {
  	        setter(accumulator, value, iteratee(value), collection);
  	      });
  	      return accumulator;
  	    }

  	    /**
  	     * The base implementation of `_.assign` without support for multiple sources
  	     * or `customizer` functions.
  	     *
  	     * @private
  	     * @param {Object} object The destination object.
  	     * @param {Object} source The source object.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function baseAssign(object, source) {
  	      return object && copyObject(source, keys(source), object);
  	    }

  	    /**
  	     * The base implementation of `_.assignIn` without support for multiple sources
  	     * or `customizer` functions.
  	     *
  	     * @private
  	     * @param {Object} object The destination object.
  	     * @param {Object} source The source object.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function baseAssignIn(object, source) {
  	      return object && copyObject(source, keysIn(source), object);
  	    }

  	    /**
  	     * The base implementation of `assignValue` and `assignMergeValue` without
  	     * value checks.
  	     *
  	     * @private
  	     * @param {Object} object The object to modify.
  	     * @param {string} key The key of the property to assign.
  	     * @param {*} value The value to assign.
  	     */
  	    function baseAssignValue(object, key, value) {
  	      if (key == '__proto__' && defineProperty) {
  	        defineProperty(object, key, {
  	          'configurable': true,
  	          'enumerable': true,
  	          'value': value,
  	          'writable': true
  	        });
  	      } else {
  	        object[key] = value;
  	      }
  	    }

  	    /**
  	     * The base implementation of `_.at` without support for individual paths.
  	     *
  	     * @private
  	     * @param {Object} object The object to iterate over.
  	     * @param {string[]} paths The property paths to pick.
  	     * @returns {Array} Returns the picked elements.
  	     */
  	    function baseAt(object, paths) {
  	      var index = -1,
  	          length = paths.length,
  	          result = Array(length),
  	          skip = object == null;

  	      while (++index < length) {
  	        result[index] = skip ? undefined$1 : get(object, paths[index]);
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.clamp` which doesn't coerce arguments.
  	     *
  	     * @private
  	     * @param {number} number The number to clamp.
  	     * @param {number} [lower] The lower bound.
  	     * @param {number} upper The upper bound.
  	     * @returns {number} Returns the clamped number.
  	     */
  	    function baseClamp(number, lower, upper) {
  	      if (number === number) {
  	        if (upper !== undefined$1) {
  	          number = number <= upper ? number : upper;
  	        }
  	        if (lower !== undefined$1) {
  	          number = number >= lower ? number : lower;
  	        }
  	      }
  	      return number;
  	    }

  	    /**
  	     * The base implementation of `_.clone` and `_.cloneDeep` which tracks
  	     * traversed objects.
  	     *
  	     * @private
  	     * @param {*} value The value to clone.
  	     * @param {boolean} bitmask The bitmask flags.
  	     *  1 - Deep clone
  	     *  2 - Flatten inherited properties
  	     *  4 - Clone symbols
  	     * @param {Function} [customizer] The function to customize cloning.
  	     * @param {string} [key] The key of `value`.
  	     * @param {Object} [object] The parent object of `value`.
  	     * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
  	     * @returns {*} Returns the cloned value.
  	     */
  	    function baseClone(value, bitmask, customizer, key, object, stack) {
  	      var result,
  	          isDeep = bitmask & CLONE_DEEP_FLAG,
  	          isFlat = bitmask & CLONE_FLAT_FLAG,
  	          isFull = bitmask & CLONE_SYMBOLS_FLAG;

  	      if (customizer) {
  	        result = object ? customizer(value, key, object, stack) : customizer(value);
  	      }
  	      if (result !== undefined$1) {
  	        return result;
  	      }
  	      if (!isObject(value)) {
  	        return value;
  	      }
  	      var isArr = isArray(value);
  	      if (isArr) {
  	        result = initCloneArray(value);
  	        if (!isDeep) {
  	          return copyArray(value, result);
  	        }
  	      } else {
  	        var tag = getTag(value),
  	            isFunc = tag == funcTag || tag == genTag;

  	        if (isBuffer(value)) {
  	          return cloneBuffer(value, isDeep);
  	        }
  	        if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
  	          result = (isFlat || isFunc) ? {} : initCloneObject(value);
  	          if (!isDeep) {
  	            return isFlat
  	              ? copySymbolsIn(value, baseAssignIn(result, value))
  	              : copySymbols(value, baseAssign(result, value));
  	          }
  	        } else {
  	          if (!cloneableTags[tag]) {
  	            return object ? value : {};
  	          }
  	          result = initCloneByTag(value, tag, isDeep);
  	        }
  	      }
  	      // Check for circular references and return its corresponding clone.
  	      stack || (stack = new Stack);
  	      var stacked = stack.get(value);
  	      if (stacked) {
  	        return stacked;
  	      }
  	      stack.set(value, result);

  	      if (isSet(value)) {
  	        value.forEach(function(subValue) {
  	          result.add(baseClone(subValue, bitmask, customizer, subValue, value, stack));
  	        });
  	      } else if (isMap(value)) {
  	        value.forEach(function(subValue, key) {
  	          result.set(key, baseClone(subValue, bitmask, customizer, key, value, stack));
  	        });
  	      }

  	      var keysFunc = isFull
  	        ? (isFlat ? getAllKeysIn : getAllKeys)
  	        : (isFlat ? keysIn : keys);

  	      var props = isArr ? undefined$1 : keysFunc(value);
  	      arrayEach(props || value, function(subValue, key) {
  	        if (props) {
  	          key = subValue;
  	          subValue = value[key];
  	        }
  	        // Recursively populate clone (susceptible to call stack limits).
  	        assignValue(result, key, baseClone(subValue, bitmask, customizer, key, value, stack));
  	      });
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.conforms` which doesn't clone `source`.
  	     *
  	     * @private
  	     * @param {Object} source The object of property predicates to conform to.
  	     * @returns {Function} Returns the new spec function.
  	     */
  	    function baseConforms(source) {
  	      var props = keys(source);
  	      return function(object) {
  	        return baseConformsTo(object, source, props);
  	      };
  	    }

  	    /**
  	     * The base implementation of `_.conformsTo` which accepts `props` to check.
  	     *
  	     * @private
  	     * @param {Object} object The object to inspect.
  	     * @param {Object} source The object of property predicates to conform to.
  	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
  	     */
  	    function baseConformsTo(object, source, props) {
  	      var length = props.length;
  	      if (object == null) {
  	        return !length;
  	      }
  	      object = Object(object);
  	      while (length--) {
  	        var key = props[length],
  	            predicate = source[key],
  	            value = object[key];

  	        if ((value === undefined$1 && !(key in object)) || !predicate(value)) {
  	          return false;
  	        }
  	      }
  	      return true;
  	    }

  	    /**
  	     * The base implementation of `_.delay` and `_.defer` which accepts `args`
  	     * to provide to `func`.
  	     *
  	     * @private
  	     * @param {Function} func The function to delay.
  	     * @param {number} wait The number of milliseconds to delay invocation.
  	     * @param {Array} args The arguments to provide to `func`.
  	     * @returns {number|Object} Returns the timer id or timeout object.
  	     */
  	    function baseDelay(func, wait, args) {
  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      return setTimeout(function() { func.apply(undefined$1, args); }, wait);
  	    }

  	    /**
  	     * The base implementation of methods like `_.difference` without support
  	     * for excluding multiple arrays or iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array} array The array to inspect.
  	     * @param {Array} values The values to exclude.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of filtered values.
  	     */
  	    function baseDifference(array, values, iteratee, comparator) {
  	      var index = -1,
  	          includes = arrayIncludes,
  	          isCommon = true,
  	          length = array.length,
  	          result = [],
  	          valuesLength = values.length;

  	      if (!length) {
  	        return result;
  	      }
  	      if (iteratee) {
  	        values = arrayMap(values, baseUnary(iteratee));
  	      }
  	      if (comparator) {
  	        includes = arrayIncludesWith;
  	        isCommon = false;
  	      }
  	      else if (values.length >= LARGE_ARRAY_SIZE) {
  	        includes = cacheHas;
  	        isCommon = false;
  	        values = new SetCache(values);
  	      }
  	      outer:
  	      while (++index < length) {
  	        var value = array[index],
  	            computed = iteratee == null ? value : iteratee(value);

  	        value = (comparator || value !== 0) ? value : 0;
  	        if (isCommon && computed === computed) {
  	          var valuesIndex = valuesLength;
  	          while (valuesIndex--) {
  	            if (values[valuesIndex] === computed) {
  	              continue outer;
  	            }
  	          }
  	          result.push(value);
  	        }
  	        else if (!includes(values, computed, comparator)) {
  	          result.push(value);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.forEach` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @returns {Array|Object} Returns `collection`.
  	     */
  	    var baseEach = createBaseEach(baseForOwn);

  	    /**
  	     * The base implementation of `_.forEachRight` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @returns {Array|Object} Returns `collection`.
  	     */
  	    var baseEachRight = createBaseEach(baseForOwnRight, true);

  	    /**
  	     * The base implementation of `_.every` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} predicate The function invoked per iteration.
  	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
  	     *  else `false`
  	     */
  	    function baseEvery(collection, predicate) {
  	      var result = true;
  	      baseEach(collection, function(value, index, collection) {
  	        result = !!predicate(value, index, collection);
  	        return result;
  	      });
  	      return result;
  	    }

  	    /**
  	     * The base implementation of methods like `_.max` and `_.min` which accepts a
  	     * `comparator` to determine the extremum value.
  	     *
  	     * @private
  	     * @param {Array} array The array to iterate over.
  	     * @param {Function} iteratee The iteratee invoked per iteration.
  	     * @param {Function} comparator The comparator used to compare values.
  	     * @returns {*} Returns the extremum value.
  	     */
  	    function baseExtremum(array, iteratee, comparator) {
  	      var index = -1,
  	          length = array.length;

  	      while (++index < length) {
  	        var value = array[index],
  	            current = iteratee(value);

  	        if (current != null && (computed === undefined$1
  	              ? (current === current && !isSymbol(current))
  	              : comparator(current, computed)
  	            )) {
  	          var computed = current,
  	              result = value;
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.fill` without an iteratee call guard.
  	     *
  	     * @private
  	     * @param {Array} array The array to fill.
  	     * @param {*} value The value to fill `array` with.
  	     * @param {number} [start=0] The start position.
  	     * @param {number} [end=array.length] The end position.
  	     * @returns {Array} Returns `array`.
  	     */
  	    function baseFill(array, value, start, end) {
  	      var length = array.length;

  	      start = toInteger(start);
  	      if (start < 0) {
  	        start = -start > length ? 0 : (length + start);
  	      }
  	      end = (end === undefined$1 || end > length) ? length : toInteger(end);
  	      if (end < 0) {
  	        end += length;
  	      }
  	      end = start > end ? 0 : toLength(end);
  	      while (start < end) {
  	        array[start++] = value;
  	      }
  	      return array;
  	    }

  	    /**
  	     * The base implementation of `_.filter` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} predicate The function invoked per iteration.
  	     * @returns {Array} Returns the new filtered array.
  	     */
  	    function baseFilter(collection, predicate) {
  	      var result = [];
  	      baseEach(collection, function(value, index, collection) {
  	        if (predicate(value, index, collection)) {
  	          result.push(value);
  	        }
  	      });
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.flatten` with support for restricting flattening.
  	     *
  	     * @private
  	     * @param {Array} array The array to flatten.
  	     * @param {number} depth The maximum recursion depth.
  	     * @param {boolean} [predicate=isFlattenable] The function invoked per iteration.
  	     * @param {boolean} [isStrict] Restrict to values that pass `predicate` checks.
  	     * @param {Array} [result=[]] The initial result value.
  	     * @returns {Array} Returns the new flattened array.
  	     */
  	    function baseFlatten(array, depth, predicate, isStrict, result) {
  	      var index = -1,
  	          length = array.length;

  	      predicate || (predicate = isFlattenable);
  	      result || (result = []);

  	      while (++index < length) {
  	        var value = array[index];
  	        if (depth > 0 && predicate(value)) {
  	          if (depth > 1) {
  	            // Recursively flatten arrays (susceptible to call stack limits).
  	            baseFlatten(value, depth - 1, predicate, isStrict, result);
  	          } else {
  	            arrayPush(result, value);
  	          }
  	        } else if (!isStrict) {
  	          result[result.length] = value;
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `baseForOwn` which iterates over `object`
  	     * properties returned by `keysFunc` and invokes `iteratee` for each property.
  	     * Iteratee functions may exit iteration early by explicitly returning `false`.
  	     *
  	     * @private
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @param {Function} keysFunc The function to get the keys of `object`.
  	     * @returns {Object} Returns `object`.
  	     */
  	    var baseFor = createBaseFor();

  	    /**
  	     * This function is like `baseFor` except that it iterates over properties
  	     * in the opposite order.
  	     *
  	     * @private
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @param {Function} keysFunc The function to get the keys of `object`.
  	     * @returns {Object} Returns `object`.
  	     */
  	    var baseForRight = createBaseFor(true);

  	    /**
  	     * The base implementation of `_.forOwn` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function baseForOwn(object, iteratee) {
  	      return object && baseFor(object, iteratee, keys);
  	    }

  	    /**
  	     * The base implementation of `_.forOwnRight` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function baseForOwnRight(object, iteratee) {
  	      return object && baseForRight(object, iteratee, keys);
  	    }

  	    /**
  	     * The base implementation of `_.functions` which creates an array of
  	     * `object` function property names filtered from `props`.
  	     *
  	     * @private
  	     * @param {Object} object The object to inspect.
  	     * @param {Array} props The property names to filter.
  	     * @returns {Array} Returns the function names.
  	     */
  	    function baseFunctions(object, props) {
  	      return arrayFilter(props, function(key) {
  	        return isFunction(object[key]);
  	      });
  	    }

  	    /**
  	     * The base implementation of `_.get` without support for default values.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path of the property to get.
  	     * @returns {*} Returns the resolved value.
  	     */
  	    function baseGet(object, path) {
  	      path = castPath(path, object);

  	      var index = 0,
  	          length = path.length;

  	      while (object != null && index < length) {
  	        object = object[toKey(path[index++])];
  	      }
  	      return (index && index == length) ? object : undefined$1;
  	    }

  	    /**
  	     * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
  	     * `keysFunc` and `symbolsFunc` to get the enumerable property names and
  	     * symbols of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {Function} keysFunc The function to get the keys of `object`.
  	     * @param {Function} symbolsFunc The function to get the symbols of `object`.
  	     * @returns {Array} Returns the array of property names and symbols.
  	     */
  	    function baseGetAllKeys(object, keysFunc, symbolsFunc) {
  	      var result = keysFunc(object);
  	      return isArray(object) ? result : arrayPush(result, symbolsFunc(object));
  	    }

  	    /**
  	     * The base implementation of `getTag` without fallbacks for buggy environments.
  	     *
  	     * @private
  	     * @param {*} value The value to query.
  	     * @returns {string} Returns the `toStringTag`.
  	     */
  	    function baseGetTag(value) {
  	      if (value == null) {
  	        return value === undefined$1 ? undefinedTag : nullTag;
  	      }
  	      return (symToStringTag && symToStringTag in Object(value))
  	        ? getRawTag(value)
  	        : objectToString(value);
  	    }

  	    /**
  	     * The base implementation of `_.gt` which doesn't coerce arguments.
  	     *
  	     * @private
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
  	     *  else `false`.
  	     */
  	    function baseGt(value, other) {
  	      return value > other;
  	    }

  	    /**
  	     * The base implementation of `_.has` without support for deep paths.
  	     *
  	     * @private
  	     * @param {Object} [object] The object to query.
  	     * @param {Array|string} key The key to check.
  	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
  	     */
  	    function baseHas(object, key) {
  	      return object != null && hasOwnProperty.call(object, key);
  	    }

  	    /**
  	     * The base implementation of `_.hasIn` without support for deep paths.
  	     *
  	     * @private
  	     * @param {Object} [object] The object to query.
  	     * @param {Array|string} key The key to check.
  	     * @returns {boolean} Returns `true` if `key` exists, else `false`.
  	     */
  	    function baseHasIn(object, key) {
  	      return object != null && key in Object(object);
  	    }

  	    /**
  	     * The base implementation of `_.inRange` which doesn't coerce arguments.
  	     *
  	     * @private
  	     * @param {number} number The number to check.
  	     * @param {number} start The start of the range.
  	     * @param {number} end The end of the range.
  	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
  	     */
  	    function baseInRange(number, start, end) {
  	      return number >= nativeMin(start, end) && number < nativeMax(start, end);
  	    }

  	    /**
  	     * The base implementation of methods like `_.intersection`, without support
  	     * for iteratee shorthands, that accepts an array of arrays to inspect.
  	     *
  	     * @private
  	     * @param {Array} arrays The arrays to inspect.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of shared values.
  	     */
  	    function baseIntersection(arrays, iteratee, comparator) {
  	      var includes = comparator ? arrayIncludesWith : arrayIncludes,
  	          length = arrays[0].length,
  	          othLength = arrays.length,
  	          othIndex = othLength,
  	          caches = Array(othLength),
  	          maxLength = Infinity,
  	          result = [];

  	      while (othIndex--) {
  	        var array = arrays[othIndex];
  	        if (othIndex && iteratee) {
  	          array = arrayMap(array, baseUnary(iteratee));
  	        }
  	        maxLength = nativeMin(array.length, maxLength);
  	        caches[othIndex] = !comparator && (iteratee || (length >= 120 && array.length >= 120))
  	          ? new SetCache(othIndex && array)
  	          : undefined$1;
  	      }
  	      array = arrays[0];

  	      var index = -1,
  	          seen = caches[0];

  	      outer:
  	      while (++index < length && result.length < maxLength) {
  	        var value = array[index],
  	            computed = iteratee ? iteratee(value) : value;

  	        value = (comparator || value !== 0) ? value : 0;
  	        if (!(seen
  	              ? cacheHas(seen, computed)
  	              : includes(result, computed, comparator)
  	            )) {
  	          othIndex = othLength;
  	          while (--othIndex) {
  	            var cache = caches[othIndex];
  	            if (!(cache
  	                  ? cacheHas(cache, computed)
  	                  : includes(arrays[othIndex], computed, comparator))
  	                ) {
  	              continue outer;
  	            }
  	          }
  	          if (seen) {
  	            seen.push(computed);
  	          }
  	          result.push(value);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.invert` and `_.invertBy` which inverts
  	     * `object` with values transformed by `iteratee` and set by `setter`.
  	     *
  	     * @private
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} setter The function to set `accumulator` values.
  	     * @param {Function} iteratee The iteratee to transform values.
  	     * @param {Object} accumulator The initial inverted object.
  	     * @returns {Function} Returns `accumulator`.
  	     */
  	    function baseInverter(object, setter, iteratee, accumulator) {
  	      baseForOwn(object, function(value, key, object) {
  	        setter(accumulator, iteratee(value), key, object);
  	      });
  	      return accumulator;
  	    }

  	    /**
  	     * The base implementation of `_.invoke` without support for individual
  	     * method arguments.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path of the method to invoke.
  	     * @param {Array} args The arguments to invoke the method with.
  	     * @returns {*} Returns the result of the invoked method.
  	     */
  	    function baseInvoke(object, path, args) {
  	      path = castPath(path, object);
  	      object = parent(object, path);
  	      var func = object == null ? object : object[toKey(last(path))];
  	      return func == null ? undefined$1 : apply(func, object, args);
  	    }

  	    /**
  	     * The base implementation of `_.isArguments`.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
  	     */
  	    function baseIsArguments(value) {
  	      return isObjectLike(value) && baseGetTag(value) == argsTag;
  	    }

  	    /**
  	     * The base implementation of `_.isArrayBuffer` without Node.js optimizations.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
  	     */
  	    function baseIsArrayBuffer(value) {
  	      return isObjectLike(value) && baseGetTag(value) == arrayBufferTag;
  	    }

  	    /**
  	     * The base implementation of `_.isDate` without Node.js optimizations.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
  	     */
  	    function baseIsDate(value) {
  	      return isObjectLike(value) && baseGetTag(value) == dateTag;
  	    }

  	    /**
  	     * The base implementation of `_.isEqual` which supports partial comparisons
  	     * and tracks traversed objects.
  	     *
  	     * @private
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @param {boolean} bitmask The bitmask flags.
  	     *  1 - Unordered comparison
  	     *  2 - Partial comparison
  	     * @param {Function} [customizer] The function to customize comparisons.
  	     * @param {Object} [stack] Tracks traversed `value` and `other` objects.
  	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
  	     */
  	    function baseIsEqual(value, other, bitmask, customizer, stack) {
  	      if (value === other) {
  	        return true;
  	      }
  	      if (value == null || other == null || (!isObjectLike(value) && !isObjectLike(other))) {
  	        return value !== value && other !== other;
  	      }
  	      return baseIsEqualDeep(value, other, bitmask, customizer, baseIsEqual, stack);
  	    }

  	    /**
  	     * A specialized version of `baseIsEqual` for arrays and objects which performs
  	     * deep comparisons and tracks traversed objects enabling objects with circular
  	     * references to be compared.
  	     *
  	     * @private
  	     * @param {Object} object The object to compare.
  	     * @param {Object} other The other object to compare.
  	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	     * @param {Function} customizer The function to customize comparisons.
  	     * @param {Function} equalFunc The function to determine equivalents of values.
  	     * @param {Object} [stack] Tracks traversed `object` and `other` objects.
  	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	     */
  	    function baseIsEqualDeep(object, other, bitmask, customizer, equalFunc, stack) {
  	      var objIsArr = isArray(object),
  	          othIsArr = isArray(other),
  	          objTag = objIsArr ? arrayTag : getTag(object),
  	          othTag = othIsArr ? arrayTag : getTag(other);

  	      objTag = objTag == argsTag ? objectTag : objTag;
  	      othTag = othTag == argsTag ? objectTag : othTag;

  	      var objIsObj = objTag == objectTag,
  	          othIsObj = othTag == objectTag,
  	          isSameTag = objTag == othTag;

  	      if (isSameTag && isBuffer(object)) {
  	        if (!isBuffer(other)) {
  	          return false;
  	        }
  	        objIsArr = true;
  	        objIsObj = false;
  	      }
  	      if (isSameTag && !objIsObj) {
  	        stack || (stack = new Stack);
  	        return (objIsArr || isTypedArray(object))
  	          ? equalArrays(object, other, bitmask, customizer, equalFunc, stack)
  	          : equalByTag(object, other, objTag, bitmask, customizer, equalFunc, stack);
  	      }
  	      if (!(bitmask & COMPARE_PARTIAL_FLAG)) {
  	        var objIsWrapped = objIsObj && hasOwnProperty.call(object, '__wrapped__'),
  	            othIsWrapped = othIsObj && hasOwnProperty.call(other, '__wrapped__');

  	        if (objIsWrapped || othIsWrapped) {
  	          var objUnwrapped = objIsWrapped ? object.value() : object,
  	              othUnwrapped = othIsWrapped ? other.value() : other;

  	          stack || (stack = new Stack);
  	          return equalFunc(objUnwrapped, othUnwrapped, bitmask, customizer, stack);
  	        }
  	      }
  	      if (!isSameTag) {
  	        return false;
  	      }
  	      stack || (stack = new Stack);
  	      return equalObjects(object, other, bitmask, customizer, equalFunc, stack);
  	    }

  	    /**
  	     * The base implementation of `_.isMap` without Node.js optimizations.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
  	     */
  	    function baseIsMap(value) {
  	      return isObjectLike(value) && getTag(value) == mapTag;
  	    }

  	    /**
  	     * The base implementation of `_.isMatch` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Object} object The object to inspect.
  	     * @param {Object} source The object of property values to match.
  	     * @param {Array} matchData The property names, values, and compare flags to match.
  	     * @param {Function} [customizer] The function to customize comparisons.
  	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
  	     */
  	    function baseIsMatch(object, source, matchData, customizer) {
  	      var index = matchData.length,
  	          length = index,
  	          noCustomizer = !customizer;

  	      if (object == null) {
  	        return !length;
  	      }
  	      object = Object(object);
  	      while (index--) {
  	        var data = matchData[index];
  	        if ((noCustomizer && data[2])
  	              ? data[1] !== object[data[0]]
  	              : !(data[0] in object)
  	            ) {
  	          return false;
  	        }
  	      }
  	      while (++index < length) {
  	        data = matchData[index];
  	        var key = data[0],
  	            objValue = object[key],
  	            srcValue = data[1];

  	        if (noCustomizer && data[2]) {
  	          if (objValue === undefined$1 && !(key in object)) {
  	            return false;
  	          }
  	        } else {
  	          var stack = new Stack;
  	          if (customizer) {
  	            var result = customizer(objValue, srcValue, key, object, source, stack);
  	          }
  	          if (!(result === undefined$1
  	                ? baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG, customizer, stack)
  	                : result
  	              )) {
  	            return false;
  	          }
  	        }
  	      }
  	      return true;
  	    }

  	    /**
  	     * The base implementation of `_.isNative` without bad shim checks.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a native function,
  	     *  else `false`.
  	     */
  	    function baseIsNative(value) {
  	      if (!isObject(value) || isMasked(value)) {
  	        return false;
  	      }
  	      var pattern = isFunction(value) ? reIsNative : reIsHostCtor;
  	      return pattern.test(toSource(value));
  	    }

  	    /**
  	     * The base implementation of `_.isRegExp` without Node.js optimizations.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
  	     */
  	    function baseIsRegExp(value) {
  	      return isObjectLike(value) && baseGetTag(value) == regexpTag;
  	    }

  	    /**
  	     * The base implementation of `_.isSet` without Node.js optimizations.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
  	     */
  	    function baseIsSet(value) {
  	      return isObjectLike(value) && getTag(value) == setTag;
  	    }

  	    /**
  	     * The base implementation of `_.isTypedArray` without Node.js optimizations.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
  	     */
  	    function baseIsTypedArray(value) {
  	      return isObjectLike(value) &&
  	        isLength(value.length) && !!typedArrayTags[baseGetTag(value)];
  	    }

  	    /**
  	     * The base implementation of `_.iteratee`.
  	     *
  	     * @private
  	     * @param {*} [value=_.identity] The value to convert to an iteratee.
  	     * @returns {Function} Returns the iteratee.
  	     */
  	    function baseIteratee(value) {
  	      // Don't store the `typeof` result in a variable to avoid a JIT bug in Safari 9.
  	      // See https://bugs.webkit.org/show_bug.cgi?id=156034 for more details.
  	      if (typeof value == 'function') {
  	        return value;
  	      }
  	      if (value == null) {
  	        return identity;
  	      }
  	      if (typeof value == 'object') {
  	        return isArray(value)
  	          ? baseMatchesProperty(value[0], value[1])
  	          : baseMatches(value);
  	      }
  	      return property(value);
  	    }

  	    /**
  	     * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names.
  	     */
  	    function baseKeys(object) {
  	      if (!isPrototype(object)) {
  	        return nativeKeys(object);
  	      }
  	      var result = [];
  	      for (var key in Object(object)) {
  	        if (hasOwnProperty.call(object, key) && key != 'constructor') {
  	          result.push(key);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.keysIn` which doesn't treat sparse arrays as dense.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names.
  	     */
  	    function baseKeysIn(object) {
  	      if (!isObject(object)) {
  	        return nativeKeysIn(object);
  	      }
  	      var isProto = isPrototype(object),
  	          result = [];

  	      for (var key in object) {
  	        if (!(key == 'constructor' && (isProto || !hasOwnProperty.call(object, key)))) {
  	          result.push(key);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.lt` which doesn't coerce arguments.
  	     *
  	     * @private
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if `value` is less than `other`,
  	     *  else `false`.
  	     */
  	    function baseLt(value, other) {
  	      return value < other;
  	    }

  	    /**
  	     * The base implementation of `_.map` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} iteratee The function invoked per iteration.
  	     * @returns {Array} Returns the new mapped array.
  	     */
  	    function baseMap(collection, iteratee) {
  	      var index = -1,
  	          result = isArrayLike(collection) ? Array(collection.length) : [];

  	      baseEach(collection, function(value, key, collection) {
  	        result[++index] = iteratee(value, key, collection);
  	      });
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.matches` which doesn't clone `source`.
  	     *
  	     * @private
  	     * @param {Object} source The object of property values to match.
  	     * @returns {Function} Returns the new spec function.
  	     */
  	    function baseMatches(source) {
  	      var matchData = getMatchData(source);
  	      if (matchData.length == 1 && matchData[0][2]) {
  	        return matchesStrictComparable(matchData[0][0], matchData[0][1]);
  	      }
  	      return function(object) {
  	        return object === source || baseIsMatch(object, source, matchData);
  	      };
  	    }

  	    /**
  	     * The base implementation of `_.matchesProperty` which doesn't clone `srcValue`.
  	     *
  	     * @private
  	     * @param {string} path The path of the property to get.
  	     * @param {*} srcValue The value to match.
  	     * @returns {Function} Returns the new spec function.
  	     */
  	    function baseMatchesProperty(path, srcValue) {
  	      if (isKey(path) && isStrictComparable(srcValue)) {
  	        return matchesStrictComparable(toKey(path), srcValue);
  	      }
  	      return function(object) {
  	        var objValue = get(object, path);
  	        return (objValue === undefined$1 && objValue === srcValue)
  	          ? hasIn(object, path)
  	          : baseIsEqual(srcValue, objValue, COMPARE_PARTIAL_FLAG | COMPARE_UNORDERED_FLAG);
  	      };
  	    }

  	    /**
  	     * The base implementation of `_.merge` without support for multiple sources.
  	     *
  	     * @private
  	     * @param {Object} object The destination object.
  	     * @param {Object} source The source object.
  	     * @param {number} srcIndex The index of `source`.
  	     * @param {Function} [customizer] The function to customize merged values.
  	     * @param {Object} [stack] Tracks traversed source values and their merged
  	     *  counterparts.
  	     */
  	    function baseMerge(object, source, srcIndex, customizer, stack) {
  	      if (object === source) {
  	        return;
  	      }
  	      baseFor(source, function(srcValue, key) {
  	        stack || (stack = new Stack);
  	        if (isObject(srcValue)) {
  	          baseMergeDeep(object, source, key, srcIndex, baseMerge, customizer, stack);
  	        }
  	        else {
  	          var newValue = customizer
  	            ? customizer(safeGet(object, key), srcValue, (key + ''), object, source, stack)
  	            : undefined$1;

  	          if (newValue === undefined$1) {
  	            newValue = srcValue;
  	          }
  	          assignMergeValue(object, key, newValue);
  	        }
  	      }, keysIn);
  	    }

  	    /**
  	     * A specialized version of `baseMerge` for arrays and objects which performs
  	     * deep merges and tracks traversed objects enabling objects with circular
  	     * references to be merged.
  	     *
  	     * @private
  	     * @param {Object} object The destination object.
  	     * @param {Object} source The source object.
  	     * @param {string} key The key of the value to merge.
  	     * @param {number} srcIndex The index of `source`.
  	     * @param {Function} mergeFunc The function to merge values.
  	     * @param {Function} [customizer] The function to customize assigned values.
  	     * @param {Object} [stack] Tracks traversed source values and their merged
  	     *  counterparts.
  	     */
  	    function baseMergeDeep(object, source, key, srcIndex, mergeFunc, customizer, stack) {
  	      var objValue = safeGet(object, key),
  	          srcValue = safeGet(source, key),
  	          stacked = stack.get(srcValue);

  	      if (stacked) {
  	        assignMergeValue(object, key, stacked);
  	        return;
  	      }
  	      var newValue = customizer
  	        ? customizer(objValue, srcValue, (key + ''), object, source, stack)
  	        : undefined$1;

  	      var isCommon = newValue === undefined$1;

  	      if (isCommon) {
  	        var isArr = isArray(srcValue),
  	            isBuff = !isArr && isBuffer(srcValue),
  	            isTyped = !isArr && !isBuff && isTypedArray(srcValue);

  	        newValue = srcValue;
  	        if (isArr || isBuff || isTyped) {
  	          if (isArray(objValue)) {
  	            newValue = objValue;
  	          }
  	          else if (isArrayLikeObject(objValue)) {
  	            newValue = copyArray(objValue);
  	          }
  	          else if (isBuff) {
  	            isCommon = false;
  	            newValue = cloneBuffer(srcValue, true);
  	          }
  	          else if (isTyped) {
  	            isCommon = false;
  	            newValue = cloneTypedArray(srcValue, true);
  	          }
  	          else {
  	            newValue = [];
  	          }
  	        }
  	        else if (isPlainObject(srcValue) || isArguments(srcValue)) {
  	          newValue = objValue;
  	          if (isArguments(objValue)) {
  	            newValue = toPlainObject(objValue);
  	          }
  	          else if (!isObject(objValue) || isFunction(objValue)) {
  	            newValue = initCloneObject(srcValue);
  	          }
  	        }
  	        else {
  	          isCommon = false;
  	        }
  	      }
  	      if (isCommon) {
  	        // Recursively merge objects and arrays (susceptible to call stack limits).
  	        stack.set(srcValue, newValue);
  	        mergeFunc(newValue, srcValue, srcIndex, customizer, stack);
  	        stack['delete'](srcValue);
  	      }
  	      assignMergeValue(object, key, newValue);
  	    }

  	    /**
  	     * The base implementation of `_.nth` which doesn't coerce arguments.
  	     *
  	     * @private
  	     * @param {Array} array The array to query.
  	     * @param {number} n The index of the element to return.
  	     * @returns {*} Returns the nth element of `array`.
  	     */
  	    function baseNth(array, n) {
  	      var length = array.length;
  	      if (!length) {
  	        return;
  	      }
  	      n += n < 0 ? length : 0;
  	      return isIndex(n, length) ? array[n] : undefined$1;
  	    }

  	    /**
  	     * The base implementation of `_.orderBy` without param guards.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function[]|Object[]|string[]} iteratees The iteratees to sort by.
  	     * @param {string[]} orders The sort orders of `iteratees`.
  	     * @returns {Array} Returns the new sorted array.
  	     */
  	    function baseOrderBy(collection, iteratees, orders) {
  	      if (iteratees.length) {
  	        iteratees = arrayMap(iteratees, function(iteratee) {
  	          if (isArray(iteratee)) {
  	            return function(value) {
  	              return baseGet(value, iteratee.length === 1 ? iteratee[0] : iteratee);
  	            }
  	          }
  	          return iteratee;
  	        });
  	      } else {
  	        iteratees = [identity];
  	      }

  	      var index = -1;
  	      iteratees = arrayMap(iteratees, baseUnary(getIteratee()));

  	      var result = baseMap(collection, function(value, key, collection) {
  	        var criteria = arrayMap(iteratees, function(iteratee) {
  	          return iteratee(value);
  	        });
  	        return { 'criteria': criteria, 'index': ++index, 'value': value };
  	      });

  	      return baseSortBy(result, function(object, other) {
  	        return compareMultiple(object, other, orders);
  	      });
  	    }

  	    /**
  	     * The base implementation of `_.pick` without support for individual
  	     * property identifiers.
  	     *
  	     * @private
  	     * @param {Object} object The source object.
  	     * @param {string[]} paths The property paths to pick.
  	     * @returns {Object} Returns the new object.
  	     */
  	    function basePick(object, paths) {
  	      return basePickBy(object, paths, function(value, path) {
  	        return hasIn(object, path);
  	      });
  	    }

  	    /**
  	     * The base implementation of  `_.pickBy` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Object} object The source object.
  	     * @param {string[]} paths The property paths to pick.
  	     * @param {Function} predicate The function invoked per property.
  	     * @returns {Object} Returns the new object.
  	     */
  	    function basePickBy(object, paths, predicate) {
  	      var index = -1,
  	          length = paths.length,
  	          result = {};

  	      while (++index < length) {
  	        var path = paths[index],
  	            value = baseGet(object, path);

  	        if (predicate(value, path)) {
  	          baseSet(result, castPath(path, object), value);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * A specialized version of `baseProperty` which supports deep paths.
  	     *
  	     * @private
  	     * @param {Array|string} path The path of the property to get.
  	     * @returns {Function} Returns the new accessor function.
  	     */
  	    function basePropertyDeep(path) {
  	      return function(object) {
  	        return baseGet(object, path);
  	      };
  	    }

  	    /**
  	     * The base implementation of `_.pullAllBy` without support for iteratee
  	     * shorthands.
  	     *
  	     * @private
  	     * @param {Array} array The array to modify.
  	     * @param {Array} values The values to remove.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns `array`.
  	     */
  	    function basePullAll(array, values, iteratee, comparator) {
  	      var indexOf = comparator ? baseIndexOfWith : baseIndexOf,
  	          index = -1,
  	          length = values.length,
  	          seen = array;

  	      if (array === values) {
  	        values = copyArray(values);
  	      }
  	      if (iteratee) {
  	        seen = arrayMap(array, baseUnary(iteratee));
  	      }
  	      while (++index < length) {
  	        var fromIndex = 0,
  	            value = values[index],
  	            computed = iteratee ? iteratee(value) : value;

  	        while ((fromIndex = indexOf(seen, computed, fromIndex, comparator)) > -1) {
  	          if (seen !== array) {
  	            splice.call(seen, fromIndex, 1);
  	          }
  	          splice.call(array, fromIndex, 1);
  	        }
  	      }
  	      return array;
  	    }

  	    /**
  	     * The base implementation of `_.pullAt` without support for individual
  	     * indexes or capturing the removed elements.
  	     *
  	     * @private
  	     * @param {Array} array The array to modify.
  	     * @param {number[]} indexes The indexes of elements to remove.
  	     * @returns {Array} Returns `array`.
  	     */
  	    function basePullAt(array, indexes) {
  	      var length = array ? indexes.length : 0,
  	          lastIndex = length - 1;

  	      while (length--) {
  	        var index = indexes[length];
  	        if (length == lastIndex || index !== previous) {
  	          var previous = index;
  	          if (isIndex(index)) {
  	            splice.call(array, index, 1);
  	          } else {
  	            baseUnset(array, index);
  	          }
  	        }
  	      }
  	      return array;
  	    }

  	    /**
  	     * The base implementation of `_.random` without support for returning
  	     * floating-point numbers.
  	     *
  	     * @private
  	     * @param {number} lower The lower bound.
  	     * @param {number} upper The upper bound.
  	     * @returns {number} Returns the random number.
  	     */
  	    function baseRandom(lower, upper) {
  	      return lower + nativeFloor(nativeRandom() * (upper - lower + 1));
  	    }

  	    /**
  	     * The base implementation of `_.range` and `_.rangeRight` which doesn't
  	     * coerce arguments.
  	     *
  	     * @private
  	     * @param {number} start The start of the range.
  	     * @param {number} end The end of the range.
  	     * @param {number} step The value to increment or decrement by.
  	     * @param {boolean} [fromRight] Specify iterating from right to left.
  	     * @returns {Array} Returns the range of numbers.
  	     */
  	    function baseRange(start, end, step, fromRight) {
  	      var index = -1,
  	          length = nativeMax(nativeCeil((end - start) / (step || 1)), 0),
  	          result = Array(length);

  	      while (length--) {
  	        result[fromRight ? length : ++index] = start;
  	        start += step;
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.repeat` which doesn't coerce arguments.
  	     *
  	     * @private
  	     * @param {string} string The string to repeat.
  	     * @param {number} n The number of times to repeat the string.
  	     * @returns {string} Returns the repeated string.
  	     */
  	    function baseRepeat(string, n) {
  	      var result = '';
  	      if (!string || n < 1 || n > MAX_SAFE_INTEGER) {
  	        return result;
  	      }
  	      // Leverage the exponentiation by squaring algorithm for a faster repeat.
  	      // See https://en.wikipedia.org/wiki/Exponentiation_by_squaring for more details.
  	      do {
  	        if (n % 2) {
  	          result += string;
  	        }
  	        n = nativeFloor(n / 2);
  	        if (n) {
  	          string += string;
  	        }
  	      } while (n);

  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.rest` which doesn't validate or coerce arguments.
  	     *
  	     * @private
  	     * @param {Function} func The function to apply a rest parameter to.
  	     * @param {number} [start=func.length-1] The start position of the rest parameter.
  	     * @returns {Function} Returns the new function.
  	     */
  	    function baseRest(func, start) {
  	      return setToString(overRest(func, start, identity), func + '');
  	    }

  	    /**
  	     * The base implementation of `_.sample`.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to sample.
  	     * @returns {*} Returns the random element.
  	     */
  	    function baseSample(collection) {
  	      return arraySample(values(collection));
  	    }

  	    /**
  	     * The base implementation of `_.sampleSize` without param guards.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to sample.
  	     * @param {number} n The number of elements to sample.
  	     * @returns {Array} Returns the random elements.
  	     */
  	    function baseSampleSize(collection, n) {
  	      var array = values(collection);
  	      return shuffleSelf(array, baseClamp(n, 0, array.length));
  	    }

  	    /**
  	     * The base implementation of `_.set`.
  	     *
  	     * @private
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to set.
  	     * @param {*} value The value to set.
  	     * @param {Function} [customizer] The function to customize path creation.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function baseSet(object, path, value, customizer) {
  	      if (!isObject(object)) {
  	        return object;
  	      }
  	      path = castPath(path, object);

  	      var index = -1,
  	          length = path.length,
  	          lastIndex = length - 1,
  	          nested = object;

  	      while (nested != null && ++index < length) {
  	        var key = toKey(path[index]),
  	            newValue = value;

  	        if (key === '__proto__' || key === 'constructor' || key === 'prototype') {
  	          return object;
  	        }

  	        if (index != lastIndex) {
  	          var objValue = nested[key];
  	          newValue = customizer ? customizer(objValue, key, nested) : undefined$1;
  	          if (newValue === undefined$1) {
  	            newValue = isObject(objValue)
  	              ? objValue
  	              : (isIndex(path[index + 1]) ? [] : {});
  	          }
  	        }
  	        assignValue(nested, key, newValue);
  	        nested = nested[key];
  	      }
  	      return object;
  	    }

  	    /**
  	     * The base implementation of `setData` without support for hot loop shorting.
  	     *
  	     * @private
  	     * @param {Function} func The function to associate metadata with.
  	     * @param {*} data The metadata.
  	     * @returns {Function} Returns `func`.
  	     */
  	    var baseSetData = !metaMap ? identity : function(func, data) {
  	      metaMap.set(func, data);
  	      return func;
  	    };

  	    /**
  	     * The base implementation of `setToString` without support for hot loop shorting.
  	     *
  	     * @private
  	     * @param {Function} func The function to modify.
  	     * @param {Function} string The `toString` result.
  	     * @returns {Function} Returns `func`.
  	     */
  	    var baseSetToString = !defineProperty ? identity : function(func, string) {
  	      return defineProperty(func, 'toString', {
  	        'configurable': true,
  	        'enumerable': false,
  	        'value': constant(string),
  	        'writable': true
  	      });
  	    };

  	    /**
  	     * The base implementation of `_.shuffle`.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to shuffle.
  	     * @returns {Array} Returns the new shuffled array.
  	     */
  	    function baseShuffle(collection) {
  	      return shuffleSelf(values(collection));
  	    }

  	    /**
  	     * The base implementation of `_.slice` without an iteratee call guard.
  	     *
  	     * @private
  	     * @param {Array} array The array to slice.
  	     * @param {number} [start=0] The start position.
  	     * @param {number} [end=array.length] The end position.
  	     * @returns {Array} Returns the slice of `array`.
  	     */
  	    function baseSlice(array, start, end) {
  	      var index = -1,
  	          length = array.length;

  	      if (start < 0) {
  	        start = -start > length ? 0 : (length + start);
  	      }
  	      end = end > length ? length : end;
  	      if (end < 0) {
  	        end += length;
  	      }
  	      length = start > end ? 0 : ((end - start) >>> 0);
  	      start >>>= 0;

  	      var result = Array(length);
  	      while (++index < length) {
  	        result[index] = array[index + start];
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.some` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} predicate The function invoked per iteration.
  	     * @returns {boolean} Returns `true` if any element passes the predicate check,
  	     *  else `false`.
  	     */
  	    function baseSome(collection, predicate) {
  	      var result;

  	      baseEach(collection, function(value, index, collection) {
  	        result = predicate(value, index, collection);
  	        return !result;
  	      });
  	      return !!result;
  	    }

  	    /**
  	     * The base implementation of `_.sortedIndex` and `_.sortedLastIndex` which
  	     * performs a binary search of `array` to determine the index at which `value`
  	     * should be inserted into `array` in order to maintain its sort order.
  	     *
  	     * @private
  	     * @param {Array} array The sorted array to inspect.
  	     * @param {*} value The value to evaluate.
  	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
  	     * @returns {number} Returns the index at which `value` should be inserted
  	     *  into `array`.
  	     */
  	    function baseSortedIndex(array, value, retHighest) {
  	      var low = 0,
  	          high = array == null ? low : array.length;

  	      if (typeof value == 'number' && value === value && high <= HALF_MAX_ARRAY_LENGTH) {
  	        while (low < high) {
  	          var mid = (low + high) >>> 1,
  	              computed = array[mid];

  	          if (computed !== null && !isSymbol(computed) &&
  	              (retHighest ? (computed <= value) : (computed < value))) {
  	            low = mid + 1;
  	          } else {
  	            high = mid;
  	          }
  	        }
  	        return high;
  	      }
  	      return baseSortedIndexBy(array, value, identity, retHighest);
  	    }

  	    /**
  	     * The base implementation of `_.sortedIndexBy` and `_.sortedLastIndexBy`
  	     * which invokes `iteratee` for `value` and each element of `array` to compute
  	     * their sort ranking. The iteratee is invoked with one argument; (value).
  	     *
  	     * @private
  	     * @param {Array} array The sorted array to inspect.
  	     * @param {*} value The value to evaluate.
  	     * @param {Function} iteratee The iteratee invoked per element.
  	     * @param {boolean} [retHighest] Specify returning the highest qualified index.
  	     * @returns {number} Returns the index at which `value` should be inserted
  	     *  into `array`.
  	     */
  	    function baseSortedIndexBy(array, value, iteratee, retHighest) {
  	      var low = 0,
  	          high = array == null ? 0 : array.length;
  	      if (high === 0) {
  	        return 0;
  	      }

  	      value = iteratee(value);
  	      var valIsNaN = value !== value,
  	          valIsNull = value === null,
  	          valIsSymbol = isSymbol(value),
  	          valIsUndefined = value === undefined$1;

  	      while (low < high) {
  	        var mid = nativeFloor((low + high) / 2),
  	            computed = iteratee(array[mid]),
  	            othIsDefined = computed !== undefined$1,
  	            othIsNull = computed === null,
  	            othIsReflexive = computed === computed,
  	            othIsSymbol = isSymbol(computed);

  	        if (valIsNaN) {
  	          var setLow = retHighest || othIsReflexive;
  	        } else if (valIsUndefined) {
  	          setLow = othIsReflexive && (retHighest || othIsDefined);
  	        } else if (valIsNull) {
  	          setLow = othIsReflexive && othIsDefined && (retHighest || !othIsNull);
  	        } else if (valIsSymbol) {
  	          setLow = othIsReflexive && othIsDefined && !othIsNull && (retHighest || !othIsSymbol);
  	        } else if (othIsNull || othIsSymbol) {
  	          setLow = false;
  	        } else {
  	          setLow = retHighest ? (computed <= value) : (computed < value);
  	        }
  	        if (setLow) {
  	          low = mid + 1;
  	        } else {
  	          high = mid;
  	        }
  	      }
  	      return nativeMin(high, MAX_ARRAY_INDEX);
  	    }

  	    /**
  	     * The base implementation of `_.sortedUniq` and `_.sortedUniqBy` without
  	     * support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @returns {Array} Returns the new duplicate free array.
  	     */
  	    function baseSortedUniq(array, iteratee) {
  	      var index = -1,
  	          length = array.length,
  	          resIndex = 0,
  	          result = [];

  	      while (++index < length) {
  	        var value = array[index],
  	            computed = iteratee ? iteratee(value) : value;

  	        if (!index || !eq(computed, seen)) {
  	          var seen = computed;
  	          result[resIndex++] = value === 0 ? 0 : value;
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.toNumber` which doesn't ensure correct
  	     * conversions of binary, hexadecimal, or octal string values.
  	     *
  	     * @private
  	     * @param {*} value The value to process.
  	     * @returns {number} Returns the number.
  	     */
  	    function baseToNumber(value) {
  	      if (typeof value == 'number') {
  	        return value;
  	      }
  	      if (isSymbol(value)) {
  	        return NAN;
  	      }
  	      return +value;
  	    }

  	    /**
  	     * The base implementation of `_.toString` which doesn't convert nullish
  	     * values to empty strings.
  	     *
  	     * @private
  	     * @param {*} value The value to process.
  	     * @returns {string} Returns the string.
  	     */
  	    function baseToString(value) {
  	      // Exit early for strings to avoid a performance hit in some environments.
  	      if (typeof value == 'string') {
  	        return value;
  	      }
  	      if (isArray(value)) {
  	        // Recursively convert values (susceptible to call stack limits).
  	        return arrayMap(value, baseToString) + '';
  	      }
  	      if (isSymbol(value)) {
  	        return symbolToString ? symbolToString.call(value) : '';
  	      }
  	      var result = (value + '');
  	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  	    }

  	    /**
  	     * The base implementation of `_.uniqBy` without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new duplicate free array.
  	     */
  	    function baseUniq(array, iteratee, comparator) {
  	      var index = -1,
  	          includes = arrayIncludes,
  	          length = array.length,
  	          isCommon = true,
  	          result = [],
  	          seen = result;

  	      if (comparator) {
  	        isCommon = false;
  	        includes = arrayIncludesWith;
  	      }
  	      else if (length >= LARGE_ARRAY_SIZE) {
  	        var set = iteratee ? null : createSet(array);
  	        if (set) {
  	          return setToArray(set);
  	        }
  	        isCommon = false;
  	        includes = cacheHas;
  	        seen = new SetCache;
  	      }
  	      else {
  	        seen = iteratee ? [] : result;
  	      }
  	      outer:
  	      while (++index < length) {
  	        var value = array[index],
  	            computed = iteratee ? iteratee(value) : value;

  	        value = (comparator || value !== 0) ? value : 0;
  	        if (isCommon && computed === computed) {
  	          var seenIndex = seen.length;
  	          while (seenIndex--) {
  	            if (seen[seenIndex] === computed) {
  	              continue outer;
  	            }
  	          }
  	          if (iteratee) {
  	            seen.push(computed);
  	          }
  	          result.push(value);
  	        }
  	        else if (!includes(seen, computed, comparator)) {
  	          if (seen !== result) {
  	            seen.push(computed);
  	          }
  	          result.push(value);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * The base implementation of `_.unset`.
  	     *
  	     * @private
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The property path to unset.
  	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
  	     */
  	    function baseUnset(object, path) {
  	      path = castPath(path, object);
  	      object = parent(object, path);
  	      return object == null || delete object[toKey(last(path))];
  	    }

  	    /**
  	     * The base implementation of `_.update`.
  	     *
  	     * @private
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to update.
  	     * @param {Function} updater The function to produce the updated value.
  	     * @param {Function} [customizer] The function to customize path creation.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function baseUpdate(object, path, updater, customizer) {
  	      return baseSet(object, path, updater(baseGet(object, path)), customizer);
  	    }

  	    /**
  	     * The base implementation of methods like `_.dropWhile` and `_.takeWhile`
  	     * without support for iteratee shorthands.
  	     *
  	     * @private
  	     * @param {Array} array The array to query.
  	     * @param {Function} predicate The function invoked per iteration.
  	     * @param {boolean} [isDrop] Specify dropping elements instead of taking them.
  	     * @param {boolean} [fromRight] Specify iterating from right to left.
  	     * @returns {Array} Returns the slice of `array`.
  	     */
  	    function baseWhile(array, predicate, isDrop, fromRight) {
  	      var length = array.length,
  	          index = fromRight ? length : -1;

  	      while ((fromRight ? index-- : ++index < length) &&
  	        predicate(array[index], index, array)) {}

  	      return isDrop
  	        ? baseSlice(array, (fromRight ? 0 : index), (fromRight ? index + 1 : length))
  	        : baseSlice(array, (fromRight ? index + 1 : 0), (fromRight ? length : index));
  	    }

  	    /**
  	     * The base implementation of `wrapperValue` which returns the result of
  	     * performing a sequence of actions on the unwrapped `value`, where each
  	     * successive action is supplied the return value of the previous.
  	     *
  	     * @private
  	     * @param {*} value The unwrapped value.
  	     * @param {Array} actions Actions to perform to resolve the unwrapped value.
  	     * @returns {*} Returns the resolved value.
  	     */
  	    function baseWrapperValue(value, actions) {
  	      var result = value;
  	      if (result instanceof LazyWrapper) {
  	        result = result.value();
  	      }
  	      return arrayReduce(actions, function(result, action) {
  	        return action.func.apply(action.thisArg, arrayPush([result], action.args));
  	      }, result);
  	    }

  	    /**
  	     * The base implementation of methods like `_.xor`, without support for
  	     * iteratee shorthands, that accepts an array of arrays to inspect.
  	     *
  	     * @private
  	     * @param {Array} arrays The arrays to inspect.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of values.
  	     */
  	    function baseXor(arrays, iteratee, comparator) {
  	      var length = arrays.length;
  	      if (length < 2) {
  	        return length ? baseUniq(arrays[0]) : [];
  	      }
  	      var index = -1,
  	          result = Array(length);

  	      while (++index < length) {
  	        var array = arrays[index],
  	            othIndex = -1;

  	        while (++othIndex < length) {
  	          if (othIndex != index) {
  	            result[index] = baseDifference(result[index] || array, arrays[othIndex], iteratee, comparator);
  	          }
  	        }
  	      }
  	      return baseUniq(baseFlatten(result, 1), iteratee, comparator);
  	    }

  	    /**
  	     * This base implementation of `_.zipObject` which assigns values using `assignFunc`.
  	     *
  	     * @private
  	     * @param {Array} props The property identifiers.
  	     * @param {Array} values The property values.
  	     * @param {Function} assignFunc The function to assign values.
  	     * @returns {Object} Returns the new object.
  	     */
  	    function baseZipObject(props, values, assignFunc) {
  	      var index = -1,
  	          length = props.length,
  	          valsLength = values.length,
  	          result = {};

  	      while (++index < length) {
  	        var value = index < valsLength ? values[index] : undefined$1;
  	        assignFunc(result, props[index], value);
  	      }
  	      return result;
  	    }

  	    /**
  	     * Casts `value` to an empty array if it's not an array like object.
  	     *
  	     * @private
  	     * @param {*} value The value to inspect.
  	     * @returns {Array|Object} Returns the cast array-like object.
  	     */
  	    function castArrayLikeObject(value) {
  	      return isArrayLikeObject(value) ? value : [];
  	    }

  	    /**
  	     * Casts `value` to `identity` if it's not a function.
  	     *
  	     * @private
  	     * @param {*} value The value to inspect.
  	     * @returns {Function} Returns cast function.
  	     */
  	    function castFunction(value) {
  	      return typeof value == 'function' ? value : identity;
  	    }

  	    /**
  	     * Casts `value` to a path array if it's not one.
  	     *
  	     * @private
  	     * @param {*} value The value to inspect.
  	     * @param {Object} [object] The object to query keys on.
  	     * @returns {Array} Returns the cast property path array.
  	     */
  	    function castPath(value, object) {
  	      if (isArray(value)) {
  	        return value;
  	      }
  	      return isKey(value, object) ? [value] : stringToPath(toString(value));
  	    }

  	    /**
  	     * A `baseRest` alias which can be replaced with `identity` by module
  	     * replacement plugins.
  	     *
  	     * @private
  	     * @type {Function}
  	     * @param {Function} func The function to apply a rest parameter to.
  	     * @returns {Function} Returns the new function.
  	     */
  	    var castRest = baseRest;

  	    /**
  	     * Casts `array` to a slice if it's needed.
  	     *
  	     * @private
  	     * @param {Array} array The array to inspect.
  	     * @param {number} start The start position.
  	     * @param {number} [end=array.length] The end position.
  	     * @returns {Array} Returns the cast slice.
  	     */
  	    function castSlice(array, start, end) {
  	      var length = array.length;
  	      end = end === undefined$1 ? length : end;
  	      return (!start && end >= length) ? array : baseSlice(array, start, end);
  	    }

  	    /**
  	     * A simple wrapper around the global [`clearTimeout`](https://mdn.io/clearTimeout).
  	     *
  	     * @private
  	     * @param {number|Object} id The timer id or timeout object of the timer to clear.
  	     */
  	    var clearTimeout = ctxClearTimeout || function(id) {
  	      return root.clearTimeout(id);
  	    };

  	    /**
  	     * Creates a clone of  `buffer`.
  	     *
  	     * @private
  	     * @param {Buffer} buffer The buffer to clone.
  	     * @param {boolean} [isDeep] Specify a deep clone.
  	     * @returns {Buffer} Returns the cloned buffer.
  	     */
  	    function cloneBuffer(buffer, isDeep) {
  	      if (isDeep) {
  	        return buffer.slice();
  	      }
  	      var length = buffer.length,
  	          result = allocUnsafe ? allocUnsafe(length) : new buffer.constructor(length);

  	      buffer.copy(result);
  	      return result;
  	    }

  	    /**
  	     * Creates a clone of `arrayBuffer`.
  	     *
  	     * @private
  	     * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
  	     * @returns {ArrayBuffer} Returns the cloned array buffer.
  	     */
  	    function cloneArrayBuffer(arrayBuffer) {
  	      var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
  	      new Uint8Array(result).set(new Uint8Array(arrayBuffer));
  	      return result;
  	    }

  	    /**
  	     * Creates a clone of `dataView`.
  	     *
  	     * @private
  	     * @param {Object} dataView The data view to clone.
  	     * @param {boolean} [isDeep] Specify a deep clone.
  	     * @returns {Object} Returns the cloned data view.
  	     */
  	    function cloneDataView(dataView, isDeep) {
  	      var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
  	      return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  	    }

  	    /**
  	     * Creates a clone of `regexp`.
  	     *
  	     * @private
  	     * @param {Object} regexp The regexp to clone.
  	     * @returns {Object} Returns the cloned regexp.
  	     */
  	    function cloneRegExp(regexp) {
  	      var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
  	      result.lastIndex = regexp.lastIndex;
  	      return result;
  	    }

  	    /**
  	     * Creates a clone of the `symbol` object.
  	     *
  	     * @private
  	     * @param {Object} symbol The symbol object to clone.
  	     * @returns {Object} Returns the cloned symbol object.
  	     */
  	    function cloneSymbol(symbol) {
  	      return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  	    }

  	    /**
  	     * Creates a clone of `typedArray`.
  	     *
  	     * @private
  	     * @param {Object} typedArray The typed array to clone.
  	     * @param {boolean} [isDeep] Specify a deep clone.
  	     * @returns {Object} Returns the cloned typed array.
  	     */
  	    function cloneTypedArray(typedArray, isDeep) {
  	      var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
  	      return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  	    }

  	    /**
  	     * Compares values to sort them in ascending order.
  	     *
  	     * @private
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {number} Returns the sort order indicator for `value`.
  	     */
  	    function compareAscending(value, other) {
  	      if (value !== other) {
  	        var valIsDefined = value !== undefined$1,
  	            valIsNull = value === null,
  	            valIsReflexive = value === value,
  	            valIsSymbol = isSymbol(value);

  	        var othIsDefined = other !== undefined$1,
  	            othIsNull = other === null,
  	            othIsReflexive = other === other,
  	            othIsSymbol = isSymbol(other);

  	        if ((!othIsNull && !othIsSymbol && !valIsSymbol && value > other) ||
  	            (valIsSymbol && othIsDefined && othIsReflexive && !othIsNull && !othIsSymbol) ||
  	            (valIsNull && othIsDefined && othIsReflexive) ||
  	            (!valIsDefined && othIsReflexive) ||
  	            !valIsReflexive) {
  	          return 1;
  	        }
  	        if ((!valIsNull && !valIsSymbol && !othIsSymbol && value < other) ||
  	            (othIsSymbol && valIsDefined && valIsReflexive && !valIsNull && !valIsSymbol) ||
  	            (othIsNull && valIsDefined && valIsReflexive) ||
  	            (!othIsDefined && valIsReflexive) ||
  	            !othIsReflexive) {
  	          return -1;
  	        }
  	      }
  	      return 0;
  	    }

  	    /**
  	     * Used by `_.orderBy` to compare multiple properties of a value to another
  	     * and stable sort them.
  	     *
  	     * If `orders` is unspecified, all values are sorted in ascending order. Otherwise,
  	     * specify an order of "desc" for descending or "asc" for ascending sort order
  	     * of corresponding values.
  	     *
  	     * @private
  	     * @param {Object} object The object to compare.
  	     * @param {Object} other The other object to compare.
  	     * @param {boolean[]|string[]} orders The order to sort by for each property.
  	     * @returns {number} Returns the sort order indicator for `object`.
  	     */
  	    function compareMultiple(object, other, orders) {
  	      var index = -1,
  	          objCriteria = object.criteria,
  	          othCriteria = other.criteria,
  	          length = objCriteria.length,
  	          ordersLength = orders.length;

  	      while (++index < length) {
  	        var result = compareAscending(objCriteria[index], othCriteria[index]);
  	        if (result) {
  	          if (index >= ordersLength) {
  	            return result;
  	          }
  	          var order = orders[index];
  	          return result * (order == 'desc' ? -1 : 1);
  	        }
  	      }
  	      // Fixes an `Array#sort` bug in the JS engine embedded in Adobe applications
  	      // that causes it, under certain circumstances, to provide the same value for
  	      // `object` and `other`. See https://github.com/jashkenas/underscore/pull/1247
  	      // for more details.
  	      //
  	      // This also ensures a stable sort in V8 and other engines.
  	      // See https://bugs.chromium.org/p/v8/issues/detail?id=90 for more details.
  	      return object.index - other.index;
  	    }

  	    /**
  	     * Creates an array that is the composition of partially applied arguments,
  	     * placeholders, and provided arguments into a single array of arguments.
  	     *
  	     * @private
  	     * @param {Array} args The provided arguments.
  	     * @param {Array} partials The arguments to prepend to those provided.
  	     * @param {Array} holders The `partials` placeholder indexes.
  	     * @params {boolean} [isCurried] Specify composing for a curried function.
  	     * @returns {Array} Returns the new array of composed arguments.
  	     */
  	    function composeArgs(args, partials, holders, isCurried) {
  	      var argsIndex = -1,
  	          argsLength = args.length,
  	          holdersLength = holders.length,
  	          leftIndex = -1,
  	          leftLength = partials.length,
  	          rangeLength = nativeMax(argsLength - holdersLength, 0),
  	          result = Array(leftLength + rangeLength),
  	          isUncurried = !isCurried;

  	      while (++leftIndex < leftLength) {
  	        result[leftIndex] = partials[leftIndex];
  	      }
  	      while (++argsIndex < holdersLength) {
  	        if (isUncurried || argsIndex < argsLength) {
  	          result[holders[argsIndex]] = args[argsIndex];
  	        }
  	      }
  	      while (rangeLength--) {
  	        result[leftIndex++] = args[argsIndex++];
  	      }
  	      return result;
  	    }

  	    /**
  	     * This function is like `composeArgs` except that the arguments composition
  	     * is tailored for `_.partialRight`.
  	     *
  	     * @private
  	     * @param {Array} args The provided arguments.
  	     * @param {Array} partials The arguments to append to those provided.
  	     * @param {Array} holders The `partials` placeholder indexes.
  	     * @params {boolean} [isCurried] Specify composing for a curried function.
  	     * @returns {Array} Returns the new array of composed arguments.
  	     */
  	    function composeArgsRight(args, partials, holders, isCurried) {
  	      var argsIndex = -1,
  	          argsLength = args.length,
  	          holdersIndex = -1,
  	          holdersLength = holders.length,
  	          rightIndex = -1,
  	          rightLength = partials.length,
  	          rangeLength = nativeMax(argsLength - holdersLength, 0),
  	          result = Array(rangeLength + rightLength),
  	          isUncurried = !isCurried;

  	      while (++argsIndex < rangeLength) {
  	        result[argsIndex] = args[argsIndex];
  	      }
  	      var offset = argsIndex;
  	      while (++rightIndex < rightLength) {
  	        result[offset + rightIndex] = partials[rightIndex];
  	      }
  	      while (++holdersIndex < holdersLength) {
  	        if (isUncurried || argsIndex < argsLength) {
  	          result[offset + holders[holdersIndex]] = args[argsIndex++];
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * Copies the values of `source` to `array`.
  	     *
  	     * @private
  	     * @param {Array} source The array to copy values from.
  	     * @param {Array} [array=[]] The array to copy values to.
  	     * @returns {Array} Returns `array`.
  	     */
  	    function copyArray(source, array) {
  	      var index = -1,
  	          length = source.length;

  	      array || (array = Array(length));
  	      while (++index < length) {
  	        array[index] = source[index];
  	      }
  	      return array;
  	    }

  	    /**
  	     * Copies properties of `source` to `object`.
  	     *
  	     * @private
  	     * @param {Object} source The object to copy properties from.
  	     * @param {Array} props The property identifiers to copy.
  	     * @param {Object} [object={}] The object to copy properties to.
  	     * @param {Function} [customizer] The function to customize copied values.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function copyObject(source, props, object, customizer) {
  	      var isNew = !object;
  	      object || (object = {});

  	      var index = -1,
  	          length = props.length;

  	      while (++index < length) {
  	        var key = props[index];

  	        var newValue = customizer
  	          ? customizer(object[key], source[key], key, object, source)
  	          : undefined$1;

  	        if (newValue === undefined$1) {
  	          newValue = source[key];
  	        }
  	        if (isNew) {
  	          baseAssignValue(object, key, newValue);
  	        } else {
  	          assignValue(object, key, newValue);
  	        }
  	      }
  	      return object;
  	    }

  	    /**
  	     * Copies own symbols of `source` to `object`.
  	     *
  	     * @private
  	     * @param {Object} source The object to copy symbols from.
  	     * @param {Object} [object={}] The object to copy symbols to.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function copySymbols(source, object) {
  	      return copyObject(source, getSymbols(source), object);
  	    }

  	    /**
  	     * Copies own and inherited symbols of `source` to `object`.
  	     *
  	     * @private
  	     * @param {Object} source The object to copy symbols from.
  	     * @param {Object} [object={}] The object to copy symbols to.
  	     * @returns {Object} Returns `object`.
  	     */
  	    function copySymbolsIn(source, object) {
  	      return copyObject(source, getSymbolsIn(source), object);
  	    }

  	    /**
  	     * Creates a function like `_.groupBy`.
  	     *
  	     * @private
  	     * @param {Function} setter The function to set accumulator values.
  	     * @param {Function} [initializer] The accumulator object initializer.
  	     * @returns {Function} Returns the new aggregator function.
  	     */
  	    function createAggregator(setter, initializer) {
  	      return function(collection, iteratee) {
  	        var func = isArray(collection) ? arrayAggregator : baseAggregator,
  	            accumulator = initializer ? initializer() : {};

  	        return func(collection, setter, getIteratee(iteratee, 2), accumulator);
  	      };
  	    }

  	    /**
  	     * Creates a function like `_.assign`.
  	     *
  	     * @private
  	     * @param {Function} assigner The function to assign values.
  	     * @returns {Function} Returns the new assigner function.
  	     */
  	    function createAssigner(assigner) {
  	      return baseRest(function(object, sources) {
  	        var index = -1,
  	            length = sources.length,
  	            customizer = length > 1 ? sources[length - 1] : undefined$1,
  	            guard = length > 2 ? sources[2] : undefined$1;

  	        customizer = (assigner.length > 3 && typeof customizer == 'function')
  	          ? (length--, customizer)
  	          : undefined$1;

  	        if (guard && isIterateeCall(sources[0], sources[1], guard)) {
  	          customizer = length < 3 ? undefined$1 : customizer;
  	          length = 1;
  	        }
  	        object = Object(object);
  	        while (++index < length) {
  	          var source = sources[index];
  	          if (source) {
  	            assigner(object, source, index, customizer);
  	          }
  	        }
  	        return object;
  	      });
  	    }

  	    /**
  	     * Creates a `baseEach` or `baseEachRight` function.
  	     *
  	     * @private
  	     * @param {Function} eachFunc The function to iterate over a collection.
  	     * @param {boolean} [fromRight] Specify iterating from right to left.
  	     * @returns {Function} Returns the new base function.
  	     */
  	    function createBaseEach(eachFunc, fromRight) {
  	      return function(collection, iteratee) {
  	        if (collection == null) {
  	          return collection;
  	        }
  	        if (!isArrayLike(collection)) {
  	          return eachFunc(collection, iteratee);
  	        }
  	        var length = collection.length,
  	            index = fromRight ? length : -1,
  	            iterable = Object(collection);

  	        while ((fromRight ? index-- : ++index < length)) {
  	          if (iteratee(iterable[index], index, iterable) === false) {
  	            break;
  	          }
  	        }
  	        return collection;
  	      };
  	    }

  	    /**
  	     * Creates a base function for methods like `_.forIn` and `_.forOwn`.
  	     *
  	     * @private
  	     * @param {boolean} [fromRight] Specify iterating from right to left.
  	     * @returns {Function} Returns the new base function.
  	     */
  	    function createBaseFor(fromRight) {
  	      return function(object, iteratee, keysFunc) {
  	        var index = -1,
  	            iterable = Object(object),
  	            props = keysFunc(object),
  	            length = props.length;

  	        while (length--) {
  	          var key = props[fromRight ? length : ++index];
  	          if (iteratee(iterable[key], key, iterable) === false) {
  	            break;
  	          }
  	        }
  	        return object;
  	      };
  	    }

  	    /**
  	     * Creates a function that wraps `func` to invoke it with the optional `this`
  	     * binding of `thisArg`.
  	     *
  	     * @private
  	     * @param {Function} func The function to wrap.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @param {*} [thisArg] The `this` binding of `func`.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createBind(func, bitmask, thisArg) {
  	      var isBind = bitmask & WRAP_BIND_FLAG,
  	          Ctor = createCtor(func);

  	      function wrapper() {
  	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
  	        return fn.apply(isBind ? thisArg : this, arguments);
  	      }
  	      return wrapper;
  	    }

  	    /**
  	     * Creates a function like `_.lowerFirst`.
  	     *
  	     * @private
  	     * @param {string} methodName The name of the `String` case method to use.
  	     * @returns {Function} Returns the new case function.
  	     */
  	    function createCaseFirst(methodName) {
  	      return function(string) {
  	        string = toString(string);

  	        var strSymbols = hasUnicode(string)
  	          ? stringToArray(string)
  	          : undefined$1;

  	        var chr = strSymbols
  	          ? strSymbols[0]
  	          : string.charAt(0);

  	        var trailing = strSymbols
  	          ? castSlice(strSymbols, 1).join('')
  	          : string.slice(1);

  	        return chr[methodName]() + trailing;
  	      };
  	    }

  	    /**
  	     * Creates a function like `_.camelCase`.
  	     *
  	     * @private
  	     * @param {Function} callback The function to combine each word.
  	     * @returns {Function} Returns the new compounder function.
  	     */
  	    function createCompounder(callback) {
  	      return function(string) {
  	        return arrayReduce(words(deburr(string).replace(reApos, '')), callback, '');
  	      };
  	    }

  	    /**
  	     * Creates a function that produces an instance of `Ctor` regardless of
  	     * whether it was invoked as part of a `new` expression or by `call` or `apply`.
  	     *
  	     * @private
  	     * @param {Function} Ctor The constructor to wrap.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createCtor(Ctor) {
  	      return function() {
  	        // Use a `switch` statement to work with class constructors. See
  	        // http://ecma-international.org/ecma-262/7.0/#sec-ecmascript-function-objects-call-thisargument-argumentslist
  	        // for more details.
  	        var args = arguments;
  	        switch (args.length) {
  	          case 0: return new Ctor;
  	          case 1: return new Ctor(args[0]);
  	          case 2: return new Ctor(args[0], args[1]);
  	          case 3: return new Ctor(args[0], args[1], args[2]);
  	          case 4: return new Ctor(args[0], args[1], args[2], args[3]);
  	          case 5: return new Ctor(args[0], args[1], args[2], args[3], args[4]);
  	          case 6: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5]);
  	          case 7: return new Ctor(args[0], args[1], args[2], args[3], args[4], args[5], args[6]);
  	        }
  	        var thisBinding = baseCreate(Ctor.prototype),
  	            result = Ctor.apply(thisBinding, args);

  	        // Mimic the constructor's `return` behavior.
  	        // See https://es5.github.io/#x13.2.2 for more details.
  	        return isObject(result) ? result : thisBinding;
  	      };
  	    }

  	    /**
  	     * Creates a function that wraps `func` to enable currying.
  	     *
  	     * @private
  	     * @param {Function} func The function to wrap.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @param {number} arity The arity of `func`.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createCurry(func, bitmask, arity) {
  	      var Ctor = createCtor(func);

  	      function wrapper() {
  	        var length = arguments.length,
  	            args = Array(length),
  	            index = length,
  	            placeholder = getHolder(wrapper);

  	        while (index--) {
  	          args[index] = arguments[index];
  	        }
  	        var holders = (length < 3 && args[0] !== placeholder && args[length - 1] !== placeholder)
  	          ? []
  	          : replaceHolders(args, placeholder);

  	        length -= holders.length;
  	        if (length < arity) {
  	          return createRecurry(
  	            func, bitmask, createHybrid, wrapper.placeholder, undefined$1,
  	            args, holders, undefined$1, undefined$1, arity - length);
  	        }
  	        var fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;
  	        return apply(fn, this, args);
  	      }
  	      return wrapper;
  	    }

  	    /**
  	     * Creates a `_.find` or `_.findLast` function.
  	     *
  	     * @private
  	     * @param {Function} findIndexFunc The function to find the collection index.
  	     * @returns {Function} Returns the new find function.
  	     */
  	    function createFind(findIndexFunc) {
  	      return function(collection, predicate, fromIndex) {
  	        var iterable = Object(collection);
  	        if (!isArrayLike(collection)) {
  	          var iteratee = getIteratee(predicate, 3);
  	          collection = keys(collection);
  	          predicate = function(key) { return iteratee(iterable[key], key, iterable); };
  	        }
  	        var index = findIndexFunc(collection, predicate, fromIndex);
  	        return index > -1 ? iterable[iteratee ? collection[index] : index] : undefined$1;
  	      };
  	    }

  	    /**
  	     * Creates a `_.flow` or `_.flowRight` function.
  	     *
  	     * @private
  	     * @param {boolean} [fromRight] Specify iterating from right to left.
  	     * @returns {Function} Returns the new flow function.
  	     */
  	    function createFlow(fromRight) {
  	      return flatRest(function(funcs) {
  	        var length = funcs.length,
  	            index = length,
  	            prereq = LodashWrapper.prototype.thru;

  	        if (fromRight) {
  	          funcs.reverse();
  	        }
  	        while (index--) {
  	          var func = funcs[index];
  	          if (typeof func != 'function') {
  	            throw new TypeError(FUNC_ERROR_TEXT);
  	          }
  	          if (prereq && !wrapper && getFuncName(func) == 'wrapper') {
  	            var wrapper = new LodashWrapper([], true);
  	          }
  	        }
  	        index = wrapper ? index : length;
  	        while (++index < length) {
  	          func = funcs[index];

  	          var funcName = getFuncName(func),
  	              data = funcName == 'wrapper' ? getData(func) : undefined$1;

  	          if (data && isLaziable(data[0]) &&
  	                data[1] == (WRAP_ARY_FLAG | WRAP_CURRY_FLAG | WRAP_PARTIAL_FLAG | WRAP_REARG_FLAG) &&
  	                !data[4].length && data[9] == 1
  	              ) {
  	            wrapper = wrapper[getFuncName(data[0])].apply(wrapper, data[3]);
  	          } else {
  	            wrapper = (func.length == 1 && isLaziable(func))
  	              ? wrapper[funcName]()
  	              : wrapper.thru(func);
  	          }
  	        }
  	        return function() {
  	          var args = arguments,
  	              value = args[0];

  	          if (wrapper && args.length == 1 && isArray(value)) {
  	            return wrapper.plant(value).value();
  	          }
  	          var index = 0,
  	              result = length ? funcs[index].apply(this, args) : value;

  	          while (++index < length) {
  	            result = funcs[index].call(this, result);
  	          }
  	          return result;
  	        };
  	      });
  	    }

  	    /**
  	     * Creates a function that wraps `func` to invoke it with optional `this`
  	     * binding of `thisArg`, partial application, and currying.
  	     *
  	     * @private
  	     * @param {Function|string} func The function or method name to wrap.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @param {*} [thisArg] The `this` binding of `func`.
  	     * @param {Array} [partials] The arguments to prepend to those provided to
  	     *  the new function.
  	     * @param {Array} [holders] The `partials` placeholder indexes.
  	     * @param {Array} [partialsRight] The arguments to append to those provided
  	     *  to the new function.
  	     * @param {Array} [holdersRight] The `partialsRight` placeholder indexes.
  	     * @param {Array} [argPos] The argument positions of the new function.
  	     * @param {number} [ary] The arity cap of `func`.
  	     * @param {number} [arity] The arity of `func`.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createHybrid(func, bitmask, thisArg, partials, holders, partialsRight, holdersRight, argPos, ary, arity) {
  	      var isAry = bitmask & WRAP_ARY_FLAG,
  	          isBind = bitmask & WRAP_BIND_FLAG,
  	          isBindKey = bitmask & WRAP_BIND_KEY_FLAG,
  	          isCurried = bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG),
  	          isFlip = bitmask & WRAP_FLIP_FLAG,
  	          Ctor = isBindKey ? undefined$1 : createCtor(func);

  	      function wrapper() {
  	        var length = arguments.length,
  	            args = Array(length),
  	            index = length;

  	        while (index--) {
  	          args[index] = arguments[index];
  	        }
  	        if (isCurried) {
  	          var placeholder = getHolder(wrapper),
  	              holdersCount = countHolders(args, placeholder);
  	        }
  	        if (partials) {
  	          args = composeArgs(args, partials, holders, isCurried);
  	        }
  	        if (partialsRight) {
  	          args = composeArgsRight(args, partialsRight, holdersRight, isCurried);
  	        }
  	        length -= holdersCount;
  	        if (isCurried && length < arity) {
  	          var newHolders = replaceHolders(args, placeholder);
  	          return createRecurry(
  	            func, bitmask, createHybrid, wrapper.placeholder, thisArg,
  	            args, newHolders, argPos, ary, arity - length
  	          );
  	        }
  	        var thisBinding = isBind ? thisArg : this,
  	            fn = isBindKey ? thisBinding[func] : func;

  	        length = args.length;
  	        if (argPos) {
  	          args = reorder(args, argPos);
  	        } else if (isFlip && length > 1) {
  	          args.reverse();
  	        }
  	        if (isAry && ary < length) {
  	          args.length = ary;
  	        }
  	        if (this && this !== root && this instanceof wrapper) {
  	          fn = Ctor || createCtor(fn);
  	        }
  	        return fn.apply(thisBinding, args);
  	      }
  	      return wrapper;
  	    }

  	    /**
  	     * Creates a function like `_.invertBy`.
  	     *
  	     * @private
  	     * @param {Function} setter The function to set accumulator values.
  	     * @param {Function} toIteratee The function to resolve iteratees.
  	     * @returns {Function} Returns the new inverter function.
  	     */
  	    function createInverter(setter, toIteratee) {
  	      return function(object, iteratee) {
  	        return baseInverter(object, setter, toIteratee(iteratee), {});
  	      };
  	    }

  	    /**
  	     * Creates a function that performs a mathematical operation on two values.
  	     *
  	     * @private
  	     * @param {Function} operator The function to perform the operation.
  	     * @param {number} [defaultValue] The value used for `undefined` arguments.
  	     * @returns {Function} Returns the new mathematical operation function.
  	     */
  	    function createMathOperation(operator, defaultValue) {
  	      return function(value, other) {
  	        var result;
  	        if (value === undefined$1 && other === undefined$1) {
  	          return defaultValue;
  	        }
  	        if (value !== undefined$1) {
  	          result = value;
  	        }
  	        if (other !== undefined$1) {
  	          if (result === undefined$1) {
  	            return other;
  	          }
  	          if (typeof value == 'string' || typeof other == 'string') {
  	            value = baseToString(value);
  	            other = baseToString(other);
  	          } else {
  	            value = baseToNumber(value);
  	            other = baseToNumber(other);
  	          }
  	          result = operator(value, other);
  	        }
  	        return result;
  	      };
  	    }

  	    /**
  	     * Creates a function like `_.over`.
  	     *
  	     * @private
  	     * @param {Function} arrayFunc The function to iterate over iteratees.
  	     * @returns {Function} Returns the new over function.
  	     */
  	    function createOver(arrayFunc) {
  	      return flatRest(function(iteratees) {
  	        iteratees = arrayMap(iteratees, baseUnary(getIteratee()));
  	        return baseRest(function(args) {
  	          var thisArg = this;
  	          return arrayFunc(iteratees, function(iteratee) {
  	            return apply(iteratee, thisArg, args);
  	          });
  	        });
  	      });
  	    }

  	    /**
  	     * Creates the padding for `string` based on `length`. The `chars` string
  	     * is truncated if the number of characters exceeds `length`.
  	     *
  	     * @private
  	     * @param {number} length The padding length.
  	     * @param {string} [chars=' '] The string used as padding.
  	     * @returns {string} Returns the padding for `string`.
  	     */
  	    function createPadding(length, chars) {
  	      chars = chars === undefined$1 ? ' ' : baseToString(chars);

  	      var charsLength = chars.length;
  	      if (charsLength < 2) {
  	        return charsLength ? baseRepeat(chars, length) : chars;
  	      }
  	      var result = baseRepeat(chars, nativeCeil(length / stringSize(chars)));
  	      return hasUnicode(chars)
  	        ? castSlice(stringToArray(result), 0, length).join('')
  	        : result.slice(0, length);
  	    }

  	    /**
  	     * Creates a function that wraps `func` to invoke it with the `this` binding
  	     * of `thisArg` and `partials` prepended to the arguments it receives.
  	     *
  	     * @private
  	     * @param {Function} func The function to wrap.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @param {*} thisArg The `this` binding of `func`.
  	     * @param {Array} partials The arguments to prepend to those provided to
  	     *  the new function.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createPartial(func, bitmask, thisArg, partials) {
  	      var isBind = bitmask & WRAP_BIND_FLAG,
  	          Ctor = createCtor(func);

  	      function wrapper() {
  	        var argsIndex = -1,
  	            argsLength = arguments.length,
  	            leftIndex = -1,
  	            leftLength = partials.length,
  	            args = Array(leftLength + argsLength),
  	            fn = (this && this !== root && this instanceof wrapper) ? Ctor : func;

  	        while (++leftIndex < leftLength) {
  	          args[leftIndex] = partials[leftIndex];
  	        }
  	        while (argsLength--) {
  	          args[leftIndex++] = arguments[++argsIndex];
  	        }
  	        return apply(fn, isBind ? thisArg : this, args);
  	      }
  	      return wrapper;
  	    }

  	    /**
  	     * Creates a `_.range` or `_.rangeRight` function.
  	     *
  	     * @private
  	     * @param {boolean} [fromRight] Specify iterating from right to left.
  	     * @returns {Function} Returns the new range function.
  	     */
  	    function createRange(fromRight) {
  	      return function(start, end, step) {
  	        if (step && typeof step != 'number' && isIterateeCall(start, end, step)) {
  	          end = step = undefined$1;
  	        }
  	        // Ensure the sign of `-0` is preserved.
  	        start = toFinite(start);
  	        if (end === undefined$1) {
  	          end = start;
  	          start = 0;
  	        } else {
  	          end = toFinite(end);
  	        }
  	        step = step === undefined$1 ? (start < end ? 1 : -1) : toFinite(step);
  	        return baseRange(start, end, step, fromRight);
  	      };
  	    }

  	    /**
  	     * Creates a function that performs a relational operation on two values.
  	     *
  	     * @private
  	     * @param {Function} operator The function to perform the operation.
  	     * @returns {Function} Returns the new relational operation function.
  	     */
  	    function createRelationalOperation(operator) {
  	      return function(value, other) {
  	        if (!(typeof value == 'string' && typeof other == 'string')) {
  	          value = toNumber(value);
  	          other = toNumber(other);
  	        }
  	        return operator(value, other);
  	      };
  	    }

  	    /**
  	     * Creates a function that wraps `func` to continue currying.
  	     *
  	     * @private
  	     * @param {Function} func The function to wrap.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @param {Function} wrapFunc The function to create the `func` wrapper.
  	     * @param {*} placeholder The placeholder value.
  	     * @param {*} [thisArg] The `this` binding of `func`.
  	     * @param {Array} [partials] The arguments to prepend to those provided to
  	     *  the new function.
  	     * @param {Array} [holders] The `partials` placeholder indexes.
  	     * @param {Array} [argPos] The argument positions of the new function.
  	     * @param {number} [ary] The arity cap of `func`.
  	     * @param {number} [arity] The arity of `func`.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createRecurry(func, bitmask, wrapFunc, placeholder, thisArg, partials, holders, argPos, ary, arity) {
  	      var isCurry = bitmask & WRAP_CURRY_FLAG,
  	          newHolders = isCurry ? holders : undefined$1,
  	          newHoldersRight = isCurry ? undefined$1 : holders,
  	          newPartials = isCurry ? partials : undefined$1,
  	          newPartialsRight = isCurry ? undefined$1 : partials;

  	      bitmask |= (isCurry ? WRAP_PARTIAL_FLAG : WRAP_PARTIAL_RIGHT_FLAG);
  	      bitmask &= ~(isCurry ? WRAP_PARTIAL_RIGHT_FLAG : WRAP_PARTIAL_FLAG);

  	      if (!(bitmask & WRAP_CURRY_BOUND_FLAG)) {
  	        bitmask &= ~(WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG);
  	      }
  	      var newData = [
  	        func, bitmask, thisArg, newPartials, newHolders, newPartialsRight,
  	        newHoldersRight, argPos, ary, arity
  	      ];

  	      var result = wrapFunc.apply(undefined$1, newData);
  	      if (isLaziable(func)) {
  	        setData(result, newData);
  	      }
  	      result.placeholder = placeholder;
  	      return setWrapToString(result, func, bitmask);
  	    }

  	    /**
  	     * Creates a function like `_.round`.
  	     *
  	     * @private
  	     * @param {string} methodName The name of the `Math` method to use when rounding.
  	     * @returns {Function} Returns the new round function.
  	     */
  	    function createRound(methodName) {
  	      var func = Math[methodName];
  	      return function(number, precision) {
  	        number = toNumber(number);
  	        precision = precision == null ? 0 : nativeMin(toInteger(precision), 292);
  	        if (precision && nativeIsFinite(number)) {
  	          // Shift with exponential notation to avoid floating-point issues.
  	          // See [MDN](https://mdn.io/round#Examples) for more details.
  	          var pair = (toString(number) + 'e').split('e'),
  	              value = func(pair[0] + 'e' + (+pair[1] + precision));

  	          pair = (toString(value) + 'e').split('e');
  	          return +(pair[0] + 'e' + (+pair[1] - precision));
  	        }
  	        return func(number);
  	      };
  	    }

  	    /**
  	     * Creates a set object of `values`.
  	     *
  	     * @private
  	     * @param {Array} values The values to add to the set.
  	     * @returns {Object} Returns the new set.
  	     */
  	    var createSet = !(Set && (1 / setToArray(new Set([,-0]))[1]) == INFINITY) ? noop : function(values) {
  	      return new Set(values);
  	    };

  	    /**
  	     * Creates a `_.toPairs` or `_.toPairsIn` function.
  	     *
  	     * @private
  	     * @param {Function} keysFunc The function to get the keys of a given object.
  	     * @returns {Function} Returns the new pairs function.
  	     */
  	    function createToPairs(keysFunc) {
  	      return function(object) {
  	        var tag = getTag(object);
  	        if (tag == mapTag) {
  	          return mapToArray(object);
  	        }
  	        if (tag == setTag) {
  	          return setToPairs(object);
  	        }
  	        return baseToPairs(object, keysFunc(object));
  	      };
  	    }

  	    /**
  	     * Creates a function that either curries or invokes `func` with optional
  	     * `this` binding and partially applied arguments.
  	     *
  	     * @private
  	     * @param {Function|string} func The function or method name to wrap.
  	     * @param {number} bitmask The bitmask flags.
  	     *    1 - `_.bind`
  	     *    2 - `_.bindKey`
  	     *    4 - `_.curry` or `_.curryRight` of a bound function
  	     *    8 - `_.curry`
  	     *   16 - `_.curryRight`
  	     *   32 - `_.partial`
  	     *   64 - `_.partialRight`
  	     *  128 - `_.rearg`
  	     *  256 - `_.ary`
  	     *  512 - `_.flip`
  	     * @param {*} [thisArg] The `this` binding of `func`.
  	     * @param {Array} [partials] The arguments to be partially applied.
  	     * @param {Array} [holders] The `partials` placeholder indexes.
  	     * @param {Array} [argPos] The argument positions of the new function.
  	     * @param {number} [ary] The arity cap of `func`.
  	     * @param {number} [arity] The arity of `func`.
  	     * @returns {Function} Returns the new wrapped function.
  	     */
  	    function createWrap(func, bitmask, thisArg, partials, holders, argPos, ary, arity) {
  	      var isBindKey = bitmask & WRAP_BIND_KEY_FLAG;
  	      if (!isBindKey && typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      var length = partials ? partials.length : 0;
  	      if (!length) {
  	        bitmask &= ~(WRAP_PARTIAL_FLAG | WRAP_PARTIAL_RIGHT_FLAG);
  	        partials = holders = undefined$1;
  	      }
  	      ary = ary === undefined$1 ? ary : nativeMax(toInteger(ary), 0);
  	      arity = arity === undefined$1 ? arity : toInteger(arity);
  	      length -= holders ? holders.length : 0;

  	      if (bitmask & WRAP_PARTIAL_RIGHT_FLAG) {
  	        var partialsRight = partials,
  	            holdersRight = holders;

  	        partials = holders = undefined$1;
  	      }
  	      var data = isBindKey ? undefined$1 : getData(func);

  	      var newData = [
  	        func, bitmask, thisArg, partials, holders, partialsRight, holdersRight,
  	        argPos, ary, arity
  	      ];

  	      if (data) {
  	        mergeData(newData, data);
  	      }
  	      func = newData[0];
  	      bitmask = newData[1];
  	      thisArg = newData[2];
  	      partials = newData[3];
  	      holders = newData[4];
  	      arity = newData[9] = newData[9] === undefined$1
  	        ? (isBindKey ? 0 : func.length)
  	        : nativeMax(newData[9] - length, 0);

  	      if (!arity && bitmask & (WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG)) {
  	        bitmask &= ~(WRAP_CURRY_FLAG | WRAP_CURRY_RIGHT_FLAG);
  	      }
  	      if (!bitmask || bitmask == WRAP_BIND_FLAG) {
  	        var result = createBind(func, bitmask, thisArg);
  	      } else if (bitmask == WRAP_CURRY_FLAG || bitmask == WRAP_CURRY_RIGHT_FLAG) {
  	        result = createCurry(func, bitmask, arity);
  	      } else if ((bitmask == WRAP_PARTIAL_FLAG || bitmask == (WRAP_BIND_FLAG | WRAP_PARTIAL_FLAG)) && !holders.length) {
  	        result = createPartial(func, bitmask, thisArg, partials);
  	      } else {
  	        result = createHybrid.apply(undefined$1, newData);
  	      }
  	      var setter = data ? baseSetData : setData;
  	      return setWrapToString(setter(result, newData), func, bitmask);
  	    }

  	    /**
  	     * Used by `_.defaults` to customize its `_.assignIn` use to assign properties
  	     * of source objects to the destination object for all destination properties
  	     * that resolve to `undefined`.
  	     *
  	     * @private
  	     * @param {*} objValue The destination value.
  	     * @param {*} srcValue The source value.
  	     * @param {string} key The key of the property to assign.
  	     * @param {Object} object The parent object of `objValue`.
  	     * @returns {*} Returns the value to assign.
  	     */
  	    function customDefaultsAssignIn(objValue, srcValue, key, object) {
  	      if (objValue === undefined$1 ||
  	          (eq(objValue, objectProto[key]) && !hasOwnProperty.call(object, key))) {
  	        return srcValue;
  	      }
  	      return objValue;
  	    }

  	    /**
  	     * Used by `_.defaultsDeep` to customize its `_.merge` use to merge source
  	     * objects into destination objects that are passed thru.
  	     *
  	     * @private
  	     * @param {*} objValue The destination value.
  	     * @param {*} srcValue The source value.
  	     * @param {string} key The key of the property to merge.
  	     * @param {Object} object The parent object of `objValue`.
  	     * @param {Object} source The parent object of `srcValue`.
  	     * @param {Object} [stack] Tracks traversed source values and their merged
  	     *  counterparts.
  	     * @returns {*} Returns the value to assign.
  	     */
  	    function customDefaultsMerge(objValue, srcValue, key, object, source, stack) {
  	      if (isObject(objValue) && isObject(srcValue)) {
  	        // Recursively merge objects and arrays (susceptible to call stack limits).
  	        stack.set(srcValue, objValue);
  	        baseMerge(objValue, srcValue, undefined$1, customDefaultsMerge, stack);
  	        stack['delete'](srcValue);
  	      }
  	      return objValue;
  	    }

  	    /**
  	     * Used by `_.omit` to customize its `_.cloneDeep` use to only clone plain
  	     * objects.
  	     *
  	     * @private
  	     * @param {*} value The value to inspect.
  	     * @param {string} key The key of the property to inspect.
  	     * @returns {*} Returns the uncloned value or `undefined` to defer cloning to `_.cloneDeep`.
  	     */
  	    function customOmitClone(value) {
  	      return isPlainObject(value) ? undefined$1 : value;
  	    }

  	    /**
  	     * A specialized version of `baseIsEqualDeep` for arrays with support for
  	     * partial deep comparisons.
  	     *
  	     * @private
  	     * @param {Array} array The array to compare.
  	     * @param {Array} other The other array to compare.
  	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	     * @param {Function} customizer The function to customize comparisons.
  	     * @param {Function} equalFunc The function to determine equivalents of values.
  	     * @param {Object} stack Tracks traversed `array` and `other` objects.
  	     * @returns {boolean} Returns `true` if the arrays are equivalent, else `false`.
  	     */
  	    function equalArrays(array, other, bitmask, customizer, equalFunc, stack) {
  	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
  	          arrLength = array.length,
  	          othLength = other.length;

  	      if (arrLength != othLength && !(isPartial && othLength > arrLength)) {
  	        return false;
  	      }
  	      // Check that cyclic values are equal.
  	      var arrStacked = stack.get(array);
  	      var othStacked = stack.get(other);
  	      if (arrStacked && othStacked) {
  	        return arrStacked == other && othStacked == array;
  	      }
  	      var index = -1,
  	          result = true,
  	          seen = (bitmask & COMPARE_UNORDERED_FLAG) ? new SetCache : undefined$1;

  	      stack.set(array, other);
  	      stack.set(other, array);

  	      // Ignore non-index properties.
  	      while (++index < arrLength) {
  	        var arrValue = array[index],
  	            othValue = other[index];

  	        if (customizer) {
  	          var compared = isPartial
  	            ? customizer(othValue, arrValue, index, other, array, stack)
  	            : customizer(arrValue, othValue, index, array, other, stack);
  	        }
  	        if (compared !== undefined$1) {
  	          if (compared) {
  	            continue;
  	          }
  	          result = false;
  	          break;
  	        }
  	        // Recursively compare arrays (susceptible to call stack limits).
  	        if (seen) {
  	          if (!arraySome(other, function(othValue, othIndex) {
  	                if (!cacheHas(seen, othIndex) &&
  	                    (arrValue === othValue || equalFunc(arrValue, othValue, bitmask, customizer, stack))) {
  	                  return seen.push(othIndex);
  	                }
  	              })) {
  	            result = false;
  	            break;
  	          }
  	        } else if (!(
  	              arrValue === othValue ||
  	                equalFunc(arrValue, othValue, bitmask, customizer, stack)
  	            )) {
  	          result = false;
  	          break;
  	        }
  	      }
  	      stack['delete'](array);
  	      stack['delete'](other);
  	      return result;
  	    }

  	    /**
  	     * A specialized version of `baseIsEqualDeep` for comparing objects of
  	     * the same `toStringTag`.
  	     *
  	     * **Note:** This function only supports comparing values with tags of
  	     * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
  	     *
  	     * @private
  	     * @param {Object} object The object to compare.
  	     * @param {Object} other The other object to compare.
  	     * @param {string} tag The `toStringTag` of the objects to compare.
  	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	     * @param {Function} customizer The function to customize comparisons.
  	     * @param {Function} equalFunc The function to determine equivalents of values.
  	     * @param {Object} stack Tracks traversed `object` and `other` objects.
  	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	     */
  	    function equalByTag(object, other, tag, bitmask, customizer, equalFunc, stack) {
  	      switch (tag) {
  	        case dataViewTag:
  	          if ((object.byteLength != other.byteLength) ||
  	              (object.byteOffset != other.byteOffset)) {
  	            return false;
  	          }
  	          object = object.buffer;
  	          other = other.buffer;

  	        case arrayBufferTag:
  	          if ((object.byteLength != other.byteLength) ||
  	              !equalFunc(new Uint8Array(object), new Uint8Array(other))) {
  	            return false;
  	          }
  	          return true;

  	        case boolTag:
  	        case dateTag:
  	        case numberTag:
  	          // Coerce booleans to `1` or `0` and dates to milliseconds.
  	          // Invalid dates are coerced to `NaN`.
  	          return eq(+object, +other);

  	        case errorTag:
  	          return object.name == other.name && object.message == other.message;

  	        case regexpTag:
  	        case stringTag:
  	          // Coerce regexes to strings and treat strings, primitives and objects,
  	          // as equal. See http://www.ecma-international.org/ecma-262/7.0/#sec-regexp.prototype.tostring
  	          // for more details.
  	          return object == (other + '');

  	        case mapTag:
  	          var convert = mapToArray;

  	        case setTag:
  	          var isPartial = bitmask & COMPARE_PARTIAL_FLAG;
  	          convert || (convert = setToArray);

  	          if (object.size != other.size && !isPartial) {
  	            return false;
  	          }
  	          // Assume cyclic values are equal.
  	          var stacked = stack.get(object);
  	          if (stacked) {
  	            return stacked == other;
  	          }
  	          bitmask |= COMPARE_UNORDERED_FLAG;

  	          // Recursively compare objects (susceptible to call stack limits).
  	          stack.set(object, other);
  	          var result = equalArrays(convert(object), convert(other), bitmask, customizer, equalFunc, stack);
  	          stack['delete'](object);
  	          return result;

  	        case symbolTag:
  	          if (symbolValueOf) {
  	            return symbolValueOf.call(object) == symbolValueOf.call(other);
  	          }
  	      }
  	      return false;
  	    }

  	    /**
  	     * A specialized version of `baseIsEqualDeep` for objects with support for
  	     * partial deep comparisons.
  	     *
  	     * @private
  	     * @param {Object} object The object to compare.
  	     * @param {Object} other The other object to compare.
  	     * @param {number} bitmask The bitmask flags. See `baseIsEqual` for more details.
  	     * @param {Function} customizer The function to customize comparisons.
  	     * @param {Function} equalFunc The function to determine equivalents of values.
  	     * @param {Object} stack Tracks traversed `object` and `other` objects.
  	     * @returns {boolean} Returns `true` if the objects are equivalent, else `false`.
  	     */
  	    function equalObjects(object, other, bitmask, customizer, equalFunc, stack) {
  	      var isPartial = bitmask & COMPARE_PARTIAL_FLAG,
  	          objProps = getAllKeys(object),
  	          objLength = objProps.length,
  	          othProps = getAllKeys(other),
  	          othLength = othProps.length;

  	      if (objLength != othLength && !isPartial) {
  	        return false;
  	      }
  	      var index = objLength;
  	      while (index--) {
  	        var key = objProps[index];
  	        if (!(isPartial ? key in other : hasOwnProperty.call(other, key))) {
  	          return false;
  	        }
  	      }
  	      // Check that cyclic values are equal.
  	      var objStacked = stack.get(object);
  	      var othStacked = stack.get(other);
  	      if (objStacked && othStacked) {
  	        return objStacked == other && othStacked == object;
  	      }
  	      var result = true;
  	      stack.set(object, other);
  	      stack.set(other, object);

  	      var skipCtor = isPartial;
  	      while (++index < objLength) {
  	        key = objProps[index];
  	        var objValue = object[key],
  	            othValue = other[key];

  	        if (customizer) {
  	          var compared = isPartial
  	            ? customizer(othValue, objValue, key, other, object, stack)
  	            : customizer(objValue, othValue, key, object, other, stack);
  	        }
  	        // Recursively compare objects (susceptible to call stack limits).
  	        if (!(compared === undefined$1
  	              ? (objValue === othValue || equalFunc(objValue, othValue, bitmask, customizer, stack))
  	              : compared
  	            )) {
  	          result = false;
  	          break;
  	        }
  	        skipCtor || (skipCtor = key == 'constructor');
  	      }
  	      if (result && !skipCtor) {
  	        var objCtor = object.constructor,
  	            othCtor = other.constructor;

  	        // Non `Object` object instances with different constructors are not equal.
  	        if (objCtor != othCtor &&
  	            ('constructor' in object && 'constructor' in other) &&
  	            !(typeof objCtor == 'function' && objCtor instanceof objCtor &&
  	              typeof othCtor == 'function' && othCtor instanceof othCtor)) {
  	          result = false;
  	        }
  	      }
  	      stack['delete'](object);
  	      stack['delete'](other);
  	      return result;
  	    }

  	    /**
  	     * A specialized version of `baseRest` which flattens the rest array.
  	     *
  	     * @private
  	     * @param {Function} func The function to apply a rest parameter to.
  	     * @returns {Function} Returns the new function.
  	     */
  	    function flatRest(func) {
  	      return setToString(overRest(func, undefined$1, flatten), func + '');
  	    }

  	    /**
  	     * Creates an array of own enumerable property names and symbols of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names and symbols.
  	     */
  	    function getAllKeys(object) {
  	      return baseGetAllKeys(object, keys, getSymbols);
  	    }

  	    /**
  	     * Creates an array of own and inherited enumerable property names and
  	     * symbols of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names and symbols.
  	     */
  	    function getAllKeysIn(object) {
  	      return baseGetAllKeys(object, keysIn, getSymbolsIn);
  	    }

  	    /**
  	     * Gets metadata for `func`.
  	     *
  	     * @private
  	     * @param {Function} func The function to query.
  	     * @returns {*} Returns the metadata for `func`.
  	     */
  	    var getData = !metaMap ? noop : function(func) {
  	      return metaMap.get(func);
  	    };

  	    /**
  	     * Gets the name of `func`.
  	     *
  	     * @private
  	     * @param {Function} func The function to query.
  	     * @returns {string} Returns the function name.
  	     */
  	    function getFuncName(func) {
  	      var result = (func.name + ''),
  	          array = realNames[result],
  	          length = hasOwnProperty.call(realNames, result) ? array.length : 0;

  	      while (length--) {
  	        var data = array[length],
  	            otherFunc = data.func;
  	        if (otherFunc == null || otherFunc == func) {
  	          return data.name;
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * Gets the argument placeholder value for `func`.
  	     *
  	     * @private
  	     * @param {Function} func The function to inspect.
  	     * @returns {*} Returns the placeholder value.
  	     */
  	    function getHolder(func) {
  	      var object = hasOwnProperty.call(lodash, 'placeholder') ? lodash : func;
  	      return object.placeholder;
  	    }

  	    /**
  	     * Gets the appropriate "iteratee" function. If `_.iteratee` is customized,
  	     * this function returns the custom method, otherwise it returns `baseIteratee`.
  	     * If arguments are provided, the chosen function is invoked with them and
  	     * its result is returned.
  	     *
  	     * @private
  	     * @param {*} [value] The value to convert to an iteratee.
  	     * @param {number} [arity] The arity of the created iteratee.
  	     * @returns {Function} Returns the chosen function or its result.
  	     */
  	    function getIteratee() {
  	      var result = lodash.iteratee || iteratee;
  	      result = result === iteratee ? baseIteratee : result;
  	      return arguments.length ? result(arguments[0], arguments[1]) : result;
  	    }

  	    /**
  	     * Gets the data for `map`.
  	     *
  	     * @private
  	     * @param {Object} map The map to query.
  	     * @param {string} key The reference key.
  	     * @returns {*} Returns the map data.
  	     */
  	    function getMapData(map, key) {
  	      var data = map.__data__;
  	      return isKeyable(key)
  	        ? data[typeof key == 'string' ? 'string' : 'hash']
  	        : data.map;
  	    }

  	    /**
  	     * Gets the property names, values, and compare flags of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the match data of `object`.
  	     */
  	    function getMatchData(object) {
  	      var result = keys(object),
  	          length = result.length;

  	      while (length--) {
  	        var key = result[length],
  	            value = object[key];

  	        result[length] = [key, value, isStrictComparable(value)];
  	      }
  	      return result;
  	    }

  	    /**
  	     * Gets the native function at `key` of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {string} key The key of the method to get.
  	     * @returns {*} Returns the function if it's native, else `undefined`.
  	     */
  	    function getNative(object, key) {
  	      var value = getValue(object, key);
  	      return baseIsNative(value) ? value : undefined$1;
  	    }

  	    /**
  	     * A specialized version of `baseGetTag` which ignores `Symbol.toStringTag` values.
  	     *
  	     * @private
  	     * @param {*} value The value to query.
  	     * @returns {string} Returns the raw `toStringTag`.
  	     */
  	    function getRawTag(value) {
  	      var isOwn = hasOwnProperty.call(value, symToStringTag),
  	          tag = value[symToStringTag];

  	      try {
  	        value[symToStringTag] = undefined$1;
  	        var unmasked = true;
  	      } catch (e) {}

  	      var result = nativeObjectToString.call(value);
  	      if (unmasked) {
  	        if (isOwn) {
  	          value[symToStringTag] = tag;
  	        } else {
  	          delete value[symToStringTag];
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * Creates an array of the own enumerable symbols of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of symbols.
  	     */
  	    var getSymbols = !nativeGetSymbols ? stubArray : function(object) {
  	      if (object == null) {
  	        return [];
  	      }
  	      object = Object(object);
  	      return arrayFilter(nativeGetSymbols(object), function(symbol) {
  	        return propertyIsEnumerable.call(object, symbol);
  	      });
  	    };

  	    /**
  	     * Creates an array of the own and inherited enumerable symbols of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of symbols.
  	     */
  	    var getSymbolsIn = !nativeGetSymbols ? stubArray : function(object) {
  	      var result = [];
  	      while (object) {
  	        arrayPush(result, getSymbols(object));
  	        object = getPrototype(object);
  	      }
  	      return result;
  	    };

  	    /**
  	     * Gets the `toStringTag` of `value`.
  	     *
  	     * @private
  	     * @param {*} value The value to query.
  	     * @returns {string} Returns the `toStringTag`.
  	     */
  	    var getTag = baseGetTag;

  	    // Fallback for data views, maps, sets, and weak maps in IE 11 and promises in Node.js < 6.
  	    if ((DataView && getTag(new DataView(new ArrayBuffer(1))) != dataViewTag) ||
  	        (Map && getTag(new Map) != mapTag) ||
  	        (Promise && getTag(Promise.resolve()) != promiseTag) ||
  	        (Set && getTag(new Set) != setTag) ||
  	        (WeakMap && getTag(new WeakMap) != weakMapTag)) {
  	      getTag = function(value) {
  	        var result = baseGetTag(value),
  	            Ctor = result == objectTag ? value.constructor : undefined$1,
  	            ctorString = Ctor ? toSource(Ctor) : '';

  	        if (ctorString) {
  	          switch (ctorString) {
  	            case dataViewCtorString: return dataViewTag;
  	            case mapCtorString: return mapTag;
  	            case promiseCtorString: return promiseTag;
  	            case setCtorString: return setTag;
  	            case weakMapCtorString: return weakMapTag;
  	          }
  	        }
  	        return result;
  	      };
  	    }

  	    /**
  	     * Gets the view, applying any `transforms` to the `start` and `end` positions.
  	     *
  	     * @private
  	     * @param {number} start The start of the view.
  	     * @param {number} end The end of the view.
  	     * @param {Array} transforms The transformations to apply to the view.
  	     * @returns {Object} Returns an object containing the `start` and `end`
  	     *  positions of the view.
  	     */
  	    function getView(start, end, transforms) {
  	      var index = -1,
  	          length = transforms.length;

  	      while (++index < length) {
  	        var data = transforms[index],
  	            size = data.size;

  	        switch (data.type) {
  	          case 'drop':      start += size; break;
  	          case 'dropRight': end -= size; break;
  	          case 'take':      end = nativeMin(end, start + size); break;
  	          case 'takeRight': start = nativeMax(start, end - size); break;
  	        }
  	      }
  	      return { 'start': start, 'end': end };
  	    }

  	    /**
  	     * Extracts wrapper details from the `source` body comment.
  	     *
  	     * @private
  	     * @param {string} source The source to inspect.
  	     * @returns {Array} Returns the wrapper details.
  	     */
  	    function getWrapDetails(source) {
  	      var match = source.match(reWrapDetails);
  	      return match ? match[1].split(reSplitDetails) : [];
  	    }

  	    /**
  	     * Checks if `path` exists on `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path to check.
  	     * @param {Function} hasFunc The function to check properties.
  	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
  	     */
  	    function hasPath(object, path, hasFunc) {
  	      path = castPath(path, object);

  	      var index = -1,
  	          length = path.length,
  	          result = false;

  	      while (++index < length) {
  	        var key = toKey(path[index]);
  	        if (!(result = object != null && hasFunc(object, key))) {
  	          break;
  	        }
  	        object = object[key];
  	      }
  	      if (result || ++index != length) {
  	        return result;
  	      }
  	      length = object == null ? 0 : object.length;
  	      return !!length && isLength(length) && isIndex(key, length) &&
  	        (isArray(object) || isArguments(object));
  	    }

  	    /**
  	     * Initializes an array clone.
  	     *
  	     * @private
  	     * @param {Array} array The array to clone.
  	     * @returns {Array} Returns the initialized clone.
  	     */
  	    function initCloneArray(array) {
  	      var length = array.length,
  	          result = new array.constructor(length);

  	      // Add properties assigned by `RegExp#exec`.
  	      if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
  	        result.index = array.index;
  	        result.input = array.input;
  	      }
  	      return result;
  	    }

  	    /**
  	     * Initializes an object clone.
  	     *
  	     * @private
  	     * @param {Object} object The object to clone.
  	     * @returns {Object} Returns the initialized clone.
  	     */
  	    function initCloneObject(object) {
  	      return (typeof object.constructor == 'function' && !isPrototype(object))
  	        ? baseCreate(getPrototype(object))
  	        : {};
  	    }

  	    /**
  	     * Initializes an object clone based on its `toStringTag`.
  	     *
  	     * **Note:** This function only supports cloning values with tags of
  	     * `Boolean`, `Date`, `Error`, `Map`, `Number`, `RegExp`, `Set`, or `String`.
  	     *
  	     * @private
  	     * @param {Object} object The object to clone.
  	     * @param {string} tag The `toStringTag` of the object to clone.
  	     * @param {boolean} [isDeep] Specify a deep clone.
  	     * @returns {Object} Returns the initialized clone.
  	     */
  	    function initCloneByTag(object, tag, isDeep) {
  	      var Ctor = object.constructor;
  	      switch (tag) {
  	        case arrayBufferTag:
  	          return cloneArrayBuffer(object);

  	        case boolTag:
  	        case dateTag:
  	          return new Ctor(+object);

  	        case dataViewTag:
  	          return cloneDataView(object, isDeep);

  	        case float32Tag: case float64Tag:
  	        case int8Tag: case int16Tag: case int32Tag:
  	        case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
  	          return cloneTypedArray(object, isDeep);

  	        case mapTag:
  	          return new Ctor;

  	        case numberTag:
  	        case stringTag:
  	          return new Ctor(object);

  	        case regexpTag:
  	          return cloneRegExp(object);

  	        case setTag:
  	          return new Ctor;

  	        case symbolTag:
  	          return cloneSymbol(object);
  	      }
  	    }

  	    /**
  	     * Inserts wrapper `details` in a comment at the top of the `source` body.
  	     *
  	     * @private
  	     * @param {string} source The source to modify.
  	     * @returns {Array} details The details to insert.
  	     * @returns {string} Returns the modified source.
  	     */
  	    function insertWrapDetails(source, details) {
  	      var length = details.length;
  	      if (!length) {
  	        return source;
  	      }
  	      var lastIndex = length - 1;
  	      details[lastIndex] = (length > 1 ? '& ' : '') + details[lastIndex];
  	      details = details.join(length > 2 ? ', ' : ' ');
  	      return source.replace(reWrapComment, '{\n/* [wrapped with ' + details + '] */\n');
  	    }

  	    /**
  	     * Checks if `value` is a flattenable `arguments` object or array.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is flattenable, else `false`.
  	     */
  	    function isFlattenable(value) {
  	      return isArray(value) || isArguments(value) ||
  	        !!(spreadableSymbol && value && value[spreadableSymbol]);
  	    }

  	    /**
  	     * Checks if `value` is a valid array-like index.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
  	     * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
  	     */
  	    function isIndex(value, length) {
  	      var type = typeof value;
  	      length = length == null ? MAX_SAFE_INTEGER : length;

  	      return !!length &&
  	        (type == 'number' ||
  	          (type != 'symbol' && reIsUint.test(value))) &&
  	            (value > -1 && value % 1 == 0 && value < length);
  	    }

  	    /**
  	     * Checks if the given arguments are from an iteratee call.
  	     *
  	     * @private
  	     * @param {*} value The potential iteratee value argument.
  	     * @param {*} index The potential iteratee index or key argument.
  	     * @param {*} object The potential iteratee object argument.
  	     * @returns {boolean} Returns `true` if the arguments are from an iteratee call,
  	     *  else `false`.
  	     */
  	    function isIterateeCall(value, index, object) {
  	      if (!isObject(object)) {
  	        return false;
  	      }
  	      var type = typeof index;
  	      if (type == 'number'
  	            ? (isArrayLike(object) && isIndex(index, object.length))
  	            : (type == 'string' && index in object)
  	          ) {
  	        return eq(object[index], value);
  	      }
  	      return false;
  	    }

  	    /**
  	     * Checks if `value` is a property name and not a property path.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @param {Object} [object] The object to query keys on.
  	     * @returns {boolean} Returns `true` if `value` is a property name, else `false`.
  	     */
  	    function isKey(value, object) {
  	      if (isArray(value)) {
  	        return false;
  	      }
  	      var type = typeof value;
  	      if (type == 'number' || type == 'symbol' || type == 'boolean' ||
  	          value == null || isSymbol(value)) {
  	        return true;
  	      }
  	      return reIsPlainProp.test(value) || !reIsDeepProp.test(value) ||
  	        (object != null && value in Object(object));
  	    }

  	    /**
  	     * Checks if `value` is suitable for use as unique object key.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
  	     */
  	    function isKeyable(value) {
  	      var type = typeof value;
  	      return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
  	        ? (value !== '__proto__')
  	        : (value === null);
  	    }

  	    /**
  	     * Checks if `func` has a lazy counterpart.
  	     *
  	     * @private
  	     * @param {Function} func The function to check.
  	     * @returns {boolean} Returns `true` if `func` has a lazy counterpart,
  	     *  else `false`.
  	     */
  	    function isLaziable(func) {
  	      var funcName = getFuncName(func),
  	          other = lodash[funcName];

  	      if (typeof other != 'function' || !(funcName in LazyWrapper.prototype)) {
  	        return false;
  	      }
  	      if (func === other) {
  	        return true;
  	      }
  	      var data = getData(other);
  	      return !!data && func === data[0];
  	    }

  	    /**
  	     * Checks if `func` has its source masked.
  	     *
  	     * @private
  	     * @param {Function} func The function to check.
  	     * @returns {boolean} Returns `true` if `func` is masked, else `false`.
  	     */
  	    function isMasked(func) {
  	      return !!maskSrcKey && (maskSrcKey in func);
  	    }

  	    /**
  	     * Checks if `func` is capable of being masked.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `func` is maskable, else `false`.
  	     */
  	    var isMaskable = coreJsData ? isFunction : stubFalse;

  	    /**
  	     * Checks if `value` is likely a prototype object.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
  	     */
  	    function isPrototype(value) {
  	      var Ctor = value && value.constructor,
  	          proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

  	      return value === proto;
  	    }

  	    /**
  	     * Checks if `value` is suitable for strict equality comparisons, i.e. `===`.
  	     *
  	     * @private
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` if suitable for strict
  	     *  equality comparisons, else `false`.
  	     */
  	    function isStrictComparable(value) {
  	      return value === value && !isObject(value);
  	    }

  	    /**
  	     * A specialized version of `matchesProperty` for source values suitable
  	     * for strict equality comparisons, i.e. `===`.
  	     *
  	     * @private
  	     * @param {string} key The key of the property to get.
  	     * @param {*} srcValue The value to match.
  	     * @returns {Function} Returns the new spec function.
  	     */
  	    function matchesStrictComparable(key, srcValue) {
  	      return function(object) {
  	        if (object == null) {
  	          return false;
  	        }
  	        return object[key] === srcValue &&
  	          (srcValue !== undefined$1 || (key in Object(object)));
  	      };
  	    }

  	    /**
  	     * A specialized version of `_.memoize` which clears the memoized function's
  	     * cache when it exceeds `MAX_MEMOIZE_SIZE`.
  	     *
  	     * @private
  	     * @param {Function} func The function to have its output memoized.
  	     * @returns {Function} Returns the new memoized function.
  	     */
  	    function memoizeCapped(func) {
  	      var result = memoize(func, function(key) {
  	        if (cache.size === MAX_MEMOIZE_SIZE) {
  	          cache.clear();
  	        }
  	        return key;
  	      });

  	      var cache = result.cache;
  	      return result;
  	    }

  	    /**
  	     * Merges the function metadata of `source` into `data`.
  	     *
  	     * Merging metadata reduces the number of wrappers used to invoke a function.
  	     * This is possible because methods like `_.bind`, `_.curry`, and `_.partial`
  	     * may be applied regardless of execution order. Methods like `_.ary` and
  	     * `_.rearg` modify function arguments, making the order in which they are
  	     * executed important, preventing the merging of metadata. However, we make
  	     * an exception for a safe combined case where curried functions have `_.ary`
  	     * and or `_.rearg` applied.
  	     *
  	     * @private
  	     * @param {Array} data The destination metadata.
  	     * @param {Array} source The source metadata.
  	     * @returns {Array} Returns `data`.
  	     */
  	    function mergeData(data, source) {
  	      var bitmask = data[1],
  	          srcBitmask = source[1],
  	          newBitmask = bitmask | srcBitmask,
  	          isCommon = newBitmask < (WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG | WRAP_ARY_FLAG);

  	      var isCombo =
  	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_CURRY_FLAG)) ||
  	        ((srcBitmask == WRAP_ARY_FLAG) && (bitmask == WRAP_REARG_FLAG) && (data[7].length <= source[8])) ||
  	        ((srcBitmask == (WRAP_ARY_FLAG | WRAP_REARG_FLAG)) && (source[7].length <= source[8]) && (bitmask == WRAP_CURRY_FLAG));

  	      // Exit early if metadata can't be merged.
  	      if (!(isCommon || isCombo)) {
  	        return data;
  	      }
  	      // Use source `thisArg` if available.
  	      if (srcBitmask & WRAP_BIND_FLAG) {
  	        data[2] = source[2];
  	        // Set when currying a bound function.
  	        newBitmask |= bitmask & WRAP_BIND_FLAG ? 0 : WRAP_CURRY_BOUND_FLAG;
  	      }
  	      // Compose partial arguments.
  	      var value = source[3];
  	      if (value) {
  	        var partials = data[3];
  	        data[3] = partials ? composeArgs(partials, value, source[4]) : value;
  	        data[4] = partials ? replaceHolders(data[3], PLACEHOLDER) : source[4];
  	      }
  	      // Compose partial right arguments.
  	      value = source[5];
  	      if (value) {
  	        partials = data[5];
  	        data[5] = partials ? composeArgsRight(partials, value, source[6]) : value;
  	        data[6] = partials ? replaceHolders(data[5], PLACEHOLDER) : source[6];
  	      }
  	      // Use source `argPos` if available.
  	      value = source[7];
  	      if (value) {
  	        data[7] = value;
  	      }
  	      // Use source `ary` if it's smaller.
  	      if (srcBitmask & WRAP_ARY_FLAG) {
  	        data[8] = data[8] == null ? source[8] : nativeMin(data[8], source[8]);
  	      }
  	      // Use source `arity` if one is not provided.
  	      if (data[9] == null) {
  	        data[9] = source[9];
  	      }
  	      // Use source `func` and merge bitmasks.
  	      data[0] = source[0];
  	      data[1] = newBitmask;

  	      return data;
  	    }

  	    /**
  	     * This function is like
  	     * [`Object.keys`](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
  	     * except that it includes inherited enumerable properties.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names.
  	     */
  	    function nativeKeysIn(object) {
  	      var result = [];
  	      if (object != null) {
  	        for (var key in Object(object)) {
  	          result.push(key);
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * Converts `value` to a string using `Object.prototype.toString`.
  	     *
  	     * @private
  	     * @param {*} value The value to convert.
  	     * @returns {string} Returns the converted string.
  	     */
  	    function objectToString(value) {
  	      return nativeObjectToString.call(value);
  	    }

  	    /**
  	     * A specialized version of `baseRest` which transforms the rest array.
  	     *
  	     * @private
  	     * @param {Function} func The function to apply a rest parameter to.
  	     * @param {number} [start=func.length-1] The start position of the rest parameter.
  	     * @param {Function} transform The rest array transform.
  	     * @returns {Function} Returns the new function.
  	     */
  	    function overRest(func, start, transform) {
  	      start = nativeMax(start === undefined$1 ? (func.length - 1) : start, 0);
  	      return function() {
  	        var args = arguments,
  	            index = -1,
  	            length = nativeMax(args.length - start, 0),
  	            array = Array(length);

  	        while (++index < length) {
  	          array[index] = args[start + index];
  	        }
  	        index = -1;
  	        var otherArgs = Array(start + 1);
  	        while (++index < start) {
  	          otherArgs[index] = args[index];
  	        }
  	        otherArgs[start] = transform(array);
  	        return apply(func, this, otherArgs);
  	      };
  	    }

  	    /**
  	     * Gets the parent value at `path` of `object`.
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {Array} path The path to get the parent value of.
  	     * @returns {*} Returns the parent value.
  	     */
  	    function parent(object, path) {
  	      return path.length < 2 ? object : baseGet(object, baseSlice(path, 0, -1));
  	    }

  	    /**
  	     * Reorder `array` according to the specified indexes where the element at
  	     * the first index is assigned as the first element, the element at
  	     * the second index is assigned as the second element, and so on.
  	     *
  	     * @private
  	     * @param {Array} array The array to reorder.
  	     * @param {Array} indexes The arranged array indexes.
  	     * @returns {Array} Returns `array`.
  	     */
  	    function reorder(array, indexes) {
  	      var arrLength = array.length,
  	          length = nativeMin(indexes.length, arrLength),
  	          oldArray = copyArray(array);

  	      while (length--) {
  	        var index = indexes[length];
  	        array[length] = isIndex(index, arrLength) ? oldArray[index] : undefined$1;
  	      }
  	      return array;
  	    }

  	    /**
  	     * Gets the value at `key`, unless `key` is "__proto__" or "constructor".
  	     *
  	     * @private
  	     * @param {Object} object The object to query.
  	     * @param {string} key The key of the property to get.
  	     * @returns {*} Returns the property value.
  	     */
  	    function safeGet(object, key) {
  	      if (key === 'constructor' && typeof object[key] === 'function') {
  	        return;
  	      }

  	      if (key == '__proto__') {
  	        return;
  	      }

  	      return object[key];
  	    }

  	    /**
  	     * Sets metadata for `func`.
  	     *
  	     * **Note:** If this function becomes hot, i.e. is invoked a lot in a short
  	     * period of time, it will trip its breaker and transition to an identity
  	     * function to avoid garbage collection pauses in V8. See
  	     * [V8 issue 2070](https://bugs.chromium.org/p/v8/issues/detail?id=2070)
  	     * for more details.
  	     *
  	     * @private
  	     * @param {Function} func The function to associate metadata with.
  	     * @param {*} data The metadata.
  	     * @returns {Function} Returns `func`.
  	     */
  	    var setData = shortOut(baseSetData);

  	    /**
  	     * A simple wrapper around the global [`setTimeout`](https://mdn.io/setTimeout).
  	     *
  	     * @private
  	     * @param {Function} func The function to delay.
  	     * @param {number} wait The number of milliseconds to delay invocation.
  	     * @returns {number|Object} Returns the timer id or timeout object.
  	     */
  	    var setTimeout = ctxSetTimeout || function(func, wait) {
  	      return root.setTimeout(func, wait);
  	    };

  	    /**
  	     * Sets the `toString` method of `func` to return `string`.
  	     *
  	     * @private
  	     * @param {Function} func The function to modify.
  	     * @param {Function} string The `toString` result.
  	     * @returns {Function} Returns `func`.
  	     */
  	    var setToString = shortOut(baseSetToString);

  	    /**
  	     * Sets the `toString` method of `wrapper` to mimic the source of `reference`
  	     * with wrapper details in a comment at the top of the source body.
  	     *
  	     * @private
  	     * @param {Function} wrapper The function to modify.
  	     * @param {Function} reference The reference function.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @returns {Function} Returns `wrapper`.
  	     */
  	    function setWrapToString(wrapper, reference, bitmask) {
  	      var source = (reference + '');
  	      return setToString(wrapper, insertWrapDetails(source, updateWrapDetails(getWrapDetails(source), bitmask)));
  	    }

  	    /**
  	     * Creates a function that'll short out and invoke `identity` instead
  	     * of `func` when it's called `HOT_COUNT` or more times in `HOT_SPAN`
  	     * milliseconds.
  	     *
  	     * @private
  	     * @param {Function} func The function to restrict.
  	     * @returns {Function} Returns the new shortable function.
  	     */
  	    function shortOut(func) {
  	      var count = 0,
  	          lastCalled = 0;

  	      return function() {
  	        var stamp = nativeNow(),
  	            remaining = HOT_SPAN - (stamp - lastCalled);

  	        lastCalled = stamp;
  	        if (remaining > 0) {
  	          if (++count >= HOT_COUNT) {
  	            return arguments[0];
  	          }
  	        } else {
  	          count = 0;
  	        }
  	        return func.apply(undefined$1, arguments);
  	      };
  	    }

  	    /**
  	     * A specialized version of `_.shuffle` which mutates and sets the size of `array`.
  	     *
  	     * @private
  	     * @param {Array} array The array to shuffle.
  	     * @param {number} [size=array.length] The size of `array`.
  	     * @returns {Array} Returns `array`.
  	     */
  	    function shuffleSelf(array, size) {
  	      var index = -1,
  	          length = array.length,
  	          lastIndex = length - 1;

  	      size = size === undefined$1 ? length : size;
  	      while (++index < size) {
  	        var rand = baseRandom(index, lastIndex),
  	            value = array[rand];

  	        array[rand] = array[index];
  	        array[index] = value;
  	      }
  	      array.length = size;
  	      return array;
  	    }

  	    /**
  	     * Converts `string` to a property path array.
  	     *
  	     * @private
  	     * @param {string} string The string to convert.
  	     * @returns {Array} Returns the property path array.
  	     */
  	    var stringToPath = memoizeCapped(function(string) {
  	      var result = [];
  	      if (string.charCodeAt(0) === 46 /* . */) {
  	        result.push('');
  	      }
  	      string.replace(rePropName, function(match, number, quote, subString) {
  	        result.push(quote ? subString.replace(reEscapeChar, '$1') : (number || match));
  	      });
  	      return result;
  	    });

  	    /**
  	     * Converts `value` to a string key if it's not a string or symbol.
  	     *
  	     * @private
  	     * @param {*} value The value to inspect.
  	     * @returns {string|symbol} Returns the key.
  	     */
  	    function toKey(value) {
  	      if (typeof value == 'string' || isSymbol(value)) {
  	        return value;
  	      }
  	      var result = (value + '');
  	      return (result == '0' && (1 / value) == -INFINITY) ? '-0' : result;
  	    }

  	    /**
  	     * Converts `func` to its source code.
  	     *
  	     * @private
  	     * @param {Function} func The function to convert.
  	     * @returns {string} Returns the source code.
  	     */
  	    function toSource(func) {
  	      if (func != null) {
  	        try {
  	          return funcToString.call(func);
  	        } catch (e) {}
  	        try {
  	          return (func + '');
  	        } catch (e) {}
  	      }
  	      return '';
  	    }

  	    /**
  	     * Updates wrapper `details` based on `bitmask` flags.
  	     *
  	     * @private
  	     * @returns {Array} details The details to modify.
  	     * @param {number} bitmask The bitmask flags. See `createWrap` for more details.
  	     * @returns {Array} Returns `details`.
  	     */
  	    function updateWrapDetails(details, bitmask) {
  	      arrayEach(wrapFlags, function(pair) {
  	        var value = '_.' + pair[0];
  	        if ((bitmask & pair[1]) && !arrayIncludes(details, value)) {
  	          details.push(value);
  	        }
  	      });
  	      return details.sort();
  	    }

  	    /**
  	     * Creates a clone of `wrapper`.
  	     *
  	     * @private
  	     * @param {Object} wrapper The wrapper to clone.
  	     * @returns {Object} Returns the cloned wrapper.
  	     */
  	    function wrapperClone(wrapper) {
  	      if (wrapper instanceof LazyWrapper) {
  	        return wrapper.clone();
  	      }
  	      var result = new LodashWrapper(wrapper.__wrapped__, wrapper.__chain__);
  	      result.__actions__ = copyArray(wrapper.__actions__);
  	      result.__index__  = wrapper.__index__;
  	      result.__values__ = wrapper.__values__;
  	      return result;
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates an array of elements split into groups the length of `size`.
  	     * If `array` can't be split evenly, the final chunk will be the remaining
  	     * elements.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to process.
  	     * @param {number} [size=1] The length of each chunk
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the new array of chunks.
  	     * @example
  	     *
  	     * _.chunk(['a', 'b', 'c', 'd'], 2);
  	     * // => [['a', 'b'], ['c', 'd']]
  	     *
  	     * _.chunk(['a', 'b', 'c', 'd'], 3);
  	     * // => [['a', 'b', 'c'], ['d']]
  	     */
  	    function chunk(array, size, guard) {
  	      if ((guard ? isIterateeCall(array, size, guard) : size === undefined$1)) {
  	        size = 1;
  	      } else {
  	        size = nativeMax(toInteger(size), 0);
  	      }
  	      var length = array == null ? 0 : array.length;
  	      if (!length || size < 1) {
  	        return [];
  	      }
  	      var index = 0,
  	          resIndex = 0,
  	          result = Array(nativeCeil(length / size));

  	      while (index < length) {
  	        result[resIndex++] = baseSlice(array, index, (index += size));
  	      }
  	      return result;
  	    }

  	    /**
  	     * Creates an array with all falsey values removed. The values `false`, `null`,
  	     * `0`, `""`, `undefined`, and `NaN` are falsey.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to compact.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @example
  	     *
  	     * _.compact([0, 1, false, 2, '', 3]);
  	     * // => [1, 2, 3]
  	     */
  	    function compact(array) {
  	      var index = -1,
  	          length = array == null ? 0 : array.length,
  	          resIndex = 0,
  	          result = [];

  	      while (++index < length) {
  	        var value = array[index];
  	        if (value) {
  	          result[resIndex++] = value;
  	        }
  	      }
  	      return result;
  	    }

  	    /**
  	     * Creates a new array concatenating `array` with any additional arrays
  	     * and/or values.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to concatenate.
  	     * @param {...*} [values] The values to concatenate.
  	     * @returns {Array} Returns the new concatenated array.
  	     * @example
  	     *
  	     * var array = [1];
  	     * var other = _.concat(array, 2, [3], [[4]]);
  	     *
  	     * console.log(other);
  	     * // => [1, 2, 3, [4]]
  	     *
  	     * console.log(array);
  	     * // => [1]
  	     */
  	    function concat() {
  	      var length = arguments.length;
  	      if (!length) {
  	        return [];
  	      }
  	      var args = Array(length - 1),
  	          array = arguments[0],
  	          index = length;

  	      while (index--) {
  	        args[index - 1] = arguments[index];
  	      }
  	      return arrayPush(isArray(array) ? copyArray(array) : [array], baseFlatten(args, 1));
  	    }

  	    /**
  	     * Creates an array of `array` values not included in the other given arrays
  	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons. The order and references of result values are
  	     * determined by the first array.
  	     *
  	     * **Note:** Unlike `_.pullAll`, this method returns a new array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {...Array} [values] The values to exclude.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @see _.without, _.xor
  	     * @example
  	     *
  	     * _.difference([2, 1], [2, 3]);
  	     * // => [1]
  	     */
  	    var difference = baseRest(function(array, values) {
  	      return isArrayLikeObject(array)
  	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true))
  	        : [];
  	    });

  	    /**
  	     * This method is like `_.difference` except that it accepts `iteratee` which
  	     * is invoked for each element of `array` and `values` to generate the criterion
  	     * by which they're compared. The order and references of result values are
  	     * determined by the first array. The iteratee is invoked with one argument:
  	     * (value).
  	     *
  	     * **Note:** Unlike `_.pullAllBy`, this method returns a new array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {...Array} [values] The values to exclude.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @example
  	     *
  	     * _.differenceBy([2.1, 1.2], [2.3, 3.4], Math.floor);
  	     * // => [1.2]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.differenceBy([{ 'x': 2 }, { 'x': 1 }], [{ 'x': 1 }], 'x');
  	     * // => [{ 'x': 2 }]
  	     */
  	    var differenceBy = baseRest(function(array, values) {
  	      var iteratee = last(values);
  	      if (isArrayLikeObject(iteratee)) {
  	        iteratee = undefined$1;
  	      }
  	      return isArrayLikeObject(array)
  	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), getIteratee(iteratee, 2))
  	        : [];
  	    });

  	    /**
  	     * This method is like `_.difference` except that it accepts `comparator`
  	     * which is invoked to compare elements of `array` to `values`. The order and
  	     * references of result values are determined by the first array. The comparator
  	     * is invoked with two arguments: (arrVal, othVal).
  	     *
  	     * **Note:** Unlike `_.pullAllWith`, this method returns a new array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {...Array} [values] The values to exclude.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
  	     *
  	     * _.differenceWith(objects, [{ 'x': 1, 'y': 2 }], _.isEqual);
  	     * // => [{ 'x': 2, 'y': 1 }]
  	     */
  	    var differenceWith = baseRest(function(array, values) {
  	      var comparator = last(values);
  	      if (isArrayLikeObject(comparator)) {
  	        comparator = undefined$1;
  	      }
  	      return isArrayLikeObject(array)
  	        ? baseDifference(array, baseFlatten(values, 1, isArrayLikeObject, true), undefined$1, comparator)
  	        : [];
  	    });

  	    /**
  	     * Creates a slice of `array` with `n` elements dropped from the beginning.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.5.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {number} [n=1] The number of elements to drop.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * _.drop([1, 2, 3]);
  	     * // => [2, 3]
  	     *
  	     * _.drop([1, 2, 3], 2);
  	     * // => [3]
  	     *
  	     * _.drop([1, 2, 3], 5);
  	     * // => []
  	     *
  	     * _.drop([1, 2, 3], 0);
  	     * // => [1, 2, 3]
  	     */
  	    function drop(array, n, guard) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return [];
  	      }
  	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
  	      return baseSlice(array, n < 0 ? 0 : n, length);
  	    }

  	    /**
  	     * Creates a slice of `array` with `n` elements dropped from the end.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {number} [n=1] The number of elements to drop.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * _.dropRight([1, 2, 3]);
  	     * // => [1, 2]
  	     *
  	     * _.dropRight([1, 2, 3], 2);
  	     * // => [1]
  	     *
  	     * _.dropRight([1, 2, 3], 5);
  	     * // => []
  	     *
  	     * _.dropRight([1, 2, 3], 0);
  	     * // => [1, 2, 3]
  	     */
  	    function dropRight(array, n, guard) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return [];
  	      }
  	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
  	      n = length - n;
  	      return baseSlice(array, 0, n < 0 ? 0 : n);
  	    }

  	    /**
  	     * Creates a slice of `array` excluding elements dropped from the end.
  	     * Elements are dropped until `predicate` returns falsey. The predicate is
  	     * invoked with three arguments: (value, index, array).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'active': true },
  	     *   { 'user': 'fred',    'active': false },
  	     *   { 'user': 'pebbles', 'active': false }
  	     * ];
  	     *
  	     * _.dropRightWhile(users, function(o) { return !o.active; });
  	     * // => objects for ['barney']
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.dropRightWhile(users, { 'user': 'pebbles', 'active': false });
  	     * // => objects for ['barney', 'fred']
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.dropRightWhile(users, ['active', false]);
  	     * // => objects for ['barney']
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.dropRightWhile(users, 'active');
  	     * // => objects for ['barney', 'fred', 'pebbles']
  	     */
  	    function dropRightWhile(array, predicate) {
  	      return (array && array.length)
  	        ? baseWhile(array, getIteratee(predicate, 3), true, true)
  	        : [];
  	    }

  	    /**
  	     * Creates a slice of `array` excluding elements dropped from the beginning.
  	     * Elements are dropped until `predicate` returns falsey. The predicate is
  	     * invoked with three arguments: (value, index, array).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'active': false },
  	     *   { 'user': 'fred',    'active': false },
  	     *   { 'user': 'pebbles', 'active': true }
  	     * ];
  	     *
  	     * _.dropWhile(users, function(o) { return !o.active; });
  	     * // => objects for ['pebbles']
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.dropWhile(users, { 'user': 'barney', 'active': false });
  	     * // => objects for ['fred', 'pebbles']
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.dropWhile(users, ['active', false]);
  	     * // => objects for ['pebbles']
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.dropWhile(users, 'active');
  	     * // => objects for ['barney', 'fred', 'pebbles']
  	     */
  	    function dropWhile(array, predicate) {
  	      return (array && array.length)
  	        ? baseWhile(array, getIteratee(predicate, 3), true)
  	        : [];
  	    }

  	    /**
  	     * Fills elements of `array` with `value` from `start` up to, but not
  	     * including, `end`.
  	     *
  	     * **Note:** This method mutates `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.2.0
  	     * @category Array
  	     * @param {Array} array The array to fill.
  	     * @param {*} value The value to fill `array` with.
  	     * @param {number} [start=0] The start position.
  	     * @param {number} [end=array.length] The end position.
  	     * @returns {Array} Returns `array`.
  	     * @example
  	     *
  	     * var array = [1, 2, 3];
  	     *
  	     * _.fill(array, 'a');
  	     * console.log(array);
  	     * // => ['a', 'a', 'a']
  	     *
  	     * _.fill(Array(3), 2);
  	     * // => [2, 2, 2]
  	     *
  	     * _.fill([4, 6, 8, 10], '*', 1, 3);
  	     * // => [4, '*', '*', 10]
  	     */
  	    function fill(array, value, start, end) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return [];
  	      }
  	      if (start && typeof start != 'number' && isIterateeCall(array, value, start)) {
  	        start = 0;
  	        end = length;
  	      }
  	      return baseFill(array, value, start, end);
  	    }

  	    /**
  	     * This method is like `_.find` except that it returns the index of the first
  	     * element `predicate` returns truthy for instead of the element itself.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.1.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @param {number} [fromIndex=0] The index to search from.
  	     * @returns {number} Returns the index of the found element, else `-1`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'active': false },
  	     *   { 'user': 'fred',    'active': false },
  	     *   { 'user': 'pebbles', 'active': true }
  	     * ];
  	     *
  	     * _.findIndex(users, function(o) { return o.user == 'barney'; });
  	     * // => 0
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.findIndex(users, { 'user': 'fred', 'active': false });
  	     * // => 1
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.findIndex(users, ['active', false]);
  	     * // => 0
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.findIndex(users, 'active');
  	     * // => 2
  	     */
  	    function findIndex(array, predicate, fromIndex) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return -1;
  	      }
  	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
  	      if (index < 0) {
  	        index = nativeMax(length + index, 0);
  	      }
  	      return baseFindIndex(array, getIteratee(predicate, 3), index);
  	    }

  	    /**
  	     * This method is like `_.findIndex` except that it iterates over elements
  	     * of `collection` from right to left.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @param {number} [fromIndex=array.length-1] The index to search from.
  	     * @returns {number} Returns the index of the found element, else `-1`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'active': true },
  	     *   { 'user': 'fred',    'active': false },
  	     *   { 'user': 'pebbles', 'active': false }
  	     * ];
  	     *
  	     * _.findLastIndex(users, function(o) { return o.user == 'pebbles'; });
  	     * // => 2
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.findLastIndex(users, { 'user': 'barney', 'active': true });
  	     * // => 0
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.findLastIndex(users, ['active', false]);
  	     * // => 2
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.findLastIndex(users, 'active');
  	     * // => 0
  	     */
  	    function findLastIndex(array, predicate, fromIndex) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return -1;
  	      }
  	      var index = length - 1;
  	      if (fromIndex !== undefined$1) {
  	        index = toInteger(fromIndex);
  	        index = fromIndex < 0
  	          ? nativeMax(length + index, 0)
  	          : nativeMin(index, length - 1);
  	      }
  	      return baseFindIndex(array, getIteratee(predicate, 3), index, true);
  	    }

  	    /**
  	     * Flattens `array` a single level deep.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to flatten.
  	     * @returns {Array} Returns the new flattened array.
  	     * @example
  	     *
  	     * _.flatten([1, [2, [3, [4]], 5]]);
  	     * // => [1, 2, [3, [4]], 5]
  	     */
  	    function flatten(array) {
  	      var length = array == null ? 0 : array.length;
  	      return length ? baseFlatten(array, 1) : [];
  	    }

  	    /**
  	     * Recursively flattens `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to flatten.
  	     * @returns {Array} Returns the new flattened array.
  	     * @example
  	     *
  	     * _.flattenDeep([1, [2, [3, [4]], 5]]);
  	     * // => [1, 2, 3, 4, 5]
  	     */
  	    function flattenDeep(array) {
  	      var length = array == null ? 0 : array.length;
  	      return length ? baseFlatten(array, INFINITY) : [];
  	    }

  	    /**
  	     * Recursively flatten `array` up to `depth` times.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.4.0
  	     * @category Array
  	     * @param {Array} array The array to flatten.
  	     * @param {number} [depth=1] The maximum recursion depth.
  	     * @returns {Array} Returns the new flattened array.
  	     * @example
  	     *
  	     * var array = [1, [2, [3, [4]], 5]];
  	     *
  	     * _.flattenDepth(array, 1);
  	     * // => [1, 2, [3, [4]], 5]
  	     *
  	     * _.flattenDepth(array, 2);
  	     * // => [1, 2, 3, [4], 5]
  	     */
  	    function flattenDepth(array, depth) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return [];
  	      }
  	      depth = depth === undefined$1 ? 1 : toInteger(depth);
  	      return baseFlatten(array, depth);
  	    }

  	    /**
  	     * The inverse of `_.toPairs`; this method returns an object composed
  	     * from key-value `pairs`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} pairs The key-value pairs.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * _.fromPairs([['a', 1], ['b', 2]]);
  	     * // => { 'a': 1, 'b': 2 }
  	     */
  	    function fromPairs(pairs) {
  	      var index = -1,
  	          length = pairs == null ? 0 : pairs.length,
  	          result = {};

  	      while (++index < length) {
  	        var pair = pairs[index];
  	        result[pair[0]] = pair[1];
  	      }
  	      return result;
  	    }

  	    /**
  	     * Gets the first element of `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @alias first
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @returns {*} Returns the first element of `array`.
  	     * @example
  	     *
  	     * _.head([1, 2, 3]);
  	     * // => 1
  	     *
  	     * _.head([]);
  	     * // => undefined
  	     */
  	    function head(array) {
  	      return (array && array.length) ? array[0] : undefined$1;
  	    }

  	    /**
  	     * Gets the index at which the first occurrence of `value` is found in `array`
  	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons. If `fromIndex` is negative, it's used as the
  	     * offset from the end of `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {*} value The value to search for.
  	     * @param {number} [fromIndex=0] The index to search from.
  	     * @returns {number} Returns the index of the matched value, else `-1`.
  	     * @example
  	     *
  	     * _.indexOf([1, 2, 1, 2], 2);
  	     * // => 1
  	     *
  	     * // Search from the `fromIndex`.
  	     * _.indexOf([1, 2, 1, 2], 2, 2);
  	     * // => 3
  	     */
  	    function indexOf(array, value, fromIndex) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return -1;
  	      }
  	      var index = fromIndex == null ? 0 : toInteger(fromIndex);
  	      if (index < 0) {
  	        index = nativeMax(length + index, 0);
  	      }
  	      return baseIndexOf(array, value, index);
  	    }

  	    /**
  	     * Gets all but the last element of `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * _.initial([1, 2, 3]);
  	     * // => [1, 2]
  	     */
  	    function initial(array) {
  	      var length = array == null ? 0 : array.length;
  	      return length ? baseSlice(array, 0, -1) : [];
  	    }

  	    /**
  	     * Creates an array of unique values that are included in all given arrays
  	     * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons. The order and references of result values are
  	     * determined by the first array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @returns {Array} Returns the new array of intersecting values.
  	     * @example
  	     *
  	     * _.intersection([2, 1], [2, 3]);
  	     * // => [2]
  	     */
  	    var intersection = baseRest(function(arrays) {
  	      var mapped = arrayMap(arrays, castArrayLikeObject);
  	      return (mapped.length && mapped[0] === arrays[0])
  	        ? baseIntersection(mapped)
  	        : [];
  	    });

  	    /**
  	     * This method is like `_.intersection` except that it accepts `iteratee`
  	     * which is invoked for each element of each `arrays` to generate the criterion
  	     * by which they're compared. The order and references of result values are
  	     * determined by the first array. The iteratee is invoked with one argument:
  	     * (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Array} Returns the new array of intersecting values.
  	     * @example
  	     *
  	     * _.intersectionBy([2.1, 1.2], [2.3, 3.4], Math.floor);
  	     * // => [2.1]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.intersectionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
  	     * // => [{ 'x': 1 }]
  	     */
  	    var intersectionBy = baseRest(function(arrays) {
  	      var iteratee = last(arrays),
  	          mapped = arrayMap(arrays, castArrayLikeObject);

  	      if (iteratee === last(mapped)) {
  	        iteratee = undefined$1;
  	      } else {
  	        mapped.pop();
  	      }
  	      return (mapped.length && mapped[0] === arrays[0])
  	        ? baseIntersection(mapped, getIteratee(iteratee, 2))
  	        : [];
  	    });

  	    /**
  	     * This method is like `_.intersection` except that it accepts `comparator`
  	     * which is invoked to compare elements of `arrays`. The order and references
  	     * of result values are determined by the first array. The comparator is
  	     * invoked with two arguments: (arrVal, othVal).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of intersecting values.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
  	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
  	     *
  	     * _.intersectionWith(objects, others, _.isEqual);
  	     * // => [{ 'x': 1, 'y': 2 }]
  	     */
  	    var intersectionWith = baseRest(function(arrays) {
  	      var comparator = last(arrays),
  	          mapped = arrayMap(arrays, castArrayLikeObject);

  	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
  	      if (comparator) {
  	        mapped.pop();
  	      }
  	      return (mapped.length && mapped[0] === arrays[0])
  	        ? baseIntersection(mapped, undefined$1, comparator)
  	        : [];
  	    });

  	    /**
  	     * Converts all elements in `array` into a string separated by `separator`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to convert.
  	     * @param {string} [separator=','] The element separator.
  	     * @returns {string} Returns the joined string.
  	     * @example
  	     *
  	     * _.join(['a', 'b', 'c'], '~');
  	     * // => 'a~b~c'
  	     */
  	    function join(array, separator) {
  	      return array == null ? '' : nativeJoin.call(array, separator);
  	    }

  	    /**
  	     * Gets the last element of `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @returns {*} Returns the last element of `array`.
  	     * @example
  	     *
  	     * _.last([1, 2, 3]);
  	     * // => 3
  	     */
  	    function last(array) {
  	      var length = array == null ? 0 : array.length;
  	      return length ? array[length - 1] : undefined$1;
  	    }

  	    /**
  	     * This method is like `_.indexOf` except that it iterates over elements of
  	     * `array` from right to left.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {*} value The value to search for.
  	     * @param {number} [fromIndex=array.length-1] The index to search from.
  	     * @returns {number} Returns the index of the matched value, else `-1`.
  	     * @example
  	     *
  	     * _.lastIndexOf([1, 2, 1, 2], 2);
  	     * // => 3
  	     *
  	     * // Search from the `fromIndex`.
  	     * _.lastIndexOf([1, 2, 1, 2], 2, 2);
  	     * // => 1
  	     */
  	    function lastIndexOf(array, value, fromIndex) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return -1;
  	      }
  	      var index = length;
  	      if (fromIndex !== undefined$1) {
  	        index = toInteger(fromIndex);
  	        index = index < 0 ? nativeMax(length + index, 0) : nativeMin(index, length - 1);
  	      }
  	      return value === value
  	        ? strictLastIndexOf(array, value, index)
  	        : baseFindIndex(array, baseIsNaN, index, true);
  	    }

  	    /**
  	     * Gets the element at index `n` of `array`. If `n` is negative, the nth
  	     * element from the end is returned.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.11.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {number} [n=0] The index of the element to return.
  	     * @returns {*} Returns the nth element of `array`.
  	     * @example
  	     *
  	     * var array = ['a', 'b', 'c', 'd'];
  	     *
  	     * _.nth(array, 1);
  	     * // => 'b'
  	     *
  	     * _.nth(array, -2);
  	     * // => 'c';
  	     */
  	    function nth(array, n) {
  	      return (array && array.length) ? baseNth(array, toInteger(n)) : undefined$1;
  	    }

  	    /**
  	     * Removes all given values from `array` using
  	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons.
  	     *
  	     * **Note:** Unlike `_.without`, this method mutates `array`. Use `_.remove`
  	     * to remove elements from an array by predicate.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @param {...*} [values] The values to remove.
  	     * @returns {Array} Returns `array`.
  	     * @example
  	     *
  	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
  	     *
  	     * _.pull(array, 'a', 'c');
  	     * console.log(array);
  	     * // => ['b', 'b']
  	     */
  	    var pull = baseRest(pullAll);

  	    /**
  	     * This method is like `_.pull` except that it accepts an array of values to remove.
  	     *
  	     * **Note:** Unlike `_.difference`, this method mutates `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @param {Array} values The values to remove.
  	     * @returns {Array} Returns `array`.
  	     * @example
  	     *
  	     * var array = ['a', 'b', 'c', 'a', 'b', 'c'];
  	     *
  	     * _.pullAll(array, ['a', 'c']);
  	     * console.log(array);
  	     * // => ['b', 'b']
  	     */
  	    function pullAll(array, values) {
  	      return (array && array.length && values && values.length)
  	        ? basePullAll(array, values)
  	        : array;
  	    }

  	    /**
  	     * This method is like `_.pullAll` except that it accepts `iteratee` which is
  	     * invoked for each element of `array` and `values` to generate the criterion
  	     * by which they're compared. The iteratee is invoked with one argument: (value).
  	     *
  	     * **Note:** Unlike `_.differenceBy`, this method mutates `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @param {Array} values The values to remove.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Array} Returns `array`.
  	     * @example
  	     *
  	     * var array = [{ 'x': 1 }, { 'x': 2 }, { 'x': 3 }, { 'x': 1 }];
  	     *
  	     * _.pullAllBy(array, [{ 'x': 1 }, { 'x': 3 }], 'x');
  	     * console.log(array);
  	     * // => [{ 'x': 2 }]
  	     */
  	    function pullAllBy(array, values, iteratee) {
  	      return (array && array.length && values && values.length)
  	        ? basePullAll(array, values, getIteratee(iteratee, 2))
  	        : array;
  	    }

  	    /**
  	     * This method is like `_.pullAll` except that it accepts `comparator` which
  	     * is invoked to compare elements of `array` to `values`. The comparator is
  	     * invoked with two arguments: (arrVal, othVal).
  	     *
  	     * **Note:** Unlike `_.differenceWith`, this method mutates `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.6.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @param {Array} values The values to remove.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns `array`.
  	     * @example
  	     *
  	     * var array = [{ 'x': 1, 'y': 2 }, { 'x': 3, 'y': 4 }, { 'x': 5, 'y': 6 }];
  	     *
  	     * _.pullAllWith(array, [{ 'x': 3, 'y': 4 }], _.isEqual);
  	     * console.log(array);
  	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 5, 'y': 6 }]
  	     */
  	    function pullAllWith(array, values, comparator) {
  	      return (array && array.length && values && values.length)
  	        ? basePullAll(array, values, undefined$1, comparator)
  	        : array;
  	    }

  	    /**
  	     * Removes elements from `array` corresponding to `indexes` and returns an
  	     * array of removed elements.
  	     *
  	     * **Note:** Unlike `_.at`, this method mutates `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @param {...(number|number[])} [indexes] The indexes of elements to remove.
  	     * @returns {Array} Returns the new array of removed elements.
  	     * @example
  	     *
  	     * var array = ['a', 'b', 'c', 'd'];
  	     * var pulled = _.pullAt(array, [1, 3]);
  	     *
  	     * console.log(array);
  	     * // => ['a', 'c']
  	     *
  	     * console.log(pulled);
  	     * // => ['b', 'd']
  	     */
  	    var pullAt = flatRest(function(array, indexes) {
  	      var length = array == null ? 0 : array.length,
  	          result = baseAt(array, indexes);

  	      basePullAt(array, arrayMap(indexes, function(index) {
  	        return isIndex(index, length) ? +index : index;
  	      }).sort(compareAscending));

  	      return result;
  	    });

  	    /**
  	     * Removes all elements from `array` that `predicate` returns truthy for
  	     * and returns an array of the removed elements. The predicate is invoked
  	     * with three arguments: (value, index, array).
  	     *
  	     * **Note:** Unlike `_.filter`, this method mutates `array`. Use `_.pull`
  	     * to pull elements from an array by value.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the new array of removed elements.
  	     * @example
  	     *
  	     * var array = [1, 2, 3, 4];
  	     * var evens = _.remove(array, function(n) {
  	     *   return n % 2 == 0;
  	     * });
  	     *
  	     * console.log(array);
  	     * // => [1, 3]
  	     *
  	     * console.log(evens);
  	     * // => [2, 4]
  	     */
  	    function remove(array, predicate) {
  	      var result = [];
  	      if (!(array && array.length)) {
  	        return result;
  	      }
  	      var index = -1,
  	          indexes = [],
  	          length = array.length;

  	      predicate = getIteratee(predicate, 3);
  	      while (++index < length) {
  	        var value = array[index];
  	        if (predicate(value, index, array)) {
  	          result.push(value);
  	          indexes.push(index);
  	        }
  	      }
  	      basePullAt(array, indexes);
  	      return result;
  	    }

  	    /**
  	     * Reverses `array` so that the first element becomes the last, the second
  	     * element becomes the second to last, and so on.
  	     *
  	     * **Note:** This method mutates `array` and is based on
  	     * [`Array#reverse`](https://mdn.io/Array/reverse).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to modify.
  	     * @returns {Array} Returns `array`.
  	     * @example
  	     *
  	     * var array = [1, 2, 3];
  	     *
  	     * _.reverse(array);
  	     * // => [3, 2, 1]
  	     *
  	     * console.log(array);
  	     * // => [3, 2, 1]
  	     */
  	    function reverse(array) {
  	      return array == null ? array : nativeReverse.call(array);
  	    }

  	    /**
  	     * Creates a slice of `array` from `start` up to, but not including, `end`.
  	     *
  	     * **Note:** This method is used instead of
  	     * [`Array#slice`](https://mdn.io/Array/slice) to ensure dense arrays are
  	     * returned.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to slice.
  	     * @param {number} [start=0] The start position.
  	     * @param {number} [end=array.length] The end position.
  	     * @returns {Array} Returns the slice of `array`.
  	     */
  	    function slice(array, start, end) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return [];
  	      }
  	      if (end && typeof end != 'number' && isIterateeCall(array, start, end)) {
  	        start = 0;
  	        end = length;
  	      }
  	      else {
  	        start = start == null ? 0 : toInteger(start);
  	        end = end === undefined$1 ? length : toInteger(end);
  	      }
  	      return baseSlice(array, start, end);
  	    }

  	    /**
  	     * Uses a binary search to determine the lowest index at which `value`
  	     * should be inserted into `array` in order to maintain its sort order.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The sorted array to inspect.
  	     * @param {*} value The value to evaluate.
  	     * @returns {number} Returns the index at which `value` should be inserted
  	     *  into `array`.
  	     * @example
  	     *
  	     * _.sortedIndex([30, 50], 40);
  	     * // => 1
  	     */
  	    function sortedIndex(array, value) {
  	      return baseSortedIndex(array, value);
  	    }

  	    /**
  	     * This method is like `_.sortedIndex` except that it accepts `iteratee`
  	     * which is invoked for `value` and each element of `array` to compute their
  	     * sort ranking. The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The sorted array to inspect.
  	     * @param {*} value The value to evaluate.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {number} Returns the index at which `value` should be inserted
  	     *  into `array`.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
  	     *
  	     * _.sortedIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
  	     * // => 0
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.sortedIndexBy(objects, { 'x': 4 }, 'x');
  	     * // => 0
  	     */
  	    function sortedIndexBy(array, value, iteratee) {
  	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2));
  	    }

  	    /**
  	     * This method is like `_.indexOf` except that it performs a binary
  	     * search on a sorted `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {*} value The value to search for.
  	     * @returns {number} Returns the index of the matched value, else `-1`.
  	     * @example
  	     *
  	     * _.sortedIndexOf([4, 5, 5, 5, 6], 5);
  	     * // => 1
  	     */
  	    function sortedIndexOf(array, value) {
  	      var length = array == null ? 0 : array.length;
  	      if (length) {
  	        var index = baseSortedIndex(array, value);
  	        if (index < length && eq(array[index], value)) {
  	          return index;
  	        }
  	      }
  	      return -1;
  	    }

  	    /**
  	     * This method is like `_.sortedIndex` except that it returns the highest
  	     * index at which `value` should be inserted into `array` in order to
  	     * maintain its sort order.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The sorted array to inspect.
  	     * @param {*} value The value to evaluate.
  	     * @returns {number} Returns the index at which `value` should be inserted
  	     *  into `array`.
  	     * @example
  	     *
  	     * _.sortedLastIndex([4, 5, 5, 5, 6], 5);
  	     * // => 4
  	     */
  	    function sortedLastIndex(array, value) {
  	      return baseSortedIndex(array, value, true);
  	    }

  	    /**
  	     * This method is like `_.sortedLastIndex` except that it accepts `iteratee`
  	     * which is invoked for `value` and each element of `array` to compute their
  	     * sort ranking. The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The sorted array to inspect.
  	     * @param {*} value The value to evaluate.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {number} Returns the index at which `value` should be inserted
  	     *  into `array`.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 4 }, { 'x': 5 }];
  	     *
  	     * _.sortedLastIndexBy(objects, { 'x': 4 }, function(o) { return o.x; });
  	     * // => 1
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.sortedLastIndexBy(objects, { 'x': 4 }, 'x');
  	     * // => 1
  	     */
  	    function sortedLastIndexBy(array, value, iteratee) {
  	      return baseSortedIndexBy(array, value, getIteratee(iteratee, 2), true);
  	    }

  	    /**
  	     * This method is like `_.lastIndexOf` except that it performs a binary
  	     * search on a sorted `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {*} value The value to search for.
  	     * @returns {number} Returns the index of the matched value, else `-1`.
  	     * @example
  	     *
  	     * _.sortedLastIndexOf([4, 5, 5, 5, 6], 5);
  	     * // => 3
  	     */
  	    function sortedLastIndexOf(array, value) {
  	      var length = array == null ? 0 : array.length;
  	      if (length) {
  	        var index = baseSortedIndex(array, value, true) - 1;
  	        if (eq(array[index], value)) {
  	          return index;
  	        }
  	      }
  	      return -1;
  	    }

  	    /**
  	     * This method is like `_.uniq` except that it's designed and optimized
  	     * for sorted arrays.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @returns {Array} Returns the new duplicate free array.
  	     * @example
  	     *
  	     * _.sortedUniq([1, 1, 2]);
  	     * // => [1, 2]
  	     */
  	    function sortedUniq(array) {
  	      return (array && array.length)
  	        ? baseSortedUniq(array)
  	        : [];
  	    }

  	    /**
  	     * This method is like `_.uniqBy` except that it's designed and optimized
  	     * for sorted arrays.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [iteratee] The iteratee invoked per element.
  	     * @returns {Array} Returns the new duplicate free array.
  	     * @example
  	     *
  	     * _.sortedUniqBy([1.1, 1.2, 2.3, 2.4], Math.floor);
  	     * // => [1.1, 2.3]
  	     */
  	    function sortedUniqBy(array, iteratee) {
  	      return (array && array.length)
  	        ? baseSortedUniq(array, getIteratee(iteratee, 2))
  	        : [];
  	    }

  	    /**
  	     * Gets all but the first element of `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * _.tail([1, 2, 3]);
  	     * // => [2, 3]
  	     */
  	    function tail(array) {
  	      var length = array == null ? 0 : array.length;
  	      return length ? baseSlice(array, 1, length) : [];
  	    }

  	    /**
  	     * Creates a slice of `array` with `n` elements taken from the beginning.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {number} [n=1] The number of elements to take.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * _.take([1, 2, 3]);
  	     * // => [1]
  	     *
  	     * _.take([1, 2, 3], 2);
  	     * // => [1, 2]
  	     *
  	     * _.take([1, 2, 3], 5);
  	     * // => [1, 2, 3]
  	     *
  	     * _.take([1, 2, 3], 0);
  	     * // => []
  	     */
  	    function take(array, n, guard) {
  	      if (!(array && array.length)) {
  	        return [];
  	      }
  	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
  	      return baseSlice(array, 0, n < 0 ? 0 : n);
  	    }

  	    /**
  	     * Creates a slice of `array` with `n` elements taken from the end.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {number} [n=1] The number of elements to take.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * _.takeRight([1, 2, 3]);
  	     * // => [3]
  	     *
  	     * _.takeRight([1, 2, 3], 2);
  	     * // => [2, 3]
  	     *
  	     * _.takeRight([1, 2, 3], 5);
  	     * // => [1, 2, 3]
  	     *
  	     * _.takeRight([1, 2, 3], 0);
  	     * // => []
  	     */
  	    function takeRight(array, n, guard) {
  	      var length = array == null ? 0 : array.length;
  	      if (!length) {
  	        return [];
  	      }
  	      n = (guard || n === undefined$1) ? 1 : toInteger(n);
  	      n = length - n;
  	      return baseSlice(array, n < 0 ? 0 : n, length);
  	    }

  	    /**
  	     * Creates a slice of `array` with elements taken from the end. Elements are
  	     * taken until `predicate` returns falsey. The predicate is invoked with
  	     * three arguments: (value, index, array).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'active': true },
  	     *   { 'user': 'fred',    'active': false },
  	     *   { 'user': 'pebbles', 'active': false }
  	     * ];
  	     *
  	     * _.takeRightWhile(users, function(o) { return !o.active; });
  	     * // => objects for ['fred', 'pebbles']
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.takeRightWhile(users, { 'user': 'pebbles', 'active': false });
  	     * // => objects for ['pebbles']
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.takeRightWhile(users, ['active', false]);
  	     * // => objects for ['fred', 'pebbles']
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.takeRightWhile(users, 'active');
  	     * // => []
  	     */
  	    function takeRightWhile(array, predicate) {
  	      return (array && array.length)
  	        ? baseWhile(array, getIteratee(predicate, 3), false, true)
  	        : [];
  	    }

  	    /**
  	     * Creates a slice of `array` with elements taken from the beginning. Elements
  	     * are taken until `predicate` returns falsey. The predicate is invoked with
  	     * three arguments: (value, index, array).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Array
  	     * @param {Array} array The array to query.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the slice of `array`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'active': false },
  	     *   { 'user': 'fred',    'active': false },
  	     *   { 'user': 'pebbles', 'active': true }
  	     * ];
  	     *
  	     * _.takeWhile(users, function(o) { return !o.active; });
  	     * // => objects for ['barney', 'fred']
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.takeWhile(users, { 'user': 'barney', 'active': false });
  	     * // => objects for ['barney']
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.takeWhile(users, ['active', false]);
  	     * // => objects for ['barney', 'fred']
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.takeWhile(users, 'active');
  	     * // => []
  	     */
  	    function takeWhile(array, predicate) {
  	      return (array && array.length)
  	        ? baseWhile(array, getIteratee(predicate, 3))
  	        : [];
  	    }

  	    /**
  	     * Creates an array of unique values, in order, from all given arrays using
  	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @returns {Array} Returns the new array of combined values.
  	     * @example
  	     *
  	     * _.union([2], [1, 2]);
  	     * // => [2, 1]
  	     */
  	    var union = baseRest(function(arrays) {
  	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true));
  	    });

  	    /**
  	     * This method is like `_.union` except that it accepts `iteratee` which is
  	     * invoked for each element of each `arrays` to generate the criterion by
  	     * which uniqueness is computed. Result values are chosen from the first
  	     * array in which the value occurs. The iteratee is invoked with one argument:
  	     * (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Array} Returns the new array of combined values.
  	     * @example
  	     *
  	     * _.unionBy([2.1], [1.2, 2.3], Math.floor);
  	     * // => [2.1, 1.2]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.unionBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
  	     * // => [{ 'x': 1 }, { 'x': 2 }]
  	     */
  	    var unionBy = baseRest(function(arrays) {
  	      var iteratee = last(arrays);
  	      if (isArrayLikeObject(iteratee)) {
  	        iteratee = undefined$1;
  	      }
  	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), getIteratee(iteratee, 2));
  	    });

  	    /**
  	     * This method is like `_.union` except that it accepts `comparator` which
  	     * is invoked to compare elements of `arrays`. Result values are chosen from
  	     * the first array in which the value occurs. The comparator is invoked
  	     * with two arguments: (arrVal, othVal).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of combined values.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
  	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
  	     *
  	     * _.unionWith(objects, others, _.isEqual);
  	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
  	     */
  	    var unionWith = baseRest(function(arrays) {
  	      var comparator = last(arrays);
  	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
  	      return baseUniq(baseFlatten(arrays, 1, isArrayLikeObject, true), undefined$1, comparator);
  	    });

  	    /**
  	     * Creates a duplicate-free version of an array, using
  	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons, in which only the first occurrence of each element
  	     * is kept. The order of result values is determined by the order they occur
  	     * in the array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @returns {Array} Returns the new duplicate free array.
  	     * @example
  	     *
  	     * _.uniq([2, 1, 2]);
  	     * // => [2, 1]
  	     */
  	    function uniq(array) {
  	      return (array && array.length) ? baseUniq(array) : [];
  	    }

  	    /**
  	     * This method is like `_.uniq` except that it accepts `iteratee` which is
  	     * invoked for each element in `array` to generate the criterion by which
  	     * uniqueness is computed. The order of result values is determined by the
  	     * order they occur in the array. The iteratee is invoked with one argument:
  	     * (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Array} Returns the new duplicate free array.
  	     * @example
  	     *
  	     * _.uniqBy([2.1, 1.2, 2.3], Math.floor);
  	     * // => [2.1, 1.2]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.uniqBy([{ 'x': 1 }, { 'x': 2 }, { 'x': 1 }], 'x');
  	     * // => [{ 'x': 1 }, { 'x': 2 }]
  	     */
  	    function uniqBy(array, iteratee) {
  	      return (array && array.length) ? baseUniq(array, getIteratee(iteratee, 2)) : [];
  	    }

  	    /**
  	     * This method is like `_.uniq` except that it accepts `comparator` which
  	     * is invoked to compare elements of `array`. The order of result values is
  	     * determined by the order they occur in the array.The comparator is invoked
  	     * with two arguments: (arrVal, othVal).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new duplicate free array.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }, { 'x': 1, 'y': 2 }];
  	     *
  	     * _.uniqWith(objects, _.isEqual);
  	     * // => [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }]
  	     */
  	    function uniqWith(array, comparator) {
  	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
  	      return (array && array.length) ? baseUniq(array, undefined$1, comparator) : [];
  	    }

  	    /**
  	     * This method is like `_.zip` except that it accepts an array of grouped
  	     * elements and creates an array regrouping the elements to their pre-zip
  	     * configuration.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.2.0
  	     * @category Array
  	     * @param {Array} array The array of grouped elements to process.
  	     * @returns {Array} Returns the new array of regrouped elements.
  	     * @example
  	     *
  	     * var zipped = _.zip(['a', 'b'], [1, 2], [true, false]);
  	     * // => [['a', 1, true], ['b', 2, false]]
  	     *
  	     * _.unzip(zipped);
  	     * // => [['a', 'b'], [1, 2], [true, false]]
  	     */
  	    function unzip(array) {
  	      if (!(array && array.length)) {
  	        return [];
  	      }
  	      var length = 0;
  	      array = arrayFilter(array, function(group) {
  	        if (isArrayLikeObject(group)) {
  	          length = nativeMax(group.length, length);
  	          return true;
  	        }
  	      });
  	      return baseTimes(length, function(index) {
  	        return arrayMap(array, baseProperty(index));
  	      });
  	    }

  	    /**
  	     * This method is like `_.unzip` except that it accepts `iteratee` to specify
  	     * how regrouped values should be combined. The iteratee is invoked with the
  	     * elements of each group: (...group).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.8.0
  	     * @category Array
  	     * @param {Array} array The array of grouped elements to process.
  	     * @param {Function} [iteratee=_.identity] The function to combine
  	     *  regrouped values.
  	     * @returns {Array} Returns the new array of regrouped elements.
  	     * @example
  	     *
  	     * var zipped = _.zip([1, 2], [10, 20], [100, 200]);
  	     * // => [[1, 10, 100], [2, 20, 200]]
  	     *
  	     * _.unzipWith(zipped, _.add);
  	     * // => [3, 30, 300]
  	     */
  	    function unzipWith(array, iteratee) {
  	      if (!(array && array.length)) {
  	        return [];
  	      }
  	      var result = unzip(array);
  	      if (iteratee == null) {
  	        return result;
  	      }
  	      return arrayMap(result, function(group) {
  	        return apply(iteratee, undefined$1, group);
  	      });
  	    }

  	    /**
  	     * Creates an array excluding all given values using
  	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * for equality comparisons.
  	     *
  	     * **Note:** Unlike `_.pull`, this method returns a new array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {Array} array The array to inspect.
  	     * @param {...*} [values] The values to exclude.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @see _.difference, _.xor
  	     * @example
  	     *
  	     * _.without([2, 1, 2, 3], 1, 2);
  	     * // => [3]
  	     */
  	    var without = baseRest(function(array, values) {
  	      return isArrayLikeObject(array)
  	        ? baseDifference(array, values)
  	        : [];
  	    });

  	    /**
  	     * Creates an array of unique values that is the
  	     * [symmetric difference](https://en.wikipedia.org/wiki/Symmetric_difference)
  	     * of the given arrays. The order of result values is determined by the order
  	     * they occur in the arrays.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.4.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @see _.difference, _.without
  	     * @example
  	     *
  	     * _.xor([2, 1], [2, 3]);
  	     * // => [1, 3]
  	     */
  	    var xor = baseRest(function(arrays) {
  	      return baseXor(arrayFilter(arrays, isArrayLikeObject));
  	    });

  	    /**
  	     * This method is like `_.xor` except that it accepts `iteratee` which is
  	     * invoked for each element of each `arrays` to generate the criterion by
  	     * which by which they're compared. The order of result values is determined
  	     * by the order they occur in the arrays. The iteratee is invoked with one
  	     * argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @example
  	     *
  	     * _.xorBy([2.1, 1.2], [2.3, 3.4], Math.floor);
  	     * // => [1.2, 3.4]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.xorBy([{ 'x': 1 }], [{ 'x': 2 }, { 'x': 1 }], 'x');
  	     * // => [{ 'x': 2 }]
  	     */
  	    var xorBy = baseRest(function(arrays) {
  	      var iteratee = last(arrays);
  	      if (isArrayLikeObject(iteratee)) {
  	        iteratee = undefined$1;
  	      }
  	      return baseXor(arrayFilter(arrays, isArrayLikeObject), getIteratee(iteratee, 2));
  	    });

  	    /**
  	     * This method is like `_.xor` except that it accepts `comparator` which is
  	     * invoked to compare elements of `arrays`. The order of result values is
  	     * determined by the order they occur in the arrays. The comparator is invoked
  	     * with two arguments: (arrVal, othVal).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to inspect.
  	     * @param {Function} [comparator] The comparator invoked per element.
  	     * @returns {Array} Returns the new array of filtered values.
  	     * @example
  	     *
  	     * var objects = [{ 'x': 1, 'y': 2 }, { 'x': 2, 'y': 1 }];
  	     * var others = [{ 'x': 1, 'y': 1 }, { 'x': 1, 'y': 2 }];
  	     *
  	     * _.xorWith(objects, others, _.isEqual);
  	     * // => [{ 'x': 2, 'y': 1 }, { 'x': 1, 'y': 1 }]
  	     */
  	    var xorWith = baseRest(function(arrays) {
  	      var comparator = last(arrays);
  	      comparator = typeof comparator == 'function' ? comparator : undefined$1;
  	      return baseXor(arrayFilter(arrays, isArrayLikeObject), undefined$1, comparator);
  	    });

  	    /**
  	     * Creates an array of grouped elements, the first of which contains the
  	     * first elements of the given arrays, the second of which contains the
  	     * second elements of the given arrays, and so on.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to process.
  	     * @returns {Array} Returns the new array of grouped elements.
  	     * @example
  	     *
  	     * _.zip(['a', 'b'], [1, 2], [true, false]);
  	     * // => [['a', 1, true], ['b', 2, false]]
  	     */
  	    var zip = baseRest(unzip);

  	    /**
  	     * This method is like `_.fromPairs` except that it accepts two arrays,
  	     * one of property identifiers and one of corresponding values.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.4.0
  	     * @category Array
  	     * @param {Array} [props=[]] The property identifiers.
  	     * @param {Array} [values=[]] The property values.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * _.zipObject(['a', 'b'], [1, 2]);
  	     * // => { 'a': 1, 'b': 2 }
  	     */
  	    function zipObject(props, values) {
  	      return baseZipObject(props || [], values || [], assignValue);
  	    }

  	    /**
  	     * This method is like `_.zipObject` except that it supports property paths.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.1.0
  	     * @category Array
  	     * @param {Array} [props=[]] The property identifiers.
  	     * @param {Array} [values=[]] The property values.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * _.zipObjectDeep(['a.b[0].c', 'a.b[1].d'], [1, 2]);
  	     * // => { 'a': { 'b': [{ 'c': 1 }, { 'd': 2 }] } }
  	     */
  	    function zipObjectDeep(props, values) {
  	      return baseZipObject(props || [], values || [], baseSet);
  	    }

  	    /**
  	     * This method is like `_.zip` except that it accepts `iteratee` to specify
  	     * how grouped values should be combined. The iteratee is invoked with the
  	     * elements of each group: (...group).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.8.0
  	     * @category Array
  	     * @param {...Array} [arrays] The arrays to process.
  	     * @param {Function} [iteratee=_.identity] The function to combine
  	     *  grouped values.
  	     * @returns {Array} Returns the new array of grouped elements.
  	     * @example
  	     *
  	     * _.zipWith([1, 2], [10, 20], [100, 200], function(a, b, c) {
  	     *   return a + b + c;
  	     * });
  	     * // => [111, 222]
  	     */
  	    var zipWith = baseRest(function(arrays) {
  	      var length = arrays.length,
  	          iteratee = length > 1 ? arrays[length - 1] : undefined$1;

  	      iteratee = typeof iteratee == 'function' ? (arrays.pop(), iteratee) : undefined$1;
  	      return unzipWith(arrays, iteratee);
  	    });

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates a `lodash` wrapper instance that wraps `value` with explicit method
  	     * chain sequences enabled. The result of such sequences must be unwrapped
  	     * with `_#value`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.3.0
  	     * @category Seq
  	     * @param {*} value The value to wrap.
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'age': 36 },
  	     *   { 'user': 'fred',    'age': 40 },
  	     *   { 'user': 'pebbles', 'age': 1 }
  	     * ];
  	     *
  	     * var youngest = _
  	     *   .chain(users)
  	     *   .sortBy('age')
  	     *   .map(function(o) {
  	     *     return o.user + ' is ' + o.age;
  	     *   })
  	     *   .head()
  	     *   .value();
  	     * // => 'pebbles is 1'
  	     */
  	    function chain(value) {
  	      var result = lodash(value);
  	      result.__chain__ = true;
  	      return result;
  	    }

  	    /**
  	     * This method invokes `interceptor` and returns `value`. The interceptor
  	     * is invoked with one argument; (value). The purpose of this method is to
  	     * "tap into" a method chain sequence in order to modify intermediate results.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Seq
  	     * @param {*} value The value to provide to `interceptor`.
  	     * @param {Function} interceptor The function to invoke.
  	     * @returns {*} Returns `value`.
  	     * @example
  	     *
  	     * _([1, 2, 3])
  	     *  .tap(function(array) {
  	     *    // Mutate input array.
  	     *    array.pop();
  	     *  })
  	     *  .reverse()
  	     *  .value();
  	     * // => [2, 1]
  	     */
  	    function tap(value, interceptor) {
  	      interceptor(value);
  	      return value;
  	    }

  	    /**
  	     * This method is like `_.tap` except that it returns the result of `interceptor`.
  	     * The purpose of this method is to "pass thru" values replacing intermediate
  	     * results in a method chain sequence.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Seq
  	     * @param {*} value The value to provide to `interceptor`.
  	     * @param {Function} interceptor The function to invoke.
  	     * @returns {*} Returns the result of `interceptor`.
  	     * @example
  	     *
  	     * _('  abc  ')
  	     *  .chain()
  	     *  .trim()
  	     *  .thru(function(value) {
  	     *    return [value];
  	     *  })
  	     *  .value();
  	     * // => ['abc']
  	     */
  	    function thru(value, interceptor) {
  	      return interceptor(value);
  	    }

  	    /**
  	     * This method is the wrapper version of `_.at`.
  	     *
  	     * @name at
  	     * @memberOf _
  	     * @since 1.0.0
  	     * @category Seq
  	     * @param {...(string|string[])} [paths] The property paths to pick.
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
  	     *
  	     * _(object).at(['a[0].b.c', 'a[1]']).value();
  	     * // => [3, 4]
  	     */
  	    var wrapperAt = flatRest(function(paths) {
  	      var length = paths.length,
  	          start = length ? paths[0] : 0,
  	          value = this.__wrapped__,
  	          interceptor = function(object) { return baseAt(object, paths); };

  	      if (length > 1 || this.__actions__.length ||
  	          !(value instanceof LazyWrapper) || !isIndex(start)) {
  	        return this.thru(interceptor);
  	      }
  	      value = value.slice(start, +start + (length ? 1 : 0));
  	      value.__actions__.push({
  	        'func': thru,
  	        'args': [interceptor],
  	        'thisArg': undefined$1
  	      });
  	      return new LodashWrapper(value, this.__chain__).thru(function(array) {
  	        if (length && !array.length) {
  	          array.push(undefined$1);
  	        }
  	        return array;
  	      });
  	    });

  	    /**
  	     * Creates a `lodash` wrapper instance with explicit method chain sequences enabled.
  	     *
  	     * @name chain
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Seq
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney', 'age': 36 },
  	     *   { 'user': 'fred',   'age': 40 }
  	     * ];
  	     *
  	     * // A sequence without explicit chaining.
  	     * _(users).head();
  	     * // => { 'user': 'barney', 'age': 36 }
  	     *
  	     * // A sequence with explicit chaining.
  	     * _(users)
  	     *   .chain()
  	     *   .head()
  	     *   .pick('user')
  	     *   .value();
  	     * // => { 'user': 'barney' }
  	     */
  	    function wrapperChain() {
  	      return chain(this);
  	    }

  	    /**
  	     * Executes the chain sequence and returns the wrapped result.
  	     *
  	     * @name commit
  	     * @memberOf _
  	     * @since 3.2.0
  	     * @category Seq
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * var array = [1, 2];
  	     * var wrapped = _(array).push(3);
  	     *
  	     * console.log(array);
  	     * // => [1, 2]
  	     *
  	     * wrapped = wrapped.commit();
  	     * console.log(array);
  	     * // => [1, 2, 3]
  	     *
  	     * wrapped.last();
  	     * // => 3
  	     *
  	     * console.log(array);
  	     * // => [1, 2, 3]
  	     */
  	    function wrapperCommit() {
  	      return new LodashWrapper(this.value(), this.__chain__);
  	    }

  	    /**
  	     * Gets the next value on a wrapped object following the
  	     * [iterator protocol](https://mdn.io/iteration_protocols#iterator).
  	     *
  	     * @name next
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Seq
  	     * @returns {Object} Returns the next iterator value.
  	     * @example
  	     *
  	     * var wrapped = _([1, 2]);
  	     *
  	     * wrapped.next();
  	     * // => { 'done': false, 'value': 1 }
  	     *
  	     * wrapped.next();
  	     * // => { 'done': false, 'value': 2 }
  	     *
  	     * wrapped.next();
  	     * // => { 'done': true, 'value': undefined }
  	     */
  	    function wrapperNext() {
  	      if (this.__values__ === undefined$1) {
  	        this.__values__ = toArray(this.value());
  	      }
  	      var done = this.__index__ >= this.__values__.length,
  	          value = done ? undefined$1 : this.__values__[this.__index__++];

  	      return { 'done': done, 'value': value };
  	    }

  	    /**
  	     * Enables the wrapper to be iterable.
  	     *
  	     * @name Symbol.iterator
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Seq
  	     * @returns {Object} Returns the wrapper object.
  	     * @example
  	     *
  	     * var wrapped = _([1, 2]);
  	     *
  	     * wrapped[Symbol.iterator]() === wrapped;
  	     * // => true
  	     *
  	     * Array.from(wrapped);
  	     * // => [1, 2]
  	     */
  	    function wrapperToIterator() {
  	      return this;
  	    }

  	    /**
  	     * Creates a clone of the chain sequence planting `value` as the wrapped value.
  	     *
  	     * @name plant
  	     * @memberOf _
  	     * @since 3.2.0
  	     * @category Seq
  	     * @param {*} value The value to plant.
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * function square(n) {
  	     *   return n * n;
  	     * }
  	     *
  	     * var wrapped = _([1, 2]).map(square);
  	     * var other = wrapped.plant([3, 4]);
  	     *
  	     * other.value();
  	     * // => [9, 16]
  	     *
  	     * wrapped.value();
  	     * // => [1, 4]
  	     */
  	    function wrapperPlant(value) {
  	      var result,
  	          parent = this;

  	      while (parent instanceof baseLodash) {
  	        var clone = wrapperClone(parent);
  	        clone.__index__ = 0;
  	        clone.__values__ = undefined$1;
  	        if (result) {
  	          previous.__wrapped__ = clone;
  	        } else {
  	          result = clone;
  	        }
  	        var previous = clone;
  	        parent = parent.__wrapped__;
  	      }
  	      previous.__wrapped__ = value;
  	      return result;
  	    }

  	    /**
  	     * This method is the wrapper version of `_.reverse`.
  	     *
  	     * **Note:** This method mutates the wrapped array.
  	     *
  	     * @name reverse
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Seq
  	     * @returns {Object} Returns the new `lodash` wrapper instance.
  	     * @example
  	     *
  	     * var array = [1, 2, 3];
  	     *
  	     * _(array).reverse().value()
  	     * // => [3, 2, 1]
  	     *
  	     * console.log(array);
  	     * // => [3, 2, 1]
  	     */
  	    function wrapperReverse() {
  	      var value = this.__wrapped__;
  	      if (value instanceof LazyWrapper) {
  	        var wrapped = value;
  	        if (this.__actions__.length) {
  	          wrapped = new LazyWrapper(this);
  	        }
  	        wrapped = wrapped.reverse();
  	        wrapped.__actions__.push({
  	          'func': thru,
  	          'args': [reverse],
  	          'thisArg': undefined$1
  	        });
  	        return new LodashWrapper(wrapped, this.__chain__);
  	      }
  	      return this.thru(reverse);
  	    }

  	    /**
  	     * Executes the chain sequence to resolve the unwrapped value.
  	     *
  	     * @name value
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @alias toJSON, valueOf
  	     * @category Seq
  	     * @returns {*} Returns the resolved unwrapped value.
  	     * @example
  	     *
  	     * _([1, 2, 3]).value();
  	     * // => [1, 2, 3]
  	     */
  	    function wrapperValue() {
  	      return baseWrapperValue(this.__wrapped__, this.__actions__);
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Creates an object composed of keys generated from the results of running
  	     * each element of `collection` thru `iteratee`. The corresponding value of
  	     * each key is the number of times the key was returned by `iteratee`. The
  	     * iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.5.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
  	     * @returns {Object} Returns the composed aggregate object.
  	     * @example
  	     *
  	     * _.countBy([6.1, 4.2, 6.3], Math.floor);
  	     * // => { '4': 1, '6': 2 }
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.countBy(['one', 'two', 'three'], 'length');
  	     * // => { '3': 2, '5': 1 }
  	     */
  	    var countBy = createAggregator(function(result, value, key) {
  	      if (hasOwnProperty.call(result, key)) {
  	        ++result[key];
  	      } else {
  	        baseAssignValue(result, key, 1);
  	      }
  	    });

  	    /**
  	     * Checks if `predicate` returns truthy for **all** elements of `collection`.
  	     * Iteration is stopped once `predicate` returns falsey. The predicate is
  	     * invoked with three arguments: (value, index|key, collection).
  	     *
  	     * **Note:** This method returns `true` for
  	     * [empty collections](https://en.wikipedia.org/wiki/Empty_set) because
  	     * [everything is true](https://en.wikipedia.org/wiki/Vacuous_truth) of
  	     * elements of empty collections.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {boolean} Returns `true` if all elements pass the predicate check,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.every([true, 1, null, 'yes'], Boolean);
  	     * // => false
  	     *
  	     * var users = [
  	     *   { 'user': 'barney', 'age': 36, 'active': false },
  	     *   { 'user': 'fred',   'age': 40, 'active': false }
  	     * ];
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.every(users, { 'user': 'barney', 'active': false });
  	     * // => false
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.every(users, ['active', false]);
  	     * // => true
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.every(users, 'active');
  	     * // => false
  	     */
  	    function every(collection, predicate, guard) {
  	      var func = isArray(collection) ? arrayEvery : baseEvery;
  	      if (guard && isIterateeCall(collection, predicate, guard)) {
  	        predicate = undefined$1;
  	      }
  	      return func(collection, getIteratee(predicate, 3));
  	    }

  	    /**
  	     * Iterates over elements of `collection`, returning an array of all elements
  	     * `predicate` returns truthy for. The predicate is invoked with three
  	     * arguments: (value, index|key, collection).
  	     *
  	     * **Note:** Unlike `_.remove`, this method returns a new array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the new filtered array.
  	     * @see _.reject
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney', 'age': 36, 'active': true },
  	     *   { 'user': 'fred',   'age': 40, 'active': false }
  	     * ];
  	     *
  	     * _.filter(users, function(o) { return !o.active; });
  	     * // => objects for ['fred']
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.filter(users, { 'age': 36, 'active': true });
  	     * // => objects for ['barney']
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.filter(users, ['active', false]);
  	     * // => objects for ['fred']
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.filter(users, 'active');
  	     * // => objects for ['barney']
  	     *
  	     * // Combining several predicates using `_.overEvery` or `_.overSome`.
  	     * _.filter(users, _.overSome([{ 'age': 36 }, ['age', 40]]));
  	     * // => objects for ['fred', 'barney']
  	     */
  	    function filter(collection, predicate) {
  	      var func = isArray(collection) ? arrayFilter : baseFilter;
  	      return func(collection, getIteratee(predicate, 3));
  	    }

  	    /**
  	     * Iterates over elements of `collection`, returning the first element
  	     * `predicate` returns truthy for. The predicate is invoked with three
  	     * arguments: (value, index|key, collection).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to inspect.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @param {number} [fromIndex=0] The index to search from.
  	     * @returns {*} Returns the matched element, else `undefined`.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'age': 36, 'active': true },
  	     *   { 'user': 'fred',    'age': 40, 'active': false },
  	     *   { 'user': 'pebbles', 'age': 1,  'active': true }
  	     * ];
  	     *
  	     * _.find(users, function(o) { return o.age < 40; });
  	     * // => object for 'barney'
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.find(users, { 'age': 1, 'active': true });
  	     * // => object for 'pebbles'
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.find(users, ['active', false]);
  	     * // => object for 'fred'
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.find(users, 'active');
  	     * // => object for 'barney'
  	     */
  	    var find = createFind(findIndex);

  	    /**
  	     * This method is like `_.find` except that it iterates over elements of
  	     * `collection` from right to left.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to inspect.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @param {number} [fromIndex=collection.length-1] The index to search from.
  	     * @returns {*} Returns the matched element, else `undefined`.
  	     * @example
  	     *
  	     * _.findLast([1, 2, 3, 4], function(n) {
  	     *   return n % 2 == 1;
  	     * });
  	     * // => 3
  	     */
  	    var findLast = createFind(findLastIndex);

  	    /**
  	     * Creates a flattened array of values by running each element in `collection`
  	     * thru `iteratee` and flattening the mapped results. The iteratee is invoked
  	     * with three arguments: (value, index|key, collection).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the new flattened array.
  	     * @example
  	     *
  	     * function duplicate(n) {
  	     *   return [n, n];
  	     * }
  	     *
  	     * _.flatMap([1, 2], duplicate);
  	     * // => [1, 1, 2, 2]
  	     */
  	    function flatMap(collection, iteratee) {
  	      return baseFlatten(map(collection, iteratee), 1);
  	    }

  	    /**
  	     * This method is like `_.flatMap` except that it recursively flattens the
  	     * mapped results.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.7.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the new flattened array.
  	     * @example
  	     *
  	     * function duplicate(n) {
  	     *   return [[[n, n]]];
  	     * }
  	     *
  	     * _.flatMapDeep([1, 2], duplicate);
  	     * // => [1, 1, 2, 2]
  	     */
  	    function flatMapDeep(collection, iteratee) {
  	      return baseFlatten(map(collection, iteratee), INFINITY);
  	    }

  	    /**
  	     * This method is like `_.flatMap` except that it recursively flattens the
  	     * mapped results up to `depth` times.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.7.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @param {number} [depth=1] The maximum recursion depth.
  	     * @returns {Array} Returns the new flattened array.
  	     * @example
  	     *
  	     * function duplicate(n) {
  	     *   return [[[n, n]]];
  	     * }
  	     *
  	     * _.flatMapDepth([1, 2], duplicate, 2);
  	     * // => [[1, 1], [2, 2]]
  	     */
  	    function flatMapDepth(collection, iteratee, depth) {
  	      depth = depth === undefined$1 ? 1 : toInteger(depth);
  	      return baseFlatten(map(collection, iteratee), depth);
  	    }

  	    /**
  	     * Iterates over elements of `collection` and invokes `iteratee` for each element.
  	     * The iteratee is invoked with three arguments: (value, index|key, collection).
  	     * Iteratee functions may exit iteration early by explicitly returning `false`.
  	     *
  	     * **Note:** As with other "Collections" methods, objects with a "length"
  	     * property are iterated like arrays. To avoid this behavior use `_.forIn`
  	     * or `_.forOwn` for object iteration.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @alias each
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Array|Object} Returns `collection`.
  	     * @see _.forEachRight
  	     * @example
  	     *
  	     * _.forEach([1, 2], function(value) {
  	     *   console.log(value);
  	     * });
  	     * // => Logs `1` then `2`.
  	     *
  	     * _.forEach({ 'a': 1, 'b': 2 }, function(value, key) {
  	     *   console.log(key);
  	     * });
  	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
  	     */
  	    function forEach(collection, iteratee) {
  	      var func = isArray(collection) ? arrayEach : baseEach;
  	      return func(collection, getIteratee(iteratee, 3));
  	    }

  	    /**
  	     * This method is like `_.forEach` except that it iterates over elements of
  	     * `collection` from right to left.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @alias eachRight
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Array|Object} Returns `collection`.
  	     * @see _.forEach
  	     * @example
  	     *
  	     * _.forEachRight([1, 2], function(value) {
  	     *   console.log(value);
  	     * });
  	     * // => Logs `2` then `1`.
  	     */
  	    function forEachRight(collection, iteratee) {
  	      var func = isArray(collection) ? arrayEachRight : baseEachRight;
  	      return func(collection, getIteratee(iteratee, 3));
  	    }

  	    /**
  	     * Creates an object composed of keys generated from the results of running
  	     * each element of `collection` thru `iteratee`. The order of grouped values
  	     * is determined by the order they occur in `collection`. The corresponding
  	     * value of each key is an array of elements responsible for generating the
  	     * key. The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
  	     * @returns {Object} Returns the composed aggregate object.
  	     * @example
  	     *
  	     * _.groupBy([6.1, 4.2, 6.3], Math.floor);
  	     * // => { '4': [4.2], '6': [6.1, 6.3] }
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.groupBy(['one', 'two', 'three'], 'length');
  	     * // => { '3': ['one', 'two'], '5': ['three'] }
  	     */
  	    var groupBy = createAggregator(function(result, value, key) {
  	      if (hasOwnProperty.call(result, key)) {
  	        result[key].push(value);
  	      } else {
  	        baseAssignValue(result, key, [value]);
  	      }
  	    });

  	    /**
  	     * Checks if `value` is in `collection`. If `collection` is a string, it's
  	     * checked for a substring of `value`, otherwise
  	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * is used for equality comparisons. If `fromIndex` is negative, it's used as
  	     * the offset from the end of `collection`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object|string} collection The collection to inspect.
  	     * @param {*} value The value to search for.
  	     * @param {number} [fromIndex=0] The index to search from.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
  	     * @returns {boolean} Returns `true` if `value` is found, else `false`.
  	     * @example
  	     *
  	     * _.includes([1, 2, 3], 1);
  	     * // => true
  	     *
  	     * _.includes([1, 2, 3], 1, 2);
  	     * // => false
  	     *
  	     * _.includes({ 'a': 1, 'b': 2 }, 1);
  	     * // => true
  	     *
  	     * _.includes('abcd', 'bc');
  	     * // => true
  	     */
  	    function includes(collection, value, fromIndex, guard) {
  	      collection = isArrayLike(collection) ? collection : values(collection);
  	      fromIndex = (fromIndex && !guard) ? toInteger(fromIndex) : 0;

  	      var length = collection.length;
  	      if (fromIndex < 0) {
  	        fromIndex = nativeMax(length + fromIndex, 0);
  	      }
  	      return isString(collection)
  	        ? (fromIndex <= length && collection.indexOf(value, fromIndex) > -1)
  	        : (!!length && baseIndexOf(collection, value, fromIndex) > -1);
  	    }

  	    /**
  	     * Invokes the method at `path` of each element in `collection`, returning
  	     * an array of the results of each invoked method. Any additional arguments
  	     * are provided to each invoked method. If `path` is a function, it's invoked
  	     * for, and `this` bound to, each element in `collection`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Array|Function|string} path The path of the method to invoke or
  	     *  the function invoked per iteration.
  	     * @param {...*} [args] The arguments to invoke each method with.
  	     * @returns {Array} Returns the array of results.
  	     * @example
  	     *
  	     * _.invokeMap([[5, 1, 7], [3, 2, 1]], 'sort');
  	     * // => [[1, 5, 7], [1, 2, 3]]
  	     *
  	     * _.invokeMap([123, 456], String.prototype.split, '');
  	     * // => [['1', '2', '3'], ['4', '5', '6']]
  	     */
  	    var invokeMap = baseRest(function(collection, path, args) {
  	      var index = -1,
  	          isFunc = typeof path == 'function',
  	          result = isArrayLike(collection) ? Array(collection.length) : [];

  	      baseEach(collection, function(value) {
  	        result[++index] = isFunc ? apply(path, value, args) : baseInvoke(value, path, args);
  	      });
  	      return result;
  	    });

  	    /**
  	     * Creates an object composed of keys generated from the results of running
  	     * each element of `collection` thru `iteratee`. The corresponding value of
  	     * each key is the last element responsible for generating the key. The
  	     * iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee to transform keys.
  	     * @returns {Object} Returns the composed aggregate object.
  	     * @example
  	     *
  	     * var array = [
  	     *   { 'dir': 'left', 'code': 97 },
  	     *   { 'dir': 'right', 'code': 100 }
  	     * ];
  	     *
  	     * _.keyBy(array, function(o) {
  	     *   return String.fromCharCode(o.code);
  	     * });
  	     * // => { 'a': { 'dir': 'left', 'code': 97 }, 'd': { 'dir': 'right', 'code': 100 } }
  	     *
  	     * _.keyBy(array, 'dir');
  	     * // => { 'left': { 'dir': 'left', 'code': 97 }, 'right': { 'dir': 'right', 'code': 100 } }
  	     */
  	    var keyBy = createAggregator(function(result, value, key) {
  	      baseAssignValue(result, key, value);
  	    });

  	    /**
  	     * Creates an array of values by running each element in `collection` thru
  	     * `iteratee`. The iteratee is invoked with three arguments:
  	     * (value, index|key, collection).
  	     *
  	     * Many lodash methods are guarded to work as iteratees for methods like
  	     * `_.every`, `_.filter`, `_.map`, `_.mapValues`, `_.reject`, and `_.some`.
  	     *
  	     * The guarded methods are:
  	     * `ary`, `chunk`, `curry`, `curryRight`, `drop`, `dropRight`, `every`,
  	     * `fill`, `invert`, `parseInt`, `random`, `range`, `rangeRight`, `repeat`,
  	     * `sampleSize`, `slice`, `some`, `sortBy`, `split`, `take`, `takeRight`,
  	     * `template`, `trim`, `trimEnd`, `trimStart`, and `words`
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the new mapped array.
  	     * @example
  	     *
  	     * function square(n) {
  	     *   return n * n;
  	     * }
  	     *
  	     * _.map([4, 8], square);
  	     * // => [16, 64]
  	     *
  	     * _.map({ 'a': 4, 'b': 8 }, square);
  	     * // => [16, 64] (iteration order is not guaranteed)
  	     *
  	     * var users = [
  	     *   { 'user': 'barney' },
  	     *   { 'user': 'fred' }
  	     * ];
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.map(users, 'user');
  	     * // => ['barney', 'fred']
  	     */
  	    function map(collection, iteratee) {
  	      var func = isArray(collection) ? arrayMap : baseMap;
  	      return func(collection, getIteratee(iteratee, 3));
  	    }

  	    /**
  	     * This method is like `_.sortBy` except that it allows specifying the sort
  	     * orders of the iteratees to sort by. If `orders` is unspecified, all values
  	     * are sorted in ascending order. Otherwise, specify an order of "desc" for
  	     * descending or "asc" for ascending sort order of corresponding values.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Array[]|Function[]|Object[]|string[]} [iteratees=[_.identity]]
  	     *  The iteratees to sort by.
  	     * @param {string[]} [orders] The sort orders of `iteratees`.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.reduce`.
  	     * @returns {Array} Returns the new sorted array.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'fred',   'age': 48 },
  	     *   { 'user': 'barney', 'age': 34 },
  	     *   { 'user': 'fred',   'age': 40 },
  	     *   { 'user': 'barney', 'age': 36 }
  	     * ];
  	     *
  	     * // Sort by `user` in ascending order and by `age` in descending order.
  	     * _.orderBy(users, ['user', 'age'], ['asc', 'desc']);
  	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 40]]
  	     */
  	    function orderBy(collection, iteratees, orders, guard) {
  	      if (collection == null) {
  	        return [];
  	      }
  	      if (!isArray(iteratees)) {
  	        iteratees = iteratees == null ? [] : [iteratees];
  	      }
  	      orders = guard ? undefined$1 : orders;
  	      if (!isArray(orders)) {
  	        orders = orders == null ? [] : [orders];
  	      }
  	      return baseOrderBy(collection, iteratees, orders);
  	    }

  	    /**
  	     * Creates an array of elements split into two groups, the first of which
  	     * contains elements `predicate` returns truthy for, the second of which
  	     * contains elements `predicate` returns falsey for. The predicate is
  	     * invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the array of grouped elements.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney',  'age': 36, 'active': false },
  	     *   { 'user': 'fred',    'age': 40, 'active': true },
  	     *   { 'user': 'pebbles', 'age': 1,  'active': false }
  	     * ];
  	     *
  	     * _.partition(users, function(o) { return o.active; });
  	     * // => objects for [['fred'], ['barney', 'pebbles']]
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.partition(users, { 'age': 1, 'active': false });
  	     * // => objects for [['pebbles'], ['barney', 'fred']]
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.partition(users, ['active', false]);
  	     * // => objects for [['barney', 'pebbles'], ['fred']]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.partition(users, 'active');
  	     * // => objects for [['fred'], ['barney', 'pebbles']]
  	     */
  	    var partition = createAggregator(function(result, value, key) {
  	      result[key ? 0 : 1].push(value);
  	    }, function() { return [[], []]; });

  	    /**
  	     * Reduces `collection` to a value which is the accumulated result of running
  	     * each element in `collection` thru `iteratee`, where each successive
  	     * invocation is supplied the return value of the previous. If `accumulator`
  	     * is not given, the first element of `collection` is used as the initial
  	     * value. The iteratee is invoked with four arguments:
  	     * (accumulator, value, index|key, collection).
  	     *
  	     * Many lodash methods are guarded to work as iteratees for methods like
  	     * `_.reduce`, `_.reduceRight`, and `_.transform`.
  	     *
  	     * The guarded methods are:
  	     * `assign`, `defaults`, `defaultsDeep`, `includes`, `merge`, `orderBy`,
  	     * and `sortBy`
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @param {*} [accumulator] The initial value.
  	     * @returns {*} Returns the accumulated value.
  	     * @see _.reduceRight
  	     * @example
  	     *
  	     * _.reduce([1, 2], function(sum, n) {
  	     *   return sum + n;
  	     * }, 0);
  	     * // => 3
  	     *
  	     * _.reduce({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
  	     *   (result[value] || (result[value] = [])).push(key);
  	     *   return result;
  	     * }, {});
  	     * // => { '1': ['a', 'c'], '2': ['b'] } (iteration order is not guaranteed)
  	     */
  	    function reduce(collection, iteratee, accumulator) {
  	      var func = isArray(collection) ? arrayReduce : baseReduce,
  	          initAccum = arguments.length < 3;

  	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEach);
  	    }

  	    /**
  	     * This method is like `_.reduce` except that it iterates over elements of
  	     * `collection` from right to left.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @param {*} [accumulator] The initial value.
  	     * @returns {*} Returns the accumulated value.
  	     * @see _.reduce
  	     * @example
  	     *
  	     * var array = [[0, 1], [2, 3], [4, 5]];
  	     *
  	     * _.reduceRight(array, function(flattened, other) {
  	     *   return flattened.concat(other);
  	     * }, []);
  	     * // => [4, 5, 2, 3, 0, 1]
  	     */
  	    function reduceRight(collection, iteratee, accumulator) {
  	      var func = isArray(collection) ? arrayReduceRight : baseReduce,
  	          initAccum = arguments.length < 3;

  	      return func(collection, getIteratee(iteratee, 4), accumulator, initAccum, baseEachRight);
  	    }

  	    /**
  	     * The opposite of `_.filter`; this method returns the elements of `collection`
  	     * that `predicate` does **not** return truthy for.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the new filtered array.
  	     * @see _.filter
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney', 'age': 36, 'active': false },
  	     *   { 'user': 'fred',   'age': 40, 'active': true }
  	     * ];
  	     *
  	     * _.reject(users, function(o) { return !o.active; });
  	     * // => objects for ['fred']
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.reject(users, { 'age': 40, 'active': true });
  	     * // => objects for ['barney']
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.reject(users, ['active', false]);
  	     * // => objects for ['fred']
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.reject(users, 'active');
  	     * // => objects for ['barney']
  	     */
  	    function reject(collection, predicate) {
  	      var func = isArray(collection) ? arrayFilter : baseFilter;
  	      return func(collection, negate(getIteratee(predicate, 3)));
  	    }

  	    /**
  	     * Gets a random element from `collection`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to sample.
  	     * @returns {*} Returns the random element.
  	     * @example
  	     *
  	     * _.sample([1, 2, 3, 4]);
  	     * // => 2
  	     */
  	    function sample(collection) {
  	      var func = isArray(collection) ? arraySample : baseSample;
  	      return func(collection);
  	    }

  	    /**
  	     * Gets `n` random elements at unique keys from `collection` up to the
  	     * size of `collection`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to sample.
  	     * @param {number} [n=1] The number of elements to sample.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the random elements.
  	     * @example
  	     *
  	     * _.sampleSize([1, 2, 3], 2);
  	     * // => [3, 1]
  	     *
  	     * _.sampleSize([1, 2, 3], 4);
  	     * // => [2, 3, 1]
  	     */
  	    function sampleSize(collection, n, guard) {
  	      if ((guard ? isIterateeCall(collection, n, guard) : n === undefined$1)) {
  	        n = 1;
  	      } else {
  	        n = toInteger(n);
  	      }
  	      var func = isArray(collection) ? arraySampleSize : baseSampleSize;
  	      return func(collection, n);
  	    }

  	    /**
  	     * Creates an array of shuffled values, using a version of the
  	     * [Fisher-Yates shuffle](https://en.wikipedia.org/wiki/Fisher-Yates_shuffle).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to shuffle.
  	     * @returns {Array} Returns the new shuffled array.
  	     * @example
  	     *
  	     * _.shuffle([1, 2, 3, 4]);
  	     * // => [4, 1, 3, 2]
  	     */
  	    function shuffle(collection) {
  	      var func = isArray(collection) ? arrayShuffle : baseShuffle;
  	      return func(collection);
  	    }

  	    /**
  	     * Gets the size of `collection` by returning its length for array-like
  	     * values or the number of own enumerable string keyed properties for objects.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object|string} collection The collection to inspect.
  	     * @returns {number} Returns the collection size.
  	     * @example
  	     *
  	     * _.size([1, 2, 3]);
  	     * // => 3
  	     *
  	     * _.size({ 'a': 1, 'b': 2 });
  	     * // => 2
  	     *
  	     * _.size('pebbles');
  	     * // => 7
  	     */
  	    function size(collection) {
  	      if (collection == null) {
  	        return 0;
  	      }
  	      if (isArrayLike(collection)) {
  	        return isString(collection) ? stringSize(collection) : collection.length;
  	      }
  	      var tag = getTag(collection);
  	      if (tag == mapTag || tag == setTag) {
  	        return collection.size;
  	      }
  	      return baseKeys(collection).length;
  	    }

  	    /**
  	     * Checks if `predicate` returns truthy for **any** element of `collection`.
  	     * Iteration is stopped once `predicate` returns truthy. The predicate is
  	     * invoked with three arguments: (value, index|key, collection).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {boolean} Returns `true` if any element passes the predicate check,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.some([null, 0, 'yes', false], Boolean);
  	     * // => true
  	     *
  	     * var users = [
  	     *   { 'user': 'barney', 'active': true },
  	     *   { 'user': 'fred',   'active': false }
  	     * ];
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.some(users, { 'user': 'barney', 'active': false });
  	     * // => false
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.some(users, ['active', false]);
  	     * // => true
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.some(users, 'active');
  	     * // => true
  	     */
  	    function some(collection, predicate, guard) {
  	      var func = isArray(collection) ? arraySome : baseSome;
  	      if (guard && isIterateeCall(collection, predicate, guard)) {
  	        predicate = undefined$1;
  	      }
  	      return func(collection, getIteratee(predicate, 3));
  	    }

  	    /**
  	     * Creates an array of elements, sorted in ascending order by the results of
  	     * running each element in a collection thru each iteratee. This method
  	     * performs a stable sort, that is, it preserves the original sort order of
  	     * equal elements. The iteratees are invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Collection
  	     * @param {Array|Object} collection The collection to iterate over.
  	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
  	     *  The iteratees to sort by.
  	     * @returns {Array} Returns the new sorted array.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'fred',   'age': 48 },
  	     *   { 'user': 'barney', 'age': 36 },
  	     *   { 'user': 'fred',   'age': 30 },
  	     *   { 'user': 'barney', 'age': 34 }
  	     * ];
  	     *
  	     * _.sortBy(users, [function(o) { return o.user; }]);
  	     * // => objects for [['barney', 36], ['barney', 34], ['fred', 48], ['fred', 30]]
  	     *
  	     * _.sortBy(users, ['user', 'age']);
  	     * // => objects for [['barney', 34], ['barney', 36], ['fred', 30], ['fred', 48]]
  	     */
  	    var sortBy = baseRest(function(collection, iteratees) {
  	      if (collection == null) {
  	        return [];
  	      }
  	      var length = iteratees.length;
  	      if (length > 1 && isIterateeCall(collection, iteratees[0], iteratees[1])) {
  	        iteratees = [];
  	      } else if (length > 2 && isIterateeCall(iteratees[0], iteratees[1], iteratees[2])) {
  	        iteratees = [iteratees[0]];
  	      }
  	      return baseOrderBy(collection, baseFlatten(iteratees, 1), []);
  	    });

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Gets the timestamp of the number of milliseconds that have elapsed since
  	     * the Unix epoch (1 January 1970 00:00:00 UTC).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.4.0
  	     * @category Date
  	     * @returns {number} Returns the timestamp.
  	     * @example
  	     *
  	     * _.defer(function(stamp) {
  	     *   console.log(_.now() - stamp);
  	     * }, _.now());
  	     * // => Logs the number of milliseconds it took for the deferred invocation.
  	     */
  	    var now = ctxNow || function() {
  	      return root.Date.now();
  	    };

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * The opposite of `_.before`; this method creates a function that invokes
  	     * `func` once it's called `n` or more times.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {number} n The number of calls before `func` is invoked.
  	     * @param {Function} func The function to restrict.
  	     * @returns {Function} Returns the new restricted function.
  	     * @example
  	     *
  	     * var saves = ['profile', 'settings'];
  	     *
  	     * var done = _.after(saves.length, function() {
  	     *   console.log('done saving!');
  	     * });
  	     *
  	     * _.forEach(saves, function(type) {
  	     *   asyncSave({ 'type': type, 'complete': done });
  	     * });
  	     * // => Logs 'done saving!' after the two async saves have completed.
  	     */
  	    function after(n, func) {
  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      n = toInteger(n);
  	      return function() {
  	        if (--n < 1) {
  	          return func.apply(this, arguments);
  	        }
  	      };
  	    }

  	    /**
  	     * Creates a function that invokes `func`, with up to `n` arguments,
  	     * ignoring any additional arguments.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Function
  	     * @param {Function} func The function to cap arguments for.
  	     * @param {number} [n=func.length] The arity cap.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Function} Returns the new capped function.
  	     * @example
  	     *
  	     * _.map(['6', '8', '10'], _.ary(parseInt, 1));
  	     * // => [6, 8, 10]
  	     */
  	    function ary(func, n, guard) {
  	      n = guard ? undefined$1 : n;
  	      n = (func && n == null) ? func.length : n;
  	      return createWrap(func, WRAP_ARY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, n);
  	    }

  	    /**
  	     * Creates a function that invokes `func`, with the `this` binding and arguments
  	     * of the created function, while it's called less than `n` times. Subsequent
  	     * calls to the created function return the result of the last `func` invocation.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Function
  	     * @param {number} n The number of calls at which `func` is no longer invoked.
  	     * @param {Function} func The function to restrict.
  	     * @returns {Function} Returns the new restricted function.
  	     * @example
  	     *
  	     * jQuery(element).on('click', _.before(5, addContactToList));
  	     * // => Allows adding up to 4 contacts to the list.
  	     */
  	    function before(n, func) {
  	      var result;
  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      n = toInteger(n);
  	      return function() {
  	        if (--n > 0) {
  	          result = func.apply(this, arguments);
  	        }
  	        if (n <= 1) {
  	          func = undefined$1;
  	        }
  	        return result;
  	      };
  	    }

  	    /**
  	     * Creates a function that invokes `func` with the `this` binding of `thisArg`
  	     * and `partials` prepended to the arguments it receives.
  	     *
  	     * The `_.bind.placeholder` value, which defaults to `_` in monolithic builds,
  	     * may be used as a placeholder for partially applied arguments.
  	     *
  	     * **Note:** Unlike native `Function#bind`, this method doesn't set the "length"
  	     * property of bound functions.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to bind.
  	     * @param {*} thisArg The `this` binding of `func`.
  	     * @param {...*} [partials] The arguments to be partially applied.
  	     * @returns {Function} Returns the new bound function.
  	     * @example
  	     *
  	     * function greet(greeting, punctuation) {
  	     *   return greeting + ' ' + this.user + punctuation;
  	     * }
  	     *
  	     * var object = { 'user': 'fred' };
  	     *
  	     * var bound = _.bind(greet, object, 'hi');
  	     * bound('!');
  	     * // => 'hi fred!'
  	     *
  	     * // Bound with placeholders.
  	     * var bound = _.bind(greet, object, _, '!');
  	     * bound('hi');
  	     * // => 'hi fred!'
  	     */
  	    var bind = baseRest(function(func, thisArg, partials) {
  	      var bitmask = WRAP_BIND_FLAG;
  	      if (partials.length) {
  	        var holders = replaceHolders(partials, getHolder(bind));
  	        bitmask |= WRAP_PARTIAL_FLAG;
  	      }
  	      return createWrap(func, bitmask, thisArg, partials, holders);
  	    });

  	    /**
  	     * Creates a function that invokes the method at `object[key]` with `partials`
  	     * prepended to the arguments it receives.
  	     *
  	     * This method differs from `_.bind` by allowing bound functions to reference
  	     * methods that may be redefined or don't yet exist. See
  	     * [Peter Michaux's article](http://peter.michaux.ca/articles/lazy-function-definition-pattern)
  	     * for more details.
  	     *
  	     * The `_.bindKey.placeholder` value, which defaults to `_` in monolithic
  	     * builds, may be used as a placeholder for partially applied arguments.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.10.0
  	     * @category Function
  	     * @param {Object} object The object to invoke the method on.
  	     * @param {string} key The key of the method.
  	     * @param {...*} [partials] The arguments to be partially applied.
  	     * @returns {Function} Returns the new bound function.
  	     * @example
  	     *
  	     * var object = {
  	     *   'user': 'fred',
  	     *   'greet': function(greeting, punctuation) {
  	     *     return greeting + ' ' + this.user + punctuation;
  	     *   }
  	     * };
  	     *
  	     * var bound = _.bindKey(object, 'greet', 'hi');
  	     * bound('!');
  	     * // => 'hi fred!'
  	     *
  	     * object.greet = function(greeting, punctuation) {
  	     *   return greeting + 'ya ' + this.user + punctuation;
  	     * };
  	     *
  	     * bound('!');
  	     * // => 'hiya fred!'
  	     *
  	     * // Bound with placeholders.
  	     * var bound = _.bindKey(object, 'greet', _, '!');
  	     * bound('hi');
  	     * // => 'hiya fred!'
  	     */
  	    var bindKey = baseRest(function(object, key, partials) {
  	      var bitmask = WRAP_BIND_FLAG | WRAP_BIND_KEY_FLAG;
  	      if (partials.length) {
  	        var holders = replaceHolders(partials, getHolder(bindKey));
  	        bitmask |= WRAP_PARTIAL_FLAG;
  	      }
  	      return createWrap(key, bitmask, object, partials, holders);
  	    });

  	    /**
  	     * Creates a function that accepts arguments of `func` and either invokes
  	     * `func` returning its result, if at least `arity` number of arguments have
  	     * been provided, or returns a function that accepts the remaining `func`
  	     * arguments, and so on. The arity of `func` may be specified if `func.length`
  	     * is not sufficient.
  	     *
  	     * The `_.curry.placeholder` value, which defaults to `_` in monolithic builds,
  	     * may be used as a placeholder for provided arguments.
  	     *
  	     * **Note:** This method doesn't set the "length" property of curried functions.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Function
  	     * @param {Function} func The function to curry.
  	     * @param {number} [arity=func.length] The arity of `func`.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Function} Returns the new curried function.
  	     * @example
  	     *
  	     * var abc = function(a, b, c) {
  	     *   return [a, b, c];
  	     * };
  	     *
  	     * var curried = _.curry(abc);
  	     *
  	     * curried(1)(2)(3);
  	     * // => [1, 2, 3]
  	     *
  	     * curried(1, 2)(3);
  	     * // => [1, 2, 3]
  	     *
  	     * curried(1, 2, 3);
  	     * // => [1, 2, 3]
  	     *
  	     * // Curried with placeholders.
  	     * curried(1)(_, 3)(2);
  	     * // => [1, 2, 3]
  	     */
  	    function curry(func, arity, guard) {
  	      arity = guard ? undefined$1 : arity;
  	      var result = createWrap(func, WRAP_CURRY_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
  	      result.placeholder = curry.placeholder;
  	      return result;
  	    }

  	    /**
  	     * This method is like `_.curry` except that arguments are applied to `func`
  	     * in the manner of `_.partialRight` instead of `_.partial`.
  	     *
  	     * The `_.curryRight.placeholder` value, which defaults to `_` in monolithic
  	     * builds, may be used as a placeholder for provided arguments.
  	     *
  	     * **Note:** This method doesn't set the "length" property of curried functions.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Function
  	     * @param {Function} func The function to curry.
  	     * @param {number} [arity=func.length] The arity of `func`.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Function} Returns the new curried function.
  	     * @example
  	     *
  	     * var abc = function(a, b, c) {
  	     *   return [a, b, c];
  	     * };
  	     *
  	     * var curried = _.curryRight(abc);
  	     *
  	     * curried(3)(2)(1);
  	     * // => [1, 2, 3]
  	     *
  	     * curried(2, 3)(1);
  	     * // => [1, 2, 3]
  	     *
  	     * curried(1, 2, 3);
  	     * // => [1, 2, 3]
  	     *
  	     * // Curried with placeholders.
  	     * curried(3)(1, _)(2);
  	     * // => [1, 2, 3]
  	     */
  	    function curryRight(func, arity, guard) {
  	      arity = guard ? undefined$1 : arity;
  	      var result = createWrap(func, WRAP_CURRY_RIGHT_FLAG, undefined$1, undefined$1, undefined$1, undefined$1, undefined$1, arity);
  	      result.placeholder = curryRight.placeholder;
  	      return result;
  	    }

  	    /**
  	     * Creates a debounced function that delays invoking `func` until after `wait`
  	     * milliseconds have elapsed since the last time the debounced function was
  	     * invoked. The debounced function comes with a `cancel` method to cancel
  	     * delayed `func` invocations and a `flush` method to immediately invoke them.
  	     * Provide `options` to indicate whether `func` should be invoked on the
  	     * leading and/or trailing edge of the `wait` timeout. The `func` is invoked
  	     * with the last arguments provided to the debounced function. Subsequent
  	     * calls to the debounced function return the result of the last `func`
  	     * invocation.
  	     *
  	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
  	     * invoked on the trailing edge of the timeout only if the debounced function
  	     * is invoked more than once during the `wait` timeout.
  	     *
  	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
  	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
  	     *
  	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
  	     * for details over the differences between `_.debounce` and `_.throttle`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to debounce.
  	     * @param {number} [wait=0] The number of milliseconds to delay.
  	     * @param {Object} [options={}] The options object.
  	     * @param {boolean} [options.leading=false]
  	     *  Specify invoking on the leading edge of the timeout.
  	     * @param {number} [options.maxWait]
  	     *  The maximum time `func` is allowed to be delayed before it's invoked.
  	     * @param {boolean} [options.trailing=true]
  	     *  Specify invoking on the trailing edge of the timeout.
  	     * @returns {Function} Returns the new debounced function.
  	     * @example
  	     *
  	     * // Avoid costly calculations while the window size is in flux.
  	     * jQuery(window).on('resize', _.debounce(calculateLayout, 150));
  	     *
  	     * // Invoke `sendMail` when clicked, debouncing subsequent calls.
  	     * jQuery(element).on('click', _.debounce(sendMail, 300, {
  	     *   'leading': true,
  	     *   'trailing': false
  	     * }));
  	     *
  	     * // Ensure `batchLog` is invoked once after 1 second of debounced calls.
  	     * var debounced = _.debounce(batchLog, 250, { 'maxWait': 1000 });
  	     * var source = new EventSource('/stream');
  	     * jQuery(source).on('message', debounced);
  	     *
  	     * // Cancel the trailing debounced invocation.
  	     * jQuery(window).on('popstate', debounced.cancel);
  	     */
  	    function debounce(func, wait, options) {
  	      var lastArgs,
  	          lastThis,
  	          maxWait,
  	          result,
  	          timerId,
  	          lastCallTime,
  	          lastInvokeTime = 0,
  	          leading = false,
  	          maxing = false,
  	          trailing = true;

  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      wait = toNumber(wait) || 0;
  	      if (isObject(options)) {
  	        leading = !!options.leading;
  	        maxing = 'maxWait' in options;
  	        maxWait = maxing ? nativeMax(toNumber(options.maxWait) || 0, wait) : maxWait;
  	        trailing = 'trailing' in options ? !!options.trailing : trailing;
  	      }

  	      function invokeFunc(time) {
  	        var args = lastArgs,
  	            thisArg = lastThis;

  	        lastArgs = lastThis = undefined$1;
  	        lastInvokeTime = time;
  	        result = func.apply(thisArg, args);
  	        return result;
  	      }

  	      function leadingEdge(time) {
  	        // Reset any `maxWait` timer.
  	        lastInvokeTime = time;
  	        // Start the timer for the trailing edge.
  	        timerId = setTimeout(timerExpired, wait);
  	        // Invoke the leading edge.
  	        return leading ? invokeFunc(time) : result;
  	      }

  	      function remainingWait(time) {
  	        var timeSinceLastCall = time - lastCallTime,
  	            timeSinceLastInvoke = time - lastInvokeTime,
  	            timeWaiting = wait - timeSinceLastCall;

  	        return maxing
  	          ? nativeMin(timeWaiting, maxWait - timeSinceLastInvoke)
  	          : timeWaiting;
  	      }

  	      function shouldInvoke(time) {
  	        var timeSinceLastCall = time - lastCallTime,
  	            timeSinceLastInvoke = time - lastInvokeTime;

  	        // Either this is the first call, activity has stopped and we're at the
  	        // trailing edge, the system time has gone backwards and we're treating
  	        // it as the trailing edge, or we've hit the `maxWait` limit.
  	        return (lastCallTime === undefined$1 || (timeSinceLastCall >= wait) ||
  	          (timeSinceLastCall < 0) || (maxing && timeSinceLastInvoke >= maxWait));
  	      }

  	      function timerExpired() {
  	        var time = now();
  	        if (shouldInvoke(time)) {
  	          return trailingEdge(time);
  	        }
  	        // Restart the timer.
  	        timerId = setTimeout(timerExpired, remainingWait(time));
  	      }

  	      function trailingEdge(time) {
  	        timerId = undefined$1;

  	        // Only invoke if we have `lastArgs` which means `func` has been
  	        // debounced at least once.
  	        if (trailing && lastArgs) {
  	          return invokeFunc(time);
  	        }
  	        lastArgs = lastThis = undefined$1;
  	        return result;
  	      }

  	      function cancel() {
  	        if (timerId !== undefined$1) {
  	          clearTimeout(timerId);
  	        }
  	        lastInvokeTime = 0;
  	        lastArgs = lastCallTime = lastThis = timerId = undefined$1;
  	      }

  	      function flush() {
  	        return timerId === undefined$1 ? result : trailingEdge(now());
  	      }

  	      function debounced() {
  	        var time = now(),
  	            isInvoking = shouldInvoke(time);

  	        lastArgs = arguments;
  	        lastThis = this;
  	        lastCallTime = time;

  	        if (isInvoking) {
  	          if (timerId === undefined$1) {
  	            return leadingEdge(lastCallTime);
  	          }
  	          if (maxing) {
  	            // Handle invocations in a tight loop.
  	            clearTimeout(timerId);
  	            timerId = setTimeout(timerExpired, wait);
  	            return invokeFunc(lastCallTime);
  	          }
  	        }
  	        if (timerId === undefined$1) {
  	          timerId = setTimeout(timerExpired, wait);
  	        }
  	        return result;
  	      }
  	      debounced.cancel = cancel;
  	      debounced.flush = flush;
  	      return debounced;
  	    }

  	    /**
  	     * Defers invoking the `func` until the current call stack has cleared. Any
  	     * additional arguments are provided to `func` when it's invoked.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to defer.
  	     * @param {...*} [args] The arguments to invoke `func` with.
  	     * @returns {number} Returns the timer id.
  	     * @example
  	     *
  	     * _.defer(function(text) {
  	     *   console.log(text);
  	     * }, 'deferred');
  	     * // => Logs 'deferred' after one millisecond.
  	     */
  	    var defer = baseRest(function(func, args) {
  	      return baseDelay(func, 1, args);
  	    });

  	    /**
  	     * Invokes `func` after `wait` milliseconds. Any additional arguments are
  	     * provided to `func` when it's invoked.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to delay.
  	     * @param {number} wait The number of milliseconds to delay invocation.
  	     * @param {...*} [args] The arguments to invoke `func` with.
  	     * @returns {number} Returns the timer id.
  	     * @example
  	     *
  	     * _.delay(function(text) {
  	     *   console.log(text);
  	     * }, 1000, 'later');
  	     * // => Logs 'later' after one second.
  	     */
  	    var delay = baseRest(function(func, wait, args) {
  	      return baseDelay(func, toNumber(wait) || 0, args);
  	    });

  	    /**
  	     * Creates a function that invokes `func` with arguments reversed.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Function
  	     * @param {Function} func The function to flip arguments for.
  	     * @returns {Function} Returns the new flipped function.
  	     * @example
  	     *
  	     * var flipped = _.flip(function() {
  	     *   return _.toArray(arguments);
  	     * });
  	     *
  	     * flipped('a', 'b', 'c', 'd');
  	     * // => ['d', 'c', 'b', 'a']
  	     */
  	    function flip(func) {
  	      return createWrap(func, WRAP_FLIP_FLAG);
  	    }

  	    /**
  	     * Creates a function that memoizes the result of `func`. If `resolver` is
  	     * provided, it determines the cache key for storing the result based on the
  	     * arguments provided to the memoized function. By default, the first argument
  	     * provided to the memoized function is used as the map cache key. The `func`
  	     * is invoked with the `this` binding of the memoized function.
  	     *
  	     * **Note:** The cache is exposed as the `cache` property on the memoized
  	     * function. Its creation may be customized by replacing the `_.memoize.Cache`
  	     * constructor with one whose instances implement the
  	     * [`Map`](http://ecma-international.org/ecma-262/7.0/#sec-properties-of-the-map-prototype-object)
  	     * method interface of `clear`, `delete`, `get`, `has`, and `set`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to have its output memoized.
  	     * @param {Function} [resolver] The function to resolve the cache key.
  	     * @returns {Function} Returns the new memoized function.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': 2 };
  	     * var other = { 'c': 3, 'd': 4 };
  	     *
  	     * var values = _.memoize(_.values);
  	     * values(object);
  	     * // => [1, 2]
  	     *
  	     * values(other);
  	     * // => [3, 4]
  	     *
  	     * object.a = 2;
  	     * values(object);
  	     * // => [1, 2]
  	     *
  	     * // Modify the result cache.
  	     * values.cache.set(object, ['a', 'b']);
  	     * values(object);
  	     * // => ['a', 'b']
  	     *
  	     * // Replace `_.memoize.Cache`.
  	     * _.memoize.Cache = WeakMap;
  	     */
  	    function memoize(func, resolver) {
  	      if (typeof func != 'function' || (resolver != null && typeof resolver != 'function')) {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      var memoized = function() {
  	        var args = arguments,
  	            key = resolver ? resolver.apply(this, args) : args[0],
  	            cache = memoized.cache;

  	        if (cache.has(key)) {
  	          return cache.get(key);
  	        }
  	        var result = func.apply(this, args);
  	        memoized.cache = cache.set(key, result) || cache;
  	        return result;
  	      };
  	      memoized.cache = new (memoize.Cache || MapCache);
  	      return memoized;
  	    }

  	    // Expose `MapCache`.
  	    memoize.Cache = MapCache;

  	    /**
  	     * Creates a function that negates the result of the predicate `func`. The
  	     * `func` predicate is invoked with the `this` binding and arguments of the
  	     * created function.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Function
  	     * @param {Function} predicate The predicate to negate.
  	     * @returns {Function} Returns the new negated function.
  	     * @example
  	     *
  	     * function isEven(n) {
  	     *   return n % 2 == 0;
  	     * }
  	     *
  	     * _.filter([1, 2, 3, 4, 5, 6], _.negate(isEven));
  	     * // => [1, 3, 5]
  	     */
  	    function negate(predicate) {
  	      if (typeof predicate != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      return function() {
  	        var args = arguments;
  	        switch (args.length) {
  	          case 0: return !predicate.call(this);
  	          case 1: return !predicate.call(this, args[0]);
  	          case 2: return !predicate.call(this, args[0], args[1]);
  	          case 3: return !predicate.call(this, args[0], args[1], args[2]);
  	        }
  	        return !predicate.apply(this, args);
  	      };
  	    }

  	    /**
  	     * Creates a function that is restricted to invoking `func` once. Repeat calls
  	     * to the function return the value of the first invocation. The `func` is
  	     * invoked with the `this` binding and arguments of the created function.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to restrict.
  	     * @returns {Function} Returns the new restricted function.
  	     * @example
  	     *
  	     * var initialize = _.once(createApplication);
  	     * initialize();
  	     * initialize();
  	     * // => `createApplication` is invoked once
  	     */
  	    function once(func) {
  	      return before(2, func);
  	    }

  	    /**
  	     * Creates a function that invokes `func` with its arguments transformed.
  	     *
  	     * @static
  	     * @since 4.0.0
  	     * @memberOf _
  	     * @category Function
  	     * @param {Function} func The function to wrap.
  	     * @param {...(Function|Function[])} [transforms=[_.identity]]
  	     *  The argument transforms.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * function doubled(n) {
  	     *   return n * 2;
  	     * }
  	     *
  	     * function square(n) {
  	     *   return n * n;
  	     * }
  	     *
  	     * var func = _.overArgs(function(x, y) {
  	     *   return [x, y];
  	     * }, [square, doubled]);
  	     *
  	     * func(9, 3);
  	     * // => [81, 6]
  	     *
  	     * func(10, 5);
  	     * // => [100, 10]
  	     */
  	    var overArgs = castRest(function(func, transforms) {
  	      transforms = (transforms.length == 1 && isArray(transforms[0]))
  	        ? arrayMap(transforms[0], baseUnary(getIteratee()))
  	        : arrayMap(baseFlatten(transforms, 1), baseUnary(getIteratee()));

  	      var funcsLength = transforms.length;
  	      return baseRest(function(args) {
  	        var index = -1,
  	            length = nativeMin(args.length, funcsLength);

  	        while (++index < length) {
  	          args[index] = transforms[index].call(this, args[index]);
  	        }
  	        return apply(func, this, args);
  	      });
  	    });

  	    /**
  	     * Creates a function that invokes `func` with `partials` prepended to the
  	     * arguments it receives. This method is like `_.bind` except it does **not**
  	     * alter the `this` binding.
  	     *
  	     * The `_.partial.placeholder` value, which defaults to `_` in monolithic
  	     * builds, may be used as a placeholder for partially applied arguments.
  	     *
  	     * **Note:** This method doesn't set the "length" property of partially
  	     * applied functions.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.2.0
  	     * @category Function
  	     * @param {Function} func The function to partially apply arguments to.
  	     * @param {...*} [partials] The arguments to be partially applied.
  	     * @returns {Function} Returns the new partially applied function.
  	     * @example
  	     *
  	     * function greet(greeting, name) {
  	     *   return greeting + ' ' + name;
  	     * }
  	     *
  	     * var sayHelloTo = _.partial(greet, 'hello');
  	     * sayHelloTo('fred');
  	     * // => 'hello fred'
  	     *
  	     * // Partially applied with placeholders.
  	     * var greetFred = _.partial(greet, _, 'fred');
  	     * greetFred('hi');
  	     * // => 'hi fred'
  	     */
  	    var partial = baseRest(function(func, partials) {
  	      var holders = replaceHolders(partials, getHolder(partial));
  	      return createWrap(func, WRAP_PARTIAL_FLAG, undefined$1, partials, holders);
  	    });

  	    /**
  	     * This method is like `_.partial` except that partially applied arguments
  	     * are appended to the arguments it receives.
  	     *
  	     * The `_.partialRight.placeholder` value, which defaults to `_` in monolithic
  	     * builds, may be used as a placeholder for partially applied arguments.
  	     *
  	     * **Note:** This method doesn't set the "length" property of partially
  	     * applied functions.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.0.0
  	     * @category Function
  	     * @param {Function} func The function to partially apply arguments to.
  	     * @param {...*} [partials] The arguments to be partially applied.
  	     * @returns {Function} Returns the new partially applied function.
  	     * @example
  	     *
  	     * function greet(greeting, name) {
  	     *   return greeting + ' ' + name;
  	     * }
  	     *
  	     * var greetFred = _.partialRight(greet, 'fred');
  	     * greetFred('hi');
  	     * // => 'hi fred'
  	     *
  	     * // Partially applied with placeholders.
  	     * var sayHelloTo = _.partialRight(greet, 'hello', _);
  	     * sayHelloTo('fred');
  	     * // => 'hello fred'
  	     */
  	    var partialRight = baseRest(function(func, partials) {
  	      var holders = replaceHolders(partials, getHolder(partialRight));
  	      return createWrap(func, WRAP_PARTIAL_RIGHT_FLAG, undefined$1, partials, holders);
  	    });

  	    /**
  	     * Creates a function that invokes `func` with arguments arranged according
  	     * to the specified `indexes` where the argument value at the first index is
  	     * provided as the first argument, the argument value at the second index is
  	     * provided as the second argument, and so on.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Function
  	     * @param {Function} func The function to rearrange arguments for.
  	     * @param {...(number|number[])} indexes The arranged argument indexes.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var rearged = _.rearg(function(a, b, c) {
  	     *   return [a, b, c];
  	     * }, [2, 0, 1]);
  	     *
  	     * rearged('b', 'c', 'a')
  	     * // => ['a', 'b', 'c']
  	     */
  	    var rearg = flatRest(function(func, indexes) {
  	      return createWrap(func, WRAP_REARG_FLAG, undefined$1, undefined$1, undefined$1, indexes);
  	    });

  	    /**
  	     * Creates a function that invokes `func` with the `this` binding of the
  	     * created function and arguments from `start` and beyond provided as
  	     * an array.
  	     *
  	     * **Note:** This method is based on the
  	     * [rest parameter](https://mdn.io/rest_parameters).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Function
  	     * @param {Function} func The function to apply a rest parameter to.
  	     * @param {number} [start=func.length-1] The start position of the rest parameter.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var say = _.rest(function(what, names) {
  	     *   return what + ' ' + _.initial(names).join(', ') +
  	     *     (_.size(names) > 1 ? ', & ' : '') + _.last(names);
  	     * });
  	     *
  	     * say('hello', 'fred', 'barney', 'pebbles');
  	     * // => 'hello fred, barney, & pebbles'
  	     */
  	    function rest(func, start) {
  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      start = start === undefined$1 ? start : toInteger(start);
  	      return baseRest(func, start);
  	    }

  	    /**
  	     * Creates a function that invokes `func` with the `this` binding of the
  	     * create function and an array of arguments much like
  	     * [`Function#apply`](http://www.ecma-international.org/ecma-262/7.0/#sec-function.prototype.apply).
  	     *
  	     * **Note:** This method is based on the
  	     * [spread operator](https://mdn.io/spread_operator).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.2.0
  	     * @category Function
  	     * @param {Function} func The function to spread arguments over.
  	     * @param {number} [start=0] The start position of the spread.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var say = _.spread(function(who, what) {
  	     *   return who + ' says ' + what;
  	     * });
  	     *
  	     * say(['fred', 'hello']);
  	     * // => 'fred says hello'
  	     *
  	     * var numbers = Promise.all([
  	     *   Promise.resolve(40),
  	     *   Promise.resolve(36)
  	     * ]);
  	     *
  	     * numbers.then(_.spread(function(x, y) {
  	     *   return x + y;
  	     * }));
  	     * // => a Promise of 76
  	     */
  	    function spread(func, start) {
  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      start = start == null ? 0 : nativeMax(toInteger(start), 0);
  	      return baseRest(function(args) {
  	        var array = args[start],
  	            otherArgs = castSlice(args, 0, start);

  	        if (array) {
  	          arrayPush(otherArgs, array);
  	        }
  	        return apply(func, this, otherArgs);
  	      });
  	    }

  	    /**
  	     * Creates a throttled function that only invokes `func` at most once per
  	     * every `wait` milliseconds. The throttled function comes with a `cancel`
  	     * method to cancel delayed `func` invocations and a `flush` method to
  	     * immediately invoke them. Provide `options` to indicate whether `func`
  	     * should be invoked on the leading and/or trailing edge of the `wait`
  	     * timeout. The `func` is invoked with the last arguments provided to the
  	     * throttled function. Subsequent calls to the throttled function return the
  	     * result of the last `func` invocation.
  	     *
  	     * **Note:** If `leading` and `trailing` options are `true`, `func` is
  	     * invoked on the trailing edge of the timeout only if the throttled function
  	     * is invoked more than once during the `wait` timeout.
  	     *
  	     * If `wait` is `0` and `leading` is `false`, `func` invocation is deferred
  	     * until to the next tick, similar to `setTimeout` with a timeout of `0`.
  	     *
  	     * See [David Corbacho's article](https://css-tricks.com/debouncing-throttling-explained-examples/)
  	     * for details over the differences between `_.throttle` and `_.debounce`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {Function} func The function to throttle.
  	     * @param {number} [wait=0] The number of milliseconds to throttle invocations to.
  	     * @param {Object} [options={}] The options object.
  	     * @param {boolean} [options.leading=true]
  	     *  Specify invoking on the leading edge of the timeout.
  	     * @param {boolean} [options.trailing=true]
  	     *  Specify invoking on the trailing edge of the timeout.
  	     * @returns {Function} Returns the new throttled function.
  	     * @example
  	     *
  	     * // Avoid excessively updating the position while scrolling.
  	     * jQuery(window).on('scroll', _.throttle(updatePosition, 100));
  	     *
  	     * // Invoke `renewToken` when the click event is fired, but not more than once every 5 minutes.
  	     * var throttled = _.throttle(renewToken, 300000, { 'trailing': false });
  	     * jQuery(element).on('click', throttled);
  	     *
  	     * // Cancel the trailing throttled invocation.
  	     * jQuery(window).on('popstate', throttled.cancel);
  	     */
  	    function throttle(func, wait, options) {
  	      var leading = true,
  	          trailing = true;

  	      if (typeof func != 'function') {
  	        throw new TypeError(FUNC_ERROR_TEXT);
  	      }
  	      if (isObject(options)) {
  	        leading = 'leading' in options ? !!options.leading : leading;
  	        trailing = 'trailing' in options ? !!options.trailing : trailing;
  	      }
  	      return debounce(func, wait, {
  	        'leading': leading,
  	        'maxWait': wait,
  	        'trailing': trailing
  	      });
  	    }

  	    /**
  	     * Creates a function that accepts up to one argument, ignoring any
  	     * additional arguments.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Function
  	     * @param {Function} func The function to cap arguments for.
  	     * @returns {Function} Returns the new capped function.
  	     * @example
  	     *
  	     * _.map(['6', '8', '10'], _.unary(parseInt));
  	     * // => [6, 8, 10]
  	     */
  	    function unary(func) {
  	      return ary(func, 1);
  	    }

  	    /**
  	     * Creates a function that provides `value` to `wrapper` as its first
  	     * argument. Any additional arguments provided to the function are appended
  	     * to those provided to the `wrapper`. The wrapper is invoked with the `this`
  	     * binding of the created function.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Function
  	     * @param {*} value The value to wrap.
  	     * @param {Function} [wrapper=identity] The wrapper function.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var p = _.wrap(_.escape, function(func, text) {
  	     *   return '<p>' + func(text) + '</p>';
  	     * });
  	     *
  	     * p('fred, barney, & pebbles');
  	     * // => '<p>fred, barney, &amp; pebbles</p>'
  	     */
  	    function wrap(value, wrapper) {
  	      return partial(castFunction(wrapper), value);
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Casts `value` as an array if it's not one.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.4.0
  	     * @category Lang
  	     * @param {*} value The value to inspect.
  	     * @returns {Array} Returns the cast array.
  	     * @example
  	     *
  	     * _.castArray(1);
  	     * // => [1]
  	     *
  	     * _.castArray({ 'a': 1 });
  	     * // => [{ 'a': 1 }]
  	     *
  	     * _.castArray('abc');
  	     * // => ['abc']
  	     *
  	     * _.castArray(null);
  	     * // => [null]
  	     *
  	     * _.castArray(undefined);
  	     * // => [undefined]
  	     *
  	     * _.castArray();
  	     * // => []
  	     *
  	     * var array = [1, 2, 3];
  	     * console.log(_.castArray(array) === array);
  	     * // => true
  	     */
  	    function castArray() {
  	      if (!arguments.length) {
  	        return [];
  	      }
  	      var value = arguments[0];
  	      return isArray(value) ? value : [value];
  	    }

  	    /**
  	     * Creates a shallow clone of `value`.
  	     *
  	     * **Note:** This method is loosely based on the
  	     * [structured clone algorithm](https://mdn.io/Structured_clone_algorithm)
  	     * and supports cloning arrays, array buffers, booleans, date objects, maps,
  	     * numbers, `Object` objects, regexes, sets, strings, symbols, and typed
  	     * arrays. The own enumerable properties of `arguments` objects are cloned
  	     * as plain objects. An empty object is returned for uncloneable values such
  	     * as error objects, functions, DOM nodes, and WeakMaps.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to clone.
  	     * @returns {*} Returns the cloned value.
  	     * @see _.cloneDeep
  	     * @example
  	     *
  	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
  	     *
  	     * var shallow = _.clone(objects);
  	     * console.log(shallow[0] === objects[0]);
  	     * // => true
  	     */
  	    function clone(value) {
  	      return baseClone(value, CLONE_SYMBOLS_FLAG);
  	    }

  	    /**
  	     * This method is like `_.clone` except that it accepts `customizer` which
  	     * is invoked to produce the cloned value. If `customizer` returns `undefined`,
  	     * cloning is handled by the method instead. The `customizer` is invoked with
  	     * up to four arguments; (value [, index|key, object, stack]).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to clone.
  	     * @param {Function} [customizer] The function to customize cloning.
  	     * @returns {*} Returns the cloned value.
  	     * @see _.cloneDeepWith
  	     * @example
  	     *
  	     * function customizer(value) {
  	     *   if (_.isElement(value)) {
  	     *     return value.cloneNode(false);
  	     *   }
  	     * }
  	     *
  	     * var el = _.cloneWith(document.body, customizer);
  	     *
  	     * console.log(el === document.body);
  	     * // => false
  	     * console.log(el.nodeName);
  	     * // => 'BODY'
  	     * console.log(el.childNodes.length);
  	     * // => 0
  	     */
  	    function cloneWith(value, customizer) {
  	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
  	      return baseClone(value, CLONE_SYMBOLS_FLAG, customizer);
  	    }

  	    /**
  	     * This method is like `_.clone` except that it recursively clones `value`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.0.0
  	     * @category Lang
  	     * @param {*} value The value to recursively clone.
  	     * @returns {*} Returns the deep cloned value.
  	     * @see _.clone
  	     * @example
  	     *
  	     * var objects = [{ 'a': 1 }, { 'b': 2 }];
  	     *
  	     * var deep = _.cloneDeep(objects);
  	     * console.log(deep[0] === objects[0]);
  	     * // => false
  	     */
  	    function cloneDeep(value) {
  	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG);
  	    }

  	    /**
  	     * This method is like `_.cloneWith` except that it recursively clones `value`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to recursively clone.
  	     * @param {Function} [customizer] The function to customize cloning.
  	     * @returns {*} Returns the deep cloned value.
  	     * @see _.cloneWith
  	     * @example
  	     *
  	     * function customizer(value) {
  	     *   if (_.isElement(value)) {
  	     *     return value.cloneNode(true);
  	     *   }
  	     * }
  	     *
  	     * var el = _.cloneDeepWith(document.body, customizer);
  	     *
  	     * console.log(el === document.body);
  	     * // => false
  	     * console.log(el.nodeName);
  	     * // => 'BODY'
  	     * console.log(el.childNodes.length);
  	     * // => 20
  	     */
  	    function cloneDeepWith(value, customizer) {
  	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
  	      return baseClone(value, CLONE_DEEP_FLAG | CLONE_SYMBOLS_FLAG, customizer);
  	    }

  	    /**
  	     * Checks if `object` conforms to `source` by invoking the predicate
  	     * properties of `source` with the corresponding property values of `object`.
  	     *
  	     * **Note:** This method is equivalent to `_.conforms` when `source` is
  	     * partially applied.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.14.0
  	     * @category Lang
  	     * @param {Object} object The object to inspect.
  	     * @param {Object} source The object of property predicates to conform to.
  	     * @returns {boolean} Returns `true` if `object` conforms, else `false`.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': 2 };
  	     *
  	     * _.conformsTo(object, { 'b': function(n) { return n > 1; } });
  	     * // => true
  	     *
  	     * _.conformsTo(object, { 'b': function(n) { return n > 2; } });
  	     * // => false
  	     */
  	    function conformsTo(object, source) {
  	      return source == null || baseConformsTo(object, source, keys(source));
  	    }

  	    /**
  	     * Performs a
  	     * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
  	     * comparison between two values to determine if they are equivalent.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
  	     * @example
  	     *
  	     * var object = { 'a': 1 };
  	     * var other = { 'a': 1 };
  	     *
  	     * _.eq(object, object);
  	     * // => true
  	     *
  	     * _.eq(object, other);
  	     * // => false
  	     *
  	     * _.eq('a', 'a');
  	     * // => true
  	     *
  	     * _.eq('a', Object('a'));
  	     * // => false
  	     *
  	     * _.eq(NaN, NaN);
  	     * // => true
  	     */
  	    function eq(value, other) {
  	      return value === other || (value !== value && other !== other);
  	    }

  	    /**
  	     * Checks if `value` is greater than `other`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.9.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if `value` is greater than `other`,
  	     *  else `false`.
  	     * @see _.lt
  	     * @example
  	     *
  	     * _.gt(3, 1);
  	     * // => true
  	     *
  	     * _.gt(3, 3);
  	     * // => false
  	     *
  	     * _.gt(1, 3);
  	     * // => false
  	     */
  	    var gt = createRelationalOperation(baseGt);

  	    /**
  	     * Checks if `value` is greater than or equal to `other`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.9.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if `value` is greater than or equal to
  	     *  `other`, else `false`.
  	     * @see _.lte
  	     * @example
  	     *
  	     * _.gte(3, 1);
  	     * // => true
  	     *
  	     * _.gte(3, 3);
  	     * // => true
  	     *
  	     * _.gte(1, 3);
  	     * // => false
  	     */
  	    var gte = createRelationalOperation(function(value, other) {
  	      return value >= other;
  	    });

  	    /**
  	     * Checks if `value` is likely an `arguments` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an `arguments` object,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.isArguments(function() { return arguments; }());
  	     * // => true
  	     *
  	     * _.isArguments([1, 2, 3]);
  	     * // => false
  	     */
  	    var isArguments = baseIsArguments(function() { return arguments; }()) ? baseIsArguments : function(value) {
  	      return isObjectLike(value) && hasOwnProperty.call(value, 'callee') &&
  	        !propertyIsEnumerable.call(value, 'callee');
  	    };

  	    /**
  	     * Checks if `value` is classified as an `Array` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an array, else `false`.
  	     * @example
  	     *
  	     * _.isArray([1, 2, 3]);
  	     * // => true
  	     *
  	     * _.isArray(document.body.children);
  	     * // => false
  	     *
  	     * _.isArray('abc');
  	     * // => false
  	     *
  	     * _.isArray(_.noop);
  	     * // => false
  	     */
  	    var isArray = Array.isArray;

  	    /**
  	     * Checks if `value` is classified as an `ArrayBuffer` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.3.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an array buffer, else `false`.
  	     * @example
  	     *
  	     * _.isArrayBuffer(new ArrayBuffer(2));
  	     * // => true
  	     *
  	     * _.isArrayBuffer(new Array(2));
  	     * // => false
  	     */
  	    var isArrayBuffer = nodeIsArrayBuffer ? baseUnary(nodeIsArrayBuffer) : baseIsArrayBuffer;

  	    /**
  	     * Checks if `value` is array-like. A value is considered array-like if it's
  	     * not a function and has a `value.length` that's an integer greater than or
  	     * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
  	     * @example
  	     *
  	     * _.isArrayLike([1, 2, 3]);
  	     * // => true
  	     *
  	     * _.isArrayLike(document.body.children);
  	     * // => true
  	     *
  	     * _.isArrayLike('abc');
  	     * // => true
  	     *
  	     * _.isArrayLike(_.noop);
  	     * // => false
  	     */
  	    function isArrayLike(value) {
  	      return value != null && isLength(value.length) && !isFunction(value);
  	    }

  	    /**
  	     * This method is like `_.isArrayLike` except that it also checks if `value`
  	     * is an object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an array-like object,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.isArrayLikeObject([1, 2, 3]);
  	     * // => true
  	     *
  	     * _.isArrayLikeObject(document.body.children);
  	     * // => true
  	     *
  	     * _.isArrayLikeObject('abc');
  	     * // => false
  	     *
  	     * _.isArrayLikeObject(_.noop);
  	     * // => false
  	     */
  	    function isArrayLikeObject(value) {
  	      return isObjectLike(value) && isArrayLike(value);
  	    }

  	    /**
  	     * Checks if `value` is classified as a boolean primitive or object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a boolean, else `false`.
  	     * @example
  	     *
  	     * _.isBoolean(false);
  	     * // => true
  	     *
  	     * _.isBoolean(null);
  	     * // => false
  	     */
  	    function isBoolean(value) {
  	      return value === true || value === false ||
  	        (isObjectLike(value) && baseGetTag(value) == boolTag);
  	    }

  	    /**
  	     * Checks if `value` is a buffer.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.3.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
  	     * @example
  	     *
  	     * _.isBuffer(new Buffer(2));
  	     * // => true
  	     *
  	     * _.isBuffer(new Uint8Array(2));
  	     * // => false
  	     */
  	    var isBuffer = nativeIsBuffer || stubFalse;

  	    /**
  	     * Checks if `value` is classified as a `Date` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a date object, else `false`.
  	     * @example
  	     *
  	     * _.isDate(new Date);
  	     * // => true
  	     *
  	     * _.isDate('Mon April 23 2012');
  	     * // => false
  	     */
  	    var isDate = nodeIsDate ? baseUnary(nodeIsDate) : baseIsDate;

  	    /**
  	     * Checks if `value` is likely a DOM element.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a DOM element, else `false`.
  	     * @example
  	     *
  	     * _.isElement(document.body);
  	     * // => true
  	     *
  	     * _.isElement('<body>');
  	     * // => false
  	     */
  	    function isElement(value) {
  	      return isObjectLike(value) && value.nodeType === 1 && !isPlainObject(value);
  	    }

  	    /**
  	     * Checks if `value` is an empty object, collection, map, or set.
  	     *
  	     * Objects are considered empty if they have no own enumerable string keyed
  	     * properties.
  	     *
  	     * Array-like values such as `arguments` objects, arrays, buffers, strings, or
  	     * jQuery-like collections are considered empty if they have a `length` of `0`.
  	     * Similarly, maps and sets are considered empty if they have a `size` of `0`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is empty, else `false`.
  	     * @example
  	     *
  	     * _.isEmpty(null);
  	     * // => true
  	     *
  	     * _.isEmpty(true);
  	     * // => true
  	     *
  	     * _.isEmpty(1);
  	     * // => true
  	     *
  	     * _.isEmpty([1, 2, 3]);
  	     * // => false
  	     *
  	     * _.isEmpty({ 'a': 1 });
  	     * // => false
  	     */
  	    function isEmpty(value) {
  	      if (value == null) {
  	        return true;
  	      }
  	      if (isArrayLike(value) &&
  	          (isArray(value) || typeof value == 'string' || typeof value.splice == 'function' ||
  	            isBuffer(value) || isTypedArray(value) || isArguments(value))) {
  	        return !value.length;
  	      }
  	      var tag = getTag(value);
  	      if (tag == mapTag || tag == setTag) {
  	        return !value.size;
  	      }
  	      if (isPrototype(value)) {
  	        return !baseKeys(value).length;
  	      }
  	      for (var key in value) {
  	        if (hasOwnProperty.call(value, key)) {
  	          return false;
  	        }
  	      }
  	      return true;
  	    }

  	    /**
  	     * Performs a deep comparison between two values to determine if they are
  	     * equivalent.
  	     *
  	     * **Note:** This method supports comparing arrays, array buffers, booleans,
  	     * date objects, error objects, maps, numbers, `Object` objects, regexes,
  	     * sets, strings, symbols, and typed arrays. `Object` objects are compared
  	     * by their own, not inherited, enumerable properties. Functions and DOM
  	     * nodes are compared by strict equality, i.e. `===`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
  	     * @example
  	     *
  	     * var object = { 'a': 1 };
  	     * var other = { 'a': 1 };
  	     *
  	     * _.isEqual(object, other);
  	     * // => true
  	     *
  	     * object === other;
  	     * // => false
  	     */
  	    function isEqual(value, other) {
  	      return baseIsEqual(value, other);
  	    }

  	    /**
  	     * This method is like `_.isEqual` except that it accepts `customizer` which
  	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
  	     * are handled by the method instead. The `customizer` is invoked with up to
  	     * six arguments: (objValue, othValue [, index|key, object, other, stack]).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @param {Function} [customizer] The function to customize comparisons.
  	     * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
  	     * @example
  	     *
  	     * function isGreeting(value) {
  	     *   return /^h(?:i|ello)$/.test(value);
  	     * }
  	     *
  	     * function customizer(objValue, othValue) {
  	     *   if (isGreeting(objValue) && isGreeting(othValue)) {
  	     *     return true;
  	     *   }
  	     * }
  	     *
  	     * var array = ['hello', 'goodbye'];
  	     * var other = ['hi', 'goodbye'];
  	     *
  	     * _.isEqualWith(array, other, customizer);
  	     * // => true
  	     */
  	    function isEqualWith(value, other, customizer) {
  	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
  	      var result = customizer ? customizer(value, other) : undefined$1;
  	      return result === undefined$1 ? baseIsEqual(value, other, undefined$1, customizer) : !!result;
  	    }

  	    /**
  	     * Checks if `value` is an `Error`, `EvalError`, `RangeError`, `ReferenceError`,
  	     * `SyntaxError`, `TypeError`, or `URIError` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an error object, else `false`.
  	     * @example
  	     *
  	     * _.isError(new Error);
  	     * // => true
  	     *
  	     * _.isError(Error);
  	     * // => false
  	     */
  	    function isError(value) {
  	      if (!isObjectLike(value)) {
  	        return false;
  	      }
  	      var tag = baseGetTag(value);
  	      return tag == errorTag || tag == domExcTag ||
  	        (typeof value.message == 'string' && typeof value.name == 'string' && !isPlainObject(value));
  	    }

  	    /**
  	     * Checks if `value` is a finite primitive number.
  	     *
  	     * **Note:** This method is based on
  	     * [`Number.isFinite`](https://mdn.io/Number/isFinite).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a finite number, else `false`.
  	     * @example
  	     *
  	     * _.isFinite(3);
  	     * // => true
  	     *
  	     * _.isFinite(Number.MIN_VALUE);
  	     * // => true
  	     *
  	     * _.isFinite(Infinity);
  	     * // => false
  	     *
  	     * _.isFinite('3');
  	     * // => false
  	     */
  	    function isFinite(value) {
  	      return typeof value == 'number' && nativeIsFinite(value);
  	    }

  	    /**
  	     * Checks if `value` is classified as a `Function` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a function, else `false`.
  	     * @example
  	     *
  	     * _.isFunction(_);
  	     * // => true
  	     *
  	     * _.isFunction(/abc/);
  	     * // => false
  	     */
  	    function isFunction(value) {
  	      if (!isObject(value)) {
  	        return false;
  	      }
  	      // The use of `Object#toString` avoids issues with the `typeof` operator
  	      // in Safari 9 which returns 'object' for typed arrays and other constructors.
  	      var tag = baseGetTag(value);
  	      return tag == funcTag || tag == genTag || tag == asyncTag || tag == proxyTag;
  	    }

  	    /**
  	     * Checks if `value` is an integer.
  	     *
  	     * **Note:** This method is based on
  	     * [`Number.isInteger`](https://mdn.io/Number/isInteger).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an integer, else `false`.
  	     * @example
  	     *
  	     * _.isInteger(3);
  	     * // => true
  	     *
  	     * _.isInteger(Number.MIN_VALUE);
  	     * // => false
  	     *
  	     * _.isInteger(Infinity);
  	     * // => false
  	     *
  	     * _.isInteger('3');
  	     * // => false
  	     */
  	    function isInteger(value) {
  	      return typeof value == 'number' && value == toInteger(value);
  	    }

  	    /**
  	     * Checks if `value` is a valid array-like length.
  	     *
  	     * **Note:** This method is loosely based on
  	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
  	     * @example
  	     *
  	     * _.isLength(3);
  	     * // => true
  	     *
  	     * _.isLength(Number.MIN_VALUE);
  	     * // => false
  	     *
  	     * _.isLength(Infinity);
  	     * // => false
  	     *
  	     * _.isLength('3');
  	     * // => false
  	     */
  	    function isLength(value) {
  	      return typeof value == 'number' &&
  	        value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  	    }

  	    /**
  	     * Checks if `value` is the
  	     * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
  	     * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is an object, else `false`.
  	     * @example
  	     *
  	     * _.isObject({});
  	     * // => true
  	     *
  	     * _.isObject([1, 2, 3]);
  	     * // => true
  	     *
  	     * _.isObject(_.noop);
  	     * // => true
  	     *
  	     * _.isObject(null);
  	     * // => false
  	     */
  	    function isObject(value) {
  	      var type = typeof value;
  	      return value != null && (type == 'object' || type == 'function');
  	    }

  	    /**
  	     * Checks if `value` is object-like. A value is object-like if it's not `null`
  	     * and has a `typeof` result of "object".
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
  	     * @example
  	     *
  	     * _.isObjectLike({});
  	     * // => true
  	     *
  	     * _.isObjectLike([1, 2, 3]);
  	     * // => true
  	     *
  	     * _.isObjectLike(_.noop);
  	     * // => false
  	     *
  	     * _.isObjectLike(null);
  	     * // => false
  	     */
  	    function isObjectLike(value) {
  	      return value != null && typeof value == 'object';
  	    }

  	    /**
  	     * Checks if `value` is classified as a `Map` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.3.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a map, else `false`.
  	     * @example
  	     *
  	     * _.isMap(new Map);
  	     * // => true
  	     *
  	     * _.isMap(new WeakMap);
  	     * // => false
  	     */
  	    var isMap = nodeIsMap ? baseUnary(nodeIsMap) : baseIsMap;

  	    /**
  	     * Performs a partial deep comparison between `object` and `source` to
  	     * determine if `object` contains equivalent property values.
  	     *
  	     * **Note:** This method is equivalent to `_.matches` when `source` is
  	     * partially applied.
  	     *
  	     * Partial comparisons will match empty array and empty object `source`
  	     * values against any array or object value, respectively. See `_.isEqual`
  	     * for a list of supported value comparisons.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Lang
  	     * @param {Object} object The object to inspect.
  	     * @param {Object} source The object of property values to match.
  	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': 2 };
  	     *
  	     * _.isMatch(object, { 'b': 2 });
  	     * // => true
  	     *
  	     * _.isMatch(object, { 'b': 1 });
  	     * // => false
  	     */
  	    function isMatch(object, source) {
  	      return object === source || baseIsMatch(object, source, getMatchData(source));
  	    }

  	    /**
  	     * This method is like `_.isMatch` except that it accepts `customizer` which
  	     * is invoked to compare values. If `customizer` returns `undefined`, comparisons
  	     * are handled by the method instead. The `customizer` is invoked with five
  	     * arguments: (objValue, srcValue, index|key, object, source).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {Object} object The object to inspect.
  	     * @param {Object} source The object of property values to match.
  	     * @param {Function} [customizer] The function to customize comparisons.
  	     * @returns {boolean} Returns `true` if `object` is a match, else `false`.
  	     * @example
  	     *
  	     * function isGreeting(value) {
  	     *   return /^h(?:i|ello)$/.test(value);
  	     * }
  	     *
  	     * function customizer(objValue, srcValue) {
  	     *   if (isGreeting(objValue) && isGreeting(srcValue)) {
  	     *     return true;
  	     *   }
  	     * }
  	     *
  	     * var object = { 'greeting': 'hello' };
  	     * var source = { 'greeting': 'hi' };
  	     *
  	     * _.isMatchWith(object, source, customizer);
  	     * // => true
  	     */
  	    function isMatchWith(object, source, customizer) {
  	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
  	      return baseIsMatch(object, source, getMatchData(source), customizer);
  	    }

  	    /**
  	     * Checks if `value` is `NaN`.
  	     *
  	     * **Note:** This method is based on
  	     * [`Number.isNaN`](https://mdn.io/Number/isNaN) and is not the same as
  	     * global [`isNaN`](https://mdn.io/isNaN) which returns `true` for
  	     * `undefined` and other non-number values.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is `NaN`, else `false`.
  	     * @example
  	     *
  	     * _.isNaN(NaN);
  	     * // => true
  	     *
  	     * _.isNaN(new Number(NaN));
  	     * // => true
  	     *
  	     * isNaN(undefined);
  	     * // => true
  	     *
  	     * _.isNaN(undefined);
  	     * // => false
  	     */
  	    function isNaN(value) {
  	      // An `NaN` primitive is the only value that is not equal to itself.
  	      // Perform the `toStringTag` check first to avoid errors with some
  	      // ActiveX objects in IE.
  	      return isNumber(value) && value != +value;
  	    }

  	    /**
  	     * Checks if `value` is a pristine native function.
  	     *
  	     * **Note:** This method can't reliably detect native functions in the presence
  	     * of the core-js package because core-js circumvents this kind of detection.
  	     * Despite multiple requests, the core-js maintainer has made it clear: any
  	     * attempt to fix the detection will be obstructed. As a result, we're left
  	     * with little choice but to throw an error. Unfortunately, this also affects
  	     * packages, like [babel-polyfill](https://www.npmjs.com/package/babel-polyfill),
  	     * which rely on core-js.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a native function,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.isNative(Array.prototype.push);
  	     * // => true
  	     *
  	     * _.isNative(_);
  	     * // => false
  	     */
  	    function isNative(value) {
  	      if (isMaskable(value)) {
  	        throw new Error(CORE_ERROR_TEXT);
  	      }
  	      return baseIsNative(value);
  	    }

  	    /**
  	     * Checks if `value` is `null`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is `null`, else `false`.
  	     * @example
  	     *
  	     * _.isNull(null);
  	     * // => true
  	     *
  	     * _.isNull(void 0);
  	     * // => false
  	     */
  	    function isNull(value) {
  	      return value === null;
  	    }

  	    /**
  	     * Checks if `value` is `null` or `undefined`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is nullish, else `false`.
  	     * @example
  	     *
  	     * _.isNil(null);
  	     * // => true
  	     *
  	     * _.isNil(void 0);
  	     * // => true
  	     *
  	     * _.isNil(NaN);
  	     * // => false
  	     */
  	    function isNil(value) {
  	      return value == null;
  	    }

  	    /**
  	     * Checks if `value` is classified as a `Number` primitive or object.
  	     *
  	     * **Note:** To exclude `Infinity`, `-Infinity`, and `NaN`, which are
  	     * classified as numbers, use the `_.isFinite` method.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a number, else `false`.
  	     * @example
  	     *
  	     * _.isNumber(3);
  	     * // => true
  	     *
  	     * _.isNumber(Number.MIN_VALUE);
  	     * // => true
  	     *
  	     * _.isNumber(Infinity);
  	     * // => true
  	     *
  	     * _.isNumber('3');
  	     * // => false
  	     */
  	    function isNumber(value) {
  	      return typeof value == 'number' ||
  	        (isObjectLike(value) && baseGetTag(value) == numberTag);
  	    }

  	    /**
  	     * Checks if `value` is a plain object, that is, an object created by the
  	     * `Object` constructor or one with a `[[Prototype]]` of `null`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.8.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a plain object, else `false`.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     * }
  	     *
  	     * _.isPlainObject(new Foo);
  	     * // => false
  	     *
  	     * _.isPlainObject([1, 2, 3]);
  	     * // => false
  	     *
  	     * _.isPlainObject({ 'x': 0, 'y': 0 });
  	     * // => true
  	     *
  	     * _.isPlainObject(Object.create(null));
  	     * // => true
  	     */
  	    function isPlainObject(value) {
  	      if (!isObjectLike(value) || baseGetTag(value) != objectTag) {
  	        return false;
  	      }
  	      var proto = getPrototype(value);
  	      if (proto === null) {
  	        return true;
  	      }
  	      var Ctor = hasOwnProperty.call(proto, 'constructor') && proto.constructor;
  	      return typeof Ctor == 'function' && Ctor instanceof Ctor &&
  	        funcToString.call(Ctor) == objectCtorString;
  	    }

  	    /**
  	     * Checks if `value` is classified as a `RegExp` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.1.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a regexp, else `false`.
  	     * @example
  	     *
  	     * _.isRegExp(/abc/);
  	     * // => true
  	     *
  	     * _.isRegExp('/abc/');
  	     * // => false
  	     */
  	    var isRegExp = nodeIsRegExp ? baseUnary(nodeIsRegExp) : baseIsRegExp;

  	    /**
  	     * Checks if `value` is a safe integer. An integer is safe if it's an IEEE-754
  	     * double precision number which isn't the result of a rounded unsafe integer.
  	     *
  	     * **Note:** This method is based on
  	     * [`Number.isSafeInteger`](https://mdn.io/Number/isSafeInteger).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a safe integer, else `false`.
  	     * @example
  	     *
  	     * _.isSafeInteger(3);
  	     * // => true
  	     *
  	     * _.isSafeInteger(Number.MIN_VALUE);
  	     * // => false
  	     *
  	     * _.isSafeInteger(Infinity);
  	     * // => false
  	     *
  	     * _.isSafeInteger('3');
  	     * // => false
  	     */
  	    function isSafeInteger(value) {
  	      return isInteger(value) && value >= -MAX_SAFE_INTEGER && value <= MAX_SAFE_INTEGER;
  	    }

  	    /**
  	     * Checks if `value` is classified as a `Set` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.3.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a set, else `false`.
  	     * @example
  	     *
  	     * _.isSet(new Set);
  	     * // => true
  	     *
  	     * _.isSet(new WeakSet);
  	     * // => false
  	     */
  	    var isSet = nodeIsSet ? baseUnary(nodeIsSet) : baseIsSet;

  	    /**
  	     * Checks if `value` is classified as a `String` primitive or object.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a string, else `false`.
  	     * @example
  	     *
  	     * _.isString('abc');
  	     * // => true
  	     *
  	     * _.isString(1);
  	     * // => false
  	     */
  	    function isString(value) {
  	      return typeof value == 'string' ||
  	        (!isArray(value) && isObjectLike(value) && baseGetTag(value) == stringTag);
  	    }

  	    /**
  	     * Checks if `value` is classified as a `Symbol` primitive or object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a symbol, else `false`.
  	     * @example
  	     *
  	     * _.isSymbol(Symbol.iterator);
  	     * // => true
  	     *
  	     * _.isSymbol('abc');
  	     * // => false
  	     */
  	    function isSymbol(value) {
  	      return typeof value == 'symbol' ||
  	        (isObjectLike(value) && baseGetTag(value) == symbolTag);
  	    }

  	    /**
  	     * Checks if `value` is classified as a typed array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a typed array, else `false`.
  	     * @example
  	     *
  	     * _.isTypedArray(new Uint8Array);
  	     * // => true
  	     *
  	     * _.isTypedArray([]);
  	     * // => false
  	     */
  	    var isTypedArray = nodeIsTypedArray ? baseUnary(nodeIsTypedArray) : baseIsTypedArray;

  	    /**
  	     * Checks if `value` is `undefined`.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is `undefined`, else `false`.
  	     * @example
  	     *
  	     * _.isUndefined(void 0);
  	     * // => true
  	     *
  	     * _.isUndefined(null);
  	     * // => false
  	     */
  	    function isUndefined(value) {
  	      return value === undefined$1;
  	    }

  	    /**
  	     * Checks if `value` is classified as a `WeakMap` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.3.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a weak map, else `false`.
  	     * @example
  	     *
  	     * _.isWeakMap(new WeakMap);
  	     * // => true
  	     *
  	     * _.isWeakMap(new Map);
  	     * // => false
  	     */
  	    function isWeakMap(value) {
  	      return isObjectLike(value) && getTag(value) == weakMapTag;
  	    }

  	    /**
  	     * Checks if `value` is classified as a `WeakSet` object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.3.0
  	     * @category Lang
  	     * @param {*} value The value to check.
  	     * @returns {boolean} Returns `true` if `value` is a weak set, else `false`.
  	     * @example
  	     *
  	     * _.isWeakSet(new WeakSet);
  	     * // => true
  	     *
  	     * _.isWeakSet(new Set);
  	     * // => false
  	     */
  	    function isWeakSet(value) {
  	      return isObjectLike(value) && baseGetTag(value) == weakSetTag;
  	    }

  	    /**
  	     * Checks if `value` is less than `other`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.9.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if `value` is less than `other`,
  	     *  else `false`.
  	     * @see _.gt
  	     * @example
  	     *
  	     * _.lt(1, 3);
  	     * // => true
  	     *
  	     * _.lt(3, 3);
  	     * // => false
  	     *
  	     * _.lt(3, 1);
  	     * // => false
  	     */
  	    var lt = createRelationalOperation(baseLt);

  	    /**
  	     * Checks if `value` is less than or equal to `other`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.9.0
  	     * @category Lang
  	     * @param {*} value The value to compare.
  	     * @param {*} other The other value to compare.
  	     * @returns {boolean} Returns `true` if `value` is less than or equal to
  	     *  `other`, else `false`.
  	     * @see _.gte
  	     * @example
  	     *
  	     * _.lte(1, 3);
  	     * // => true
  	     *
  	     * _.lte(3, 3);
  	     * // => true
  	     *
  	     * _.lte(3, 1);
  	     * // => false
  	     */
  	    var lte = createRelationalOperation(function(value, other) {
  	      return value <= other;
  	    });

  	    /**
  	     * Converts `value` to an array.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {Array} Returns the converted array.
  	     * @example
  	     *
  	     * _.toArray({ 'a': 1, 'b': 2 });
  	     * // => [1, 2]
  	     *
  	     * _.toArray('abc');
  	     * // => ['a', 'b', 'c']
  	     *
  	     * _.toArray(1);
  	     * // => []
  	     *
  	     * _.toArray(null);
  	     * // => []
  	     */
  	    function toArray(value) {
  	      if (!value) {
  	        return [];
  	      }
  	      if (isArrayLike(value)) {
  	        return isString(value) ? stringToArray(value) : copyArray(value);
  	      }
  	      if (symIterator && value[symIterator]) {
  	        return iteratorToArray(value[symIterator]());
  	      }
  	      var tag = getTag(value),
  	          func = tag == mapTag ? mapToArray : (tag == setTag ? setToArray : values);

  	      return func(value);
  	    }

  	    /**
  	     * Converts `value` to a finite number.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.12.0
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {number} Returns the converted number.
  	     * @example
  	     *
  	     * _.toFinite(3.2);
  	     * // => 3.2
  	     *
  	     * _.toFinite(Number.MIN_VALUE);
  	     * // => 5e-324
  	     *
  	     * _.toFinite(Infinity);
  	     * // => 1.7976931348623157e+308
  	     *
  	     * _.toFinite('3.2');
  	     * // => 3.2
  	     */
  	    function toFinite(value) {
  	      if (!value) {
  	        return value === 0 ? value : 0;
  	      }
  	      value = toNumber(value);
  	      if (value === INFINITY || value === -INFINITY) {
  	        var sign = (value < 0 ? -1 : 1);
  	        return sign * MAX_INTEGER;
  	      }
  	      return value === value ? value : 0;
  	    }

  	    /**
  	     * Converts `value` to an integer.
  	     *
  	     * **Note:** This method is loosely based on
  	     * [`ToInteger`](http://www.ecma-international.org/ecma-262/7.0/#sec-tointeger).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {number} Returns the converted integer.
  	     * @example
  	     *
  	     * _.toInteger(3.2);
  	     * // => 3
  	     *
  	     * _.toInteger(Number.MIN_VALUE);
  	     * // => 0
  	     *
  	     * _.toInteger(Infinity);
  	     * // => 1.7976931348623157e+308
  	     *
  	     * _.toInteger('3.2');
  	     * // => 3
  	     */
  	    function toInteger(value) {
  	      var result = toFinite(value),
  	          remainder = result % 1;

  	      return result === result ? (remainder ? result - remainder : result) : 0;
  	    }

  	    /**
  	     * Converts `value` to an integer suitable for use as the length of an
  	     * array-like object.
  	     *
  	     * **Note:** This method is based on
  	     * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {number} Returns the converted integer.
  	     * @example
  	     *
  	     * _.toLength(3.2);
  	     * // => 3
  	     *
  	     * _.toLength(Number.MIN_VALUE);
  	     * // => 0
  	     *
  	     * _.toLength(Infinity);
  	     * // => 4294967295
  	     *
  	     * _.toLength('3.2');
  	     * // => 3
  	     */
  	    function toLength(value) {
  	      return value ? baseClamp(toInteger(value), 0, MAX_ARRAY_LENGTH) : 0;
  	    }

  	    /**
  	     * Converts `value` to a number.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to process.
  	     * @returns {number} Returns the number.
  	     * @example
  	     *
  	     * _.toNumber(3.2);
  	     * // => 3.2
  	     *
  	     * _.toNumber(Number.MIN_VALUE);
  	     * // => 5e-324
  	     *
  	     * _.toNumber(Infinity);
  	     * // => Infinity
  	     *
  	     * _.toNumber('3.2');
  	     * // => 3.2
  	     */
  	    function toNumber(value) {
  	      if (typeof value == 'number') {
  	        return value;
  	      }
  	      if (isSymbol(value)) {
  	        return NAN;
  	      }
  	      if (isObject(value)) {
  	        var other = typeof value.valueOf == 'function' ? value.valueOf() : value;
  	        value = isObject(other) ? (other + '') : other;
  	      }
  	      if (typeof value != 'string') {
  	        return value === 0 ? value : +value;
  	      }
  	      value = baseTrim(value);
  	      var isBinary = reIsBinary.test(value);
  	      return (isBinary || reIsOctal.test(value))
  	        ? freeParseInt(value.slice(2), isBinary ? 2 : 8)
  	        : (reIsBadHex.test(value) ? NAN : +value);
  	    }

  	    /**
  	     * Converts `value` to a plain object flattening inherited enumerable string
  	     * keyed properties of `value` to own properties of the plain object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {Object} Returns the converted plain object.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.assign({ 'a': 1 }, new Foo);
  	     * // => { 'a': 1, 'b': 2 }
  	     *
  	     * _.assign({ 'a': 1 }, _.toPlainObject(new Foo));
  	     * // => { 'a': 1, 'b': 2, 'c': 3 }
  	     */
  	    function toPlainObject(value) {
  	      return copyObject(value, keysIn(value));
  	    }

  	    /**
  	     * Converts `value` to a safe integer. A safe integer can be compared and
  	     * represented correctly.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {number} Returns the converted integer.
  	     * @example
  	     *
  	     * _.toSafeInteger(3.2);
  	     * // => 3
  	     *
  	     * _.toSafeInteger(Number.MIN_VALUE);
  	     * // => 0
  	     *
  	     * _.toSafeInteger(Infinity);
  	     * // => 9007199254740991
  	     *
  	     * _.toSafeInteger('3.2');
  	     * // => 3
  	     */
  	    function toSafeInteger(value) {
  	      return value
  	        ? baseClamp(toInteger(value), -MAX_SAFE_INTEGER, MAX_SAFE_INTEGER)
  	        : (value === 0 ? value : 0);
  	    }

  	    /**
  	     * Converts `value` to a string. An empty string is returned for `null`
  	     * and `undefined` values. The sign of `-0` is preserved.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Lang
  	     * @param {*} value The value to convert.
  	     * @returns {string} Returns the converted string.
  	     * @example
  	     *
  	     * _.toString(null);
  	     * // => ''
  	     *
  	     * _.toString(-0);
  	     * // => '-0'
  	     *
  	     * _.toString([1, 2, 3]);
  	     * // => '1,2,3'
  	     */
  	    function toString(value) {
  	      return value == null ? '' : baseToString(value);
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Assigns own enumerable string keyed properties of source objects to the
  	     * destination object. Source objects are applied from left to right.
  	     * Subsequent sources overwrite property assignments of previous sources.
  	     *
  	     * **Note:** This method mutates `object` and is loosely based on
  	     * [`Object.assign`](https://mdn.io/Object/assign).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.10.0
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} [sources] The source objects.
  	     * @returns {Object} Returns `object`.
  	     * @see _.assignIn
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     * }
  	     *
  	     * function Bar() {
  	     *   this.c = 3;
  	     * }
  	     *
  	     * Foo.prototype.b = 2;
  	     * Bar.prototype.d = 4;
  	     *
  	     * _.assign({ 'a': 0 }, new Foo, new Bar);
  	     * // => { 'a': 1, 'c': 3 }
  	     */
  	    var assign = createAssigner(function(object, source) {
  	      if (isPrototype(source) || isArrayLike(source)) {
  	        copyObject(source, keys(source), object);
  	        return;
  	      }
  	      for (var key in source) {
  	        if (hasOwnProperty.call(source, key)) {
  	          assignValue(object, key, source[key]);
  	        }
  	      }
  	    });

  	    /**
  	     * This method is like `_.assign` except that it iterates over own and
  	     * inherited source properties.
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @alias extend
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} [sources] The source objects.
  	     * @returns {Object} Returns `object`.
  	     * @see _.assign
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     * }
  	     *
  	     * function Bar() {
  	     *   this.c = 3;
  	     * }
  	     *
  	     * Foo.prototype.b = 2;
  	     * Bar.prototype.d = 4;
  	     *
  	     * _.assignIn({ 'a': 0 }, new Foo, new Bar);
  	     * // => { 'a': 1, 'b': 2, 'c': 3, 'd': 4 }
  	     */
  	    var assignIn = createAssigner(function(object, source) {
  	      copyObject(source, keysIn(source), object);
  	    });

  	    /**
  	     * This method is like `_.assignIn` except that it accepts `customizer`
  	     * which is invoked to produce the assigned values. If `customizer` returns
  	     * `undefined`, assignment is handled by the method instead. The `customizer`
  	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @alias extendWith
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} sources The source objects.
  	     * @param {Function} [customizer] The function to customize assigned values.
  	     * @returns {Object} Returns `object`.
  	     * @see _.assignWith
  	     * @example
  	     *
  	     * function customizer(objValue, srcValue) {
  	     *   return _.isUndefined(objValue) ? srcValue : objValue;
  	     * }
  	     *
  	     * var defaults = _.partialRight(_.assignInWith, customizer);
  	     *
  	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
  	     * // => { 'a': 1, 'b': 2 }
  	     */
  	    var assignInWith = createAssigner(function(object, source, srcIndex, customizer) {
  	      copyObject(source, keysIn(source), object, customizer);
  	    });

  	    /**
  	     * This method is like `_.assign` except that it accepts `customizer`
  	     * which is invoked to produce the assigned values. If `customizer` returns
  	     * `undefined`, assignment is handled by the method instead. The `customizer`
  	     * is invoked with five arguments: (objValue, srcValue, key, object, source).
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} sources The source objects.
  	     * @param {Function} [customizer] The function to customize assigned values.
  	     * @returns {Object} Returns `object`.
  	     * @see _.assignInWith
  	     * @example
  	     *
  	     * function customizer(objValue, srcValue) {
  	     *   return _.isUndefined(objValue) ? srcValue : objValue;
  	     * }
  	     *
  	     * var defaults = _.partialRight(_.assignWith, customizer);
  	     *
  	     * defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
  	     * // => { 'a': 1, 'b': 2 }
  	     */
  	    var assignWith = createAssigner(function(object, source, srcIndex, customizer) {
  	      copyObject(source, keys(source), object, customizer);
  	    });

  	    /**
  	     * Creates an array of values corresponding to `paths` of `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.0.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {...(string|string[])} [paths] The property paths to pick.
  	     * @returns {Array} Returns the picked values.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': 3 } }, 4] };
  	     *
  	     * _.at(object, ['a[0].b.c', 'a[1]']);
  	     * // => [3, 4]
  	     */
  	    var at = flatRest(baseAt);

  	    /**
  	     * Creates an object that inherits from the `prototype` object. If a
  	     * `properties` object is given, its own enumerable string keyed properties
  	     * are assigned to the created object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.3.0
  	     * @category Object
  	     * @param {Object} prototype The object to inherit from.
  	     * @param {Object} [properties] The properties to assign to the object.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * function Shape() {
  	     *   this.x = 0;
  	     *   this.y = 0;
  	     * }
  	     *
  	     * function Circle() {
  	     *   Shape.call(this);
  	     * }
  	     *
  	     * Circle.prototype = _.create(Shape.prototype, {
  	     *   'constructor': Circle
  	     * });
  	     *
  	     * var circle = new Circle;
  	     * circle instanceof Circle;
  	     * // => true
  	     *
  	     * circle instanceof Shape;
  	     * // => true
  	     */
  	    function create(prototype, properties) {
  	      var result = baseCreate(prototype);
  	      return properties == null ? result : baseAssign(result, properties);
  	    }

  	    /**
  	     * Assigns own and inherited enumerable string keyed properties of source
  	     * objects to the destination object for all destination properties that
  	     * resolve to `undefined`. Source objects are applied from left to right.
  	     * Once a property is set, additional values of the same property are ignored.
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} [sources] The source objects.
  	     * @returns {Object} Returns `object`.
  	     * @see _.defaultsDeep
  	     * @example
  	     *
  	     * _.defaults({ 'a': 1 }, { 'b': 2 }, { 'a': 3 });
  	     * // => { 'a': 1, 'b': 2 }
  	     */
  	    var defaults = baseRest(function(object, sources) {
  	      object = Object(object);

  	      var index = -1;
  	      var length = sources.length;
  	      var guard = length > 2 ? sources[2] : undefined$1;

  	      if (guard && isIterateeCall(sources[0], sources[1], guard)) {
  	        length = 1;
  	      }

  	      while (++index < length) {
  	        var source = sources[index];
  	        var props = keysIn(source);
  	        var propsIndex = -1;
  	        var propsLength = props.length;

  	        while (++propsIndex < propsLength) {
  	          var key = props[propsIndex];
  	          var value = object[key];

  	          if (value === undefined$1 ||
  	              (eq(value, objectProto[key]) && !hasOwnProperty.call(object, key))) {
  	            object[key] = source[key];
  	          }
  	        }
  	      }

  	      return object;
  	    });

  	    /**
  	     * This method is like `_.defaults` except that it recursively assigns
  	     * default properties.
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.10.0
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} [sources] The source objects.
  	     * @returns {Object} Returns `object`.
  	     * @see _.defaults
  	     * @example
  	     *
  	     * _.defaultsDeep({ 'a': { 'b': 2 } }, { 'a': { 'b': 1, 'c': 3 } });
  	     * // => { 'a': { 'b': 2, 'c': 3 } }
  	     */
  	    var defaultsDeep = baseRest(function(args) {
  	      args.push(undefined$1, customDefaultsMerge);
  	      return apply(mergeWith, undefined$1, args);
  	    });

  	    /**
  	     * This method is like `_.find` except that it returns the key of the first
  	     * element `predicate` returns truthy for instead of the element itself.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.1.0
  	     * @category Object
  	     * @param {Object} object The object to inspect.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {string|undefined} Returns the key of the matched element,
  	     *  else `undefined`.
  	     * @example
  	     *
  	     * var users = {
  	     *   'barney':  { 'age': 36, 'active': true },
  	     *   'fred':    { 'age': 40, 'active': false },
  	     *   'pebbles': { 'age': 1,  'active': true }
  	     * };
  	     *
  	     * _.findKey(users, function(o) { return o.age < 40; });
  	     * // => 'barney' (iteration order is not guaranteed)
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.findKey(users, { 'age': 1, 'active': true });
  	     * // => 'pebbles'
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.findKey(users, ['active', false]);
  	     * // => 'fred'
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.findKey(users, 'active');
  	     * // => 'barney'
  	     */
  	    function findKey(object, predicate) {
  	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwn);
  	    }

  	    /**
  	     * This method is like `_.findKey` except that it iterates over elements of
  	     * a collection in the opposite order.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Object
  	     * @param {Object} object The object to inspect.
  	     * @param {Function} [predicate=_.identity] The function invoked per iteration.
  	     * @returns {string|undefined} Returns the key of the matched element,
  	     *  else `undefined`.
  	     * @example
  	     *
  	     * var users = {
  	     *   'barney':  { 'age': 36, 'active': true },
  	     *   'fred':    { 'age': 40, 'active': false },
  	     *   'pebbles': { 'age': 1,  'active': true }
  	     * };
  	     *
  	     * _.findLastKey(users, function(o) { return o.age < 40; });
  	     * // => returns 'pebbles' assuming `_.findKey` returns 'barney'
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.findLastKey(users, { 'age': 36, 'active': true });
  	     * // => 'barney'
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.findLastKey(users, ['active', false]);
  	     * // => 'fred'
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.findLastKey(users, 'active');
  	     * // => 'pebbles'
  	     */
  	    function findLastKey(object, predicate) {
  	      return baseFindKey(object, getIteratee(predicate, 3), baseForOwnRight);
  	    }

  	    /**
  	     * Iterates over own and inherited enumerable string keyed properties of an
  	     * object and invokes `iteratee` for each property. The iteratee is invoked
  	     * with three arguments: (value, key, object). Iteratee functions may exit
  	     * iteration early by explicitly returning `false`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.3.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Object} Returns `object`.
  	     * @see _.forInRight
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.forIn(new Foo, function(value, key) {
  	     *   console.log(key);
  	     * });
  	     * // => Logs 'a', 'b', then 'c' (iteration order is not guaranteed).
  	     */
  	    function forIn(object, iteratee) {
  	      return object == null
  	        ? object
  	        : baseFor(object, getIteratee(iteratee, 3), keysIn);
  	    }

  	    /**
  	     * This method is like `_.forIn` except that it iterates over properties of
  	     * `object` in the opposite order.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Object} Returns `object`.
  	     * @see _.forIn
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.forInRight(new Foo, function(value, key) {
  	     *   console.log(key);
  	     * });
  	     * // => Logs 'c', 'b', then 'a' assuming `_.forIn` logs 'a', 'b', then 'c'.
  	     */
  	    function forInRight(object, iteratee) {
  	      return object == null
  	        ? object
  	        : baseForRight(object, getIteratee(iteratee, 3), keysIn);
  	    }

  	    /**
  	     * Iterates over own enumerable string keyed properties of an object and
  	     * invokes `iteratee` for each property. The iteratee is invoked with three
  	     * arguments: (value, key, object). Iteratee functions may exit iteration
  	     * early by explicitly returning `false`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.3.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Object} Returns `object`.
  	     * @see _.forOwnRight
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.forOwn(new Foo, function(value, key) {
  	     *   console.log(key);
  	     * });
  	     * // => Logs 'a' then 'b' (iteration order is not guaranteed).
  	     */
  	    function forOwn(object, iteratee) {
  	      return object && baseForOwn(object, getIteratee(iteratee, 3));
  	    }

  	    /**
  	     * This method is like `_.forOwn` except that it iterates over properties of
  	     * `object` in the opposite order.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.0.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Object} Returns `object`.
  	     * @see _.forOwn
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.forOwnRight(new Foo, function(value, key) {
  	     *   console.log(key);
  	     * });
  	     * // => Logs 'b' then 'a' assuming `_.forOwn` logs 'a' then 'b'.
  	     */
  	    function forOwnRight(object, iteratee) {
  	      return object && baseForOwnRight(object, getIteratee(iteratee, 3));
  	    }

  	    /**
  	     * Creates an array of function property names from own enumerable properties
  	     * of `object`.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The object to inspect.
  	     * @returns {Array} Returns the function names.
  	     * @see _.functionsIn
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = _.constant('a');
  	     *   this.b = _.constant('b');
  	     * }
  	     *
  	     * Foo.prototype.c = _.constant('c');
  	     *
  	     * _.functions(new Foo);
  	     * // => ['a', 'b']
  	     */
  	    function functions(object) {
  	      return object == null ? [] : baseFunctions(object, keys(object));
  	    }

  	    /**
  	     * Creates an array of function property names from own and inherited
  	     * enumerable properties of `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The object to inspect.
  	     * @returns {Array} Returns the function names.
  	     * @see _.functions
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = _.constant('a');
  	     *   this.b = _.constant('b');
  	     * }
  	     *
  	     * Foo.prototype.c = _.constant('c');
  	     *
  	     * _.functionsIn(new Foo);
  	     * // => ['a', 'b', 'c']
  	     */
  	    function functionsIn(object) {
  	      return object == null ? [] : baseFunctions(object, keysIn(object));
  	    }

  	    /**
  	     * Gets the value at `path` of `object`. If the resolved value is
  	     * `undefined`, the `defaultValue` is returned in its place.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.7.0
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path of the property to get.
  	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
  	     * @returns {*} Returns the resolved value.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
  	     *
  	     * _.get(object, 'a[0].b.c');
  	     * // => 3
  	     *
  	     * _.get(object, ['a', '0', 'b', 'c']);
  	     * // => 3
  	     *
  	     * _.get(object, 'a.b.c', 'default');
  	     * // => 'default'
  	     */
  	    function get(object, path, defaultValue) {
  	      var result = object == null ? undefined$1 : baseGet(object, path);
  	      return result === undefined$1 ? defaultValue : result;
  	    }

  	    /**
  	     * Checks if `path` is a direct property of `object`.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path to check.
  	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
  	     * @example
  	     *
  	     * var object = { 'a': { 'b': 2 } };
  	     * var other = _.create({ 'a': _.create({ 'b': 2 }) });
  	     *
  	     * _.has(object, 'a');
  	     * // => true
  	     *
  	     * _.has(object, 'a.b');
  	     * // => true
  	     *
  	     * _.has(object, ['a', 'b']);
  	     * // => true
  	     *
  	     * _.has(other, 'a');
  	     * // => false
  	     */
  	    function has(object, path) {
  	      return object != null && hasPath(object, path, baseHas);
  	    }

  	    /**
  	     * Checks if `path` is a direct or inherited property of `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path to check.
  	     * @returns {boolean} Returns `true` if `path` exists, else `false`.
  	     * @example
  	     *
  	     * var object = _.create({ 'a': _.create({ 'b': 2 }) });
  	     *
  	     * _.hasIn(object, 'a');
  	     * // => true
  	     *
  	     * _.hasIn(object, 'a.b');
  	     * // => true
  	     *
  	     * _.hasIn(object, ['a', 'b']);
  	     * // => true
  	     *
  	     * _.hasIn(object, 'b');
  	     * // => false
  	     */
  	    function hasIn(object, path) {
  	      return object != null && hasPath(object, path, baseHasIn);
  	    }

  	    /**
  	     * Creates an object composed of the inverted keys and values of `object`.
  	     * If `object` contains duplicate values, subsequent values overwrite
  	     * property assignments of previous values.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.7.0
  	     * @category Object
  	     * @param {Object} object The object to invert.
  	     * @returns {Object} Returns the new inverted object.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
  	     *
  	     * _.invert(object);
  	     * // => { '1': 'c', '2': 'b' }
  	     */
  	    var invert = createInverter(function(result, value, key) {
  	      if (value != null &&
  	          typeof value.toString != 'function') {
  	        value = nativeObjectToString.call(value);
  	      }

  	      result[value] = key;
  	    }, constant(identity));

  	    /**
  	     * This method is like `_.invert` except that the inverted object is generated
  	     * from the results of running each element of `object` thru `iteratee`. The
  	     * corresponding inverted value of each inverted key is an array of keys
  	     * responsible for generating the inverted value. The iteratee is invoked
  	     * with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.1.0
  	     * @category Object
  	     * @param {Object} object The object to invert.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {Object} Returns the new inverted object.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': 2, 'c': 1 };
  	     *
  	     * _.invertBy(object);
  	     * // => { '1': ['a', 'c'], '2': ['b'] }
  	     *
  	     * _.invertBy(object, function(value) {
  	     *   return 'group' + value;
  	     * });
  	     * // => { 'group1': ['a', 'c'], 'group2': ['b'] }
  	     */
  	    var invertBy = createInverter(function(result, value, key) {
  	      if (value != null &&
  	          typeof value.toString != 'function') {
  	        value = nativeObjectToString.call(value);
  	      }

  	      if (hasOwnProperty.call(result, value)) {
  	        result[value].push(key);
  	      } else {
  	        result[value] = [key];
  	      }
  	    }, getIteratee);

  	    /**
  	     * Invokes the method at `path` of `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path of the method to invoke.
  	     * @param {...*} [args] The arguments to invoke the method with.
  	     * @returns {*} Returns the result of the invoked method.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': [1, 2, 3, 4] } }] };
  	     *
  	     * _.invoke(object, 'a[0].b.c.slice', 1, 3);
  	     * // => [2, 3]
  	     */
  	    var invoke = baseRest(baseInvoke);

  	    /**
  	     * Creates an array of the own enumerable property names of `object`.
  	     *
  	     * **Note:** Non-object values are coerced to objects. See the
  	     * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
  	     * for more details.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.keys(new Foo);
  	     * // => ['a', 'b'] (iteration order is not guaranteed)
  	     *
  	     * _.keys('hi');
  	     * // => ['0', '1']
  	     */
  	    function keys(object) {
  	      return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  	    }

  	    /**
  	     * Creates an array of the own and inherited enumerable property names of `object`.
  	     *
  	     * **Note:** Non-object values are coerced to objects.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property names.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.keysIn(new Foo);
  	     * // => ['a', 'b', 'c'] (iteration order is not guaranteed)
  	     */
  	    function keysIn(object) {
  	      return isArrayLike(object) ? arrayLikeKeys(object, true) : baseKeysIn(object);
  	    }

  	    /**
  	     * The opposite of `_.mapValues`; this method creates an object with the
  	     * same values as `object` and keys generated by running each own enumerable
  	     * string keyed property of `object` thru `iteratee`. The iteratee is invoked
  	     * with three arguments: (value, key, object).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.8.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Object} Returns the new mapped object.
  	     * @see _.mapValues
  	     * @example
  	     *
  	     * _.mapKeys({ 'a': 1, 'b': 2 }, function(value, key) {
  	     *   return key + value;
  	     * });
  	     * // => { 'a1': 1, 'b2': 2 }
  	     */
  	    function mapKeys(object, iteratee) {
  	      var result = {};
  	      iteratee = getIteratee(iteratee, 3);

  	      baseForOwn(object, function(value, key, object) {
  	        baseAssignValue(result, iteratee(value, key, object), value);
  	      });
  	      return result;
  	    }

  	    /**
  	     * Creates an object with the same keys as `object` and values generated
  	     * by running each own enumerable string keyed property of `object` thru
  	     * `iteratee`. The iteratee is invoked with three arguments:
  	     * (value, key, object).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.4.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Object} Returns the new mapped object.
  	     * @see _.mapKeys
  	     * @example
  	     *
  	     * var users = {
  	     *   'fred':    { 'user': 'fred',    'age': 40 },
  	     *   'pebbles': { 'user': 'pebbles', 'age': 1 }
  	     * };
  	     *
  	     * _.mapValues(users, function(o) { return o.age; });
  	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.mapValues(users, 'age');
  	     * // => { 'fred': 40, 'pebbles': 1 } (iteration order is not guaranteed)
  	     */
  	    function mapValues(object, iteratee) {
  	      var result = {};
  	      iteratee = getIteratee(iteratee, 3);

  	      baseForOwn(object, function(value, key, object) {
  	        baseAssignValue(result, key, iteratee(value, key, object));
  	      });
  	      return result;
  	    }

  	    /**
  	     * This method is like `_.assign` except that it recursively merges own and
  	     * inherited enumerable string keyed properties of source objects into the
  	     * destination object. Source properties that resolve to `undefined` are
  	     * skipped if a destination value exists. Array and plain object properties
  	     * are merged recursively. Other objects and value types are overridden by
  	     * assignment. Source objects are applied from left to right. Subsequent
  	     * sources overwrite property assignments of previous sources.
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.5.0
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} [sources] The source objects.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * var object = {
  	     *   'a': [{ 'b': 2 }, { 'd': 4 }]
  	     * };
  	     *
  	     * var other = {
  	     *   'a': [{ 'c': 3 }, { 'e': 5 }]
  	     * };
  	     *
  	     * _.merge(object, other);
  	     * // => { 'a': [{ 'b': 2, 'c': 3 }, { 'd': 4, 'e': 5 }] }
  	     */
  	    var merge = createAssigner(function(object, source, srcIndex) {
  	      baseMerge(object, source, srcIndex);
  	    });

  	    /**
  	     * This method is like `_.merge` except that it accepts `customizer` which
  	     * is invoked to produce the merged values of the destination and source
  	     * properties. If `customizer` returns `undefined`, merging is handled by the
  	     * method instead. The `customizer` is invoked with six arguments:
  	     * (objValue, srcValue, key, object, source, stack).
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The destination object.
  	     * @param {...Object} sources The source objects.
  	     * @param {Function} customizer The function to customize assigned values.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * function customizer(objValue, srcValue) {
  	     *   if (_.isArray(objValue)) {
  	     *     return objValue.concat(srcValue);
  	     *   }
  	     * }
  	     *
  	     * var object = { 'a': [1], 'b': [2] };
  	     * var other = { 'a': [3], 'b': [4] };
  	     *
  	     * _.mergeWith(object, other, customizer);
  	     * // => { 'a': [1, 3], 'b': [2, 4] }
  	     */
  	    var mergeWith = createAssigner(function(object, source, srcIndex, customizer) {
  	      baseMerge(object, source, srcIndex, customizer);
  	    });

  	    /**
  	     * The opposite of `_.pick`; this method creates an object composed of the
  	     * own and inherited enumerable property paths of `object` that are not omitted.
  	     *
  	     * **Note:** This method is considerably slower than `_.pick`.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The source object.
  	     * @param {...(string|string[])} [paths] The property paths to omit.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
  	     *
  	     * _.omit(object, ['a', 'c']);
  	     * // => { 'b': '2' }
  	     */
  	    var omit = flatRest(function(object, paths) {
  	      var result = {};
  	      if (object == null) {
  	        return result;
  	      }
  	      var isDeep = false;
  	      paths = arrayMap(paths, function(path) {
  	        path = castPath(path, object);
  	        isDeep || (isDeep = path.length > 1);
  	        return path;
  	      });
  	      copyObject(object, getAllKeysIn(object), result);
  	      if (isDeep) {
  	        result = baseClone(result, CLONE_DEEP_FLAG | CLONE_FLAT_FLAG | CLONE_SYMBOLS_FLAG, customOmitClone);
  	      }
  	      var length = paths.length;
  	      while (length--) {
  	        baseUnset(result, paths[length]);
  	      }
  	      return result;
  	    });

  	    /**
  	     * The opposite of `_.pickBy`; this method creates an object composed of
  	     * the own and inherited enumerable string keyed properties of `object` that
  	     * `predicate` doesn't return truthy for. The predicate is invoked with two
  	     * arguments: (value, key).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The source object.
  	     * @param {Function} [predicate=_.identity] The function invoked per property.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
  	     *
  	     * _.omitBy(object, _.isNumber);
  	     * // => { 'b': '2' }
  	     */
  	    function omitBy(object, predicate) {
  	      return pickBy(object, negate(getIteratee(predicate)));
  	    }

  	    /**
  	     * Creates an object composed of the picked `object` properties.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The source object.
  	     * @param {...(string|string[])} [paths] The property paths to pick.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
  	     *
  	     * _.pick(object, ['a', 'c']);
  	     * // => { 'a': 1, 'c': 3 }
  	     */
  	    var pick = flatRest(function(object, paths) {
  	      return object == null ? {} : basePick(object, paths);
  	    });

  	    /**
  	     * Creates an object composed of the `object` properties `predicate` returns
  	     * truthy for. The predicate is invoked with two arguments: (value, key).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The source object.
  	     * @param {Function} [predicate=_.identity] The function invoked per property.
  	     * @returns {Object} Returns the new object.
  	     * @example
  	     *
  	     * var object = { 'a': 1, 'b': '2', 'c': 3 };
  	     *
  	     * _.pickBy(object, _.isNumber);
  	     * // => { 'a': 1, 'c': 3 }
  	     */
  	    function pickBy(object, predicate) {
  	      if (object == null) {
  	        return {};
  	      }
  	      var props = arrayMap(getAllKeysIn(object), function(prop) {
  	        return [prop];
  	      });
  	      predicate = getIteratee(predicate);
  	      return basePickBy(object, props, function(value, path) {
  	        return predicate(value, path[0]);
  	      });
  	    }

  	    /**
  	     * This method is like `_.get` except that if the resolved value is a
  	     * function it's invoked with the `this` binding of its parent object and
  	     * its result is returned.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @param {Array|string} path The path of the property to resolve.
  	     * @param {*} [defaultValue] The value returned for `undefined` resolved values.
  	     * @returns {*} Returns the resolved value.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c1': 3, 'c2': _.constant(4) } }] };
  	     *
  	     * _.result(object, 'a[0].b.c1');
  	     * // => 3
  	     *
  	     * _.result(object, 'a[0].b.c2');
  	     * // => 4
  	     *
  	     * _.result(object, 'a[0].b.c3', 'default');
  	     * // => 'default'
  	     *
  	     * _.result(object, 'a[0].b.c3', _.constant('default'));
  	     * // => 'default'
  	     */
  	    function result(object, path, defaultValue) {
  	      path = castPath(path, object);

  	      var index = -1,
  	          length = path.length;

  	      // Ensure the loop is entered when path is empty.
  	      if (!length) {
  	        length = 1;
  	        object = undefined$1;
  	      }
  	      while (++index < length) {
  	        var value = object == null ? undefined$1 : object[toKey(path[index])];
  	        if (value === undefined$1) {
  	          index = length;
  	          value = defaultValue;
  	        }
  	        object = isFunction(value) ? value.call(object) : value;
  	      }
  	      return object;
  	    }

  	    /**
  	     * Sets the value at `path` of `object`. If a portion of `path` doesn't exist,
  	     * it's created. Arrays are created for missing index properties while objects
  	     * are created for all other missing properties. Use `_.setWith` to customize
  	     * `path` creation.
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.7.0
  	     * @category Object
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to set.
  	     * @param {*} value The value to set.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
  	     *
  	     * _.set(object, 'a[0].b.c', 4);
  	     * console.log(object.a[0].b.c);
  	     * // => 4
  	     *
  	     * _.set(object, ['x', '0', 'y', 'z'], 5);
  	     * console.log(object.x[0].y.z);
  	     * // => 5
  	     */
  	    function set(object, path, value) {
  	      return object == null ? object : baseSet(object, path, value);
  	    }

  	    /**
  	     * This method is like `_.set` except that it accepts `customizer` which is
  	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
  	     * path creation is handled by the method instead. The `customizer` is invoked
  	     * with three arguments: (nsValue, key, nsObject).
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to set.
  	     * @param {*} value The value to set.
  	     * @param {Function} [customizer] The function to customize assigned values.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * var object = {};
  	     *
  	     * _.setWith(object, '[0][1]', 'a', Object);
  	     * // => { '0': { '1': 'a' } }
  	     */
  	    function setWith(object, path, value, customizer) {
  	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
  	      return object == null ? object : baseSet(object, path, value, customizer);
  	    }

  	    /**
  	     * Creates an array of own enumerable string keyed-value pairs for `object`
  	     * which can be consumed by `_.fromPairs`. If `object` is a map or set, its
  	     * entries are returned.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @alias entries
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the key-value pairs.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.toPairs(new Foo);
  	     * // => [['a', 1], ['b', 2]] (iteration order is not guaranteed)
  	     */
  	    var toPairs = createToPairs(keys);

  	    /**
  	     * Creates an array of own and inherited enumerable string keyed-value pairs
  	     * for `object` which can be consumed by `_.fromPairs`. If `object` is a map
  	     * or set, its entries are returned.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @alias entriesIn
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the key-value pairs.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.toPairsIn(new Foo);
  	     * // => [['a', 1], ['b', 2], ['c', 3]] (iteration order is not guaranteed)
  	     */
  	    var toPairsIn = createToPairs(keysIn);

  	    /**
  	     * An alternative to `_.reduce`; this method transforms `object` to a new
  	     * `accumulator` object which is the result of running each of its own
  	     * enumerable string keyed properties thru `iteratee`, with each invocation
  	     * potentially mutating the `accumulator` object. If `accumulator` is not
  	     * provided, a new object with the same `[[Prototype]]` will be used. The
  	     * iteratee is invoked with four arguments: (accumulator, value, key, object).
  	     * Iteratee functions may exit iteration early by explicitly returning `false`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.3.0
  	     * @category Object
  	     * @param {Object} object The object to iterate over.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @param {*} [accumulator] The custom accumulator value.
  	     * @returns {*} Returns the accumulated value.
  	     * @example
  	     *
  	     * _.transform([2, 3, 4], function(result, n) {
  	     *   result.push(n *= n);
  	     *   return n % 2 == 0;
  	     * }, []);
  	     * // => [4, 9]
  	     *
  	     * _.transform({ 'a': 1, 'b': 2, 'c': 1 }, function(result, value, key) {
  	     *   (result[value] || (result[value] = [])).push(key);
  	     * }, {});
  	     * // => { '1': ['a', 'c'], '2': ['b'] }
  	     */
  	    function transform(object, iteratee, accumulator) {
  	      var isArr = isArray(object),
  	          isArrLike = isArr || isBuffer(object) || isTypedArray(object);

  	      iteratee = getIteratee(iteratee, 4);
  	      if (accumulator == null) {
  	        var Ctor = object && object.constructor;
  	        if (isArrLike) {
  	          accumulator = isArr ? new Ctor : [];
  	        }
  	        else if (isObject(object)) {
  	          accumulator = isFunction(Ctor) ? baseCreate(getPrototype(object)) : {};
  	        }
  	        else {
  	          accumulator = {};
  	        }
  	      }
  	      (isArrLike ? arrayEach : baseForOwn)(object, function(value, index, object) {
  	        return iteratee(accumulator, value, index, object);
  	      });
  	      return accumulator;
  	    }

  	    /**
  	     * Removes the property at `path` of `object`.
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Object
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to unset.
  	     * @returns {boolean} Returns `true` if the property is deleted, else `false`.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': 7 } }] };
  	     * _.unset(object, 'a[0].b.c');
  	     * // => true
  	     *
  	     * console.log(object);
  	     * // => { 'a': [{ 'b': {} }] };
  	     *
  	     * _.unset(object, ['a', '0', 'b', 'c']);
  	     * // => true
  	     *
  	     * console.log(object);
  	     * // => { 'a': [{ 'b': {} }] };
  	     */
  	    function unset(object, path) {
  	      return object == null ? true : baseUnset(object, path);
  	    }

  	    /**
  	     * This method is like `_.set` except that accepts `updater` to produce the
  	     * value to set. Use `_.updateWith` to customize `path` creation. The `updater`
  	     * is invoked with one argument: (value).
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.6.0
  	     * @category Object
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to set.
  	     * @param {Function} updater The function to produce the updated value.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * var object = { 'a': [{ 'b': { 'c': 3 } }] };
  	     *
  	     * _.update(object, 'a[0].b.c', function(n) { return n * n; });
  	     * console.log(object.a[0].b.c);
  	     * // => 9
  	     *
  	     * _.update(object, 'x[0].y.z', function(n) { return n ? n + 1 : 0; });
  	     * console.log(object.x[0].y.z);
  	     * // => 0
  	     */
  	    function update(object, path, updater) {
  	      return object == null ? object : baseUpdate(object, path, castFunction(updater));
  	    }

  	    /**
  	     * This method is like `_.update` except that it accepts `customizer` which is
  	     * invoked to produce the objects of `path`.  If `customizer` returns `undefined`
  	     * path creation is handled by the method instead. The `customizer` is invoked
  	     * with three arguments: (nsValue, key, nsObject).
  	     *
  	     * **Note:** This method mutates `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.6.0
  	     * @category Object
  	     * @param {Object} object The object to modify.
  	     * @param {Array|string} path The path of the property to set.
  	     * @param {Function} updater The function to produce the updated value.
  	     * @param {Function} [customizer] The function to customize assigned values.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * var object = {};
  	     *
  	     * _.updateWith(object, '[0][1]', _.constant('a'), Object);
  	     * // => { '0': { '1': 'a' } }
  	     */
  	    function updateWith(object, path, updater, customizer) {
  	      customizer = typeof customizer == 'function' ? customizer : undefined$1;
  	      return object == null ? object : baseUpdate(object, path, castFunction(updater), customizer);
  	    }

  	    /**
  	     * Creates an array of the own enumerable string keyed property values of `object`.
  	     *
  	     * **Note:** Non-object values are coerced to objects.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property values.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.values(new Foo);
  	     * // => [1, 2] (iteration order is not guaranteed)
  	     *
  	     * _.values('hi');
  	     * // => ['h', 'i']
  	     */
  	    function values(object) {
  	      return object == null ? [] : baseValues(object, keys(object));
  	    }

  	    /**
  	     * Creates an array of the own and inherited enumerable string keyed property
  	     * values of `object`.
  	     *
  	     * **Note:** Non-object values are coerced to objects.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Object
  	     * @param {Object} object The object to query.
  	     * @returns {Array} Returns the array of property values.
  	     * @example
  	     *
  	     * function Foo() {
  	     *   this.a = 1;
  	     *   this.b = 2;
  	     * }
  	     *
  	     * Foo.prototype.c = 3;
  	     *
  	     * _.valuesIn(new Foo);
  	     * // => [1, 2, 3] (iteration order is not guaranteed)
  	     */
  	    function valuesIn(object) {
  	      return object == null ? [] : baseValues(object, keysIn(object));
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Clamps `number` within the inclusive `lower` and `upper` bounds.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Number
  	     * @param {number} number The number to clamp.
  	     * @param {number} [lower] The lower bound.
  	     * @param {number} upper The upper bound.
  	     * @returns {number} Returns the clamped number.
  	     * @example
  	     *
  	     * _.clamp(-10, -5, 5);
  	     * // => -5
  	     *
  	     * _.clamp(10, -5, 5);
  	     * // => 5
  	     */
  	    function clamp(number, lower, upper) {
  	      if (upper === undefined$1) {
  	        upper = lower;
  	        lower = undefined$1;
  	      }
  	      if (upper !== undefined$1) {
  	        upper = toNumber(upper);
  	        upper = upper === upper ? upper : 0;
  	      }
  	      if (lower !== undefined$1) {
  	        lower = toNumber(lower);
  	        lower = lower === lower ? lower : 0;
  	      }
  	      return baseClamp(toNumber(number), lower, upper);
  	    }

  	    /**
  	     * Checks if `n` is between `start` and up to, but not including, `end`. If
  	     * `end` is not specified, it's set to `start` with `start` then set to `0`.
  	     * If `start` is greater than `end` the params are swapped to support
  	     * negative ranges.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.3.0
  	     * @category Number
  	     * @param {number} number The number to check.
  	     * @param {number} [start=0] The start of the range.
  	     * @param {number} end The end of the range.
  	     * @returns {boolean} Returns `true` if `number` is in the range, else `false`.
  	     * @see _.range, _.rangeRight
  	     * @example
  	     *
  	     * _.inRange(3, 2, 4);
  	     * // => true
  	     *
  	     * _.inRange(4, 8);
  	     * // => true
  	     *
  	     * _.inRange(4, 2);
  	     * // => false
  	     *
  	     * _.inRange(2, 2);
  	     * // => false
  	     *
  	     * _.inRange(1.2, 2);
  	     * // => true
  	     *
  	     * _.inRange(5.2, 4);
  	     * // => false
  	     *
  	     * _.inRange(-3, -2, -6);
  	     * // => true
  	     */
  	    function inRange(number, start, end) {
  	      start = toFinite(start);
  	      if (end === undefined$1) {
  	        end = start;
  	        start = 0;
  	      } else {
  	        end = toFinite(end);
  	      }
  	      number = toNumber(number);
  	      return baseInRange(number, start, end);
  	    }

  	    /**
  	     * Produces a random number between the inclusive `lower` and `upper` bounds.
  	     * If only one argument is provided a number between `0` and the given number
  	     * is returned. If `floating` is `true`, or either `lower` or `upper` are
  	     * floats, a floating-point number is returned instead of an integer.
  	     *
  	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
  	     * floating-point values which can produce unexpected results.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.7.0
  	     * @category Number
  	     * @param {number} [lower=0] The lower bound.
  	     * @param {number} [upper=1] The upper bound.
  	     * @param {boolean} [floating] Specify returning a floating-point number.
  	     * @returns {number} Returns the random number.
  	     * @example
  	     *
  	     * _.random(0, 5);
  	     * // => an integer between 0 and 5
  	     *
  	     * _.random(5);
  	     * // => also an integer between 0 and 5
  	     *
  	     * _.random(5, true);
  	     * // => a floating-point number between 0 and 5
  	     *
  	     * _.random(1.2, 5.2);
  	     * // => a floating-point number between 1.2 and 5.2
  	     */
  	    function random(lower, upper, floating) {
  	      if (floating && typeof floating != 'boolean' && isIterateeCall(lower, upper, floating)) {
  	        upper = floating = undefined$1;
  	      }
  	      if (floating === undefined$1) {
  	        if (typeof upper == 'boolean') {
  	          floating = upper;
  	          upper = undefined$1;
  	        }
  	        else if (typeof lower == 'boolean') {
  	          floating = lower;
  	          lower = undefined$1;
  	        }
  	      }
  	      if (lower === undefined$1 && upper === undefined$1) {
  	        lower = 0;
  	        upper = 1;
  	      }
  	      else {
  	        lower = toFinite(lower);
  	        if (upper === undefined$1) {
  	          upper = lower;
  	          lower = 0;
  	        } else {
  	          upper = toFinite(upper);
  	        }
  	      }
  	      if (lower > upper) {
  	        var temp = lower;
  	        lower = upper;
  	        upper = temp;
  	      }
  	      if (floating || lower % 1 || upper % 1) {
  	        var rand = nativeRandom();
  	        return nativeMin(lower + (rand * (upper - lower + freeParseFloat('1e-' + ((rand + '').length - 1)))), upper);
  	      }
  	      return baseRandom(lower, upper);
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Converts `string` to [camel case](https://en.wikipedia.org/wiki/CamelCase).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the camel cased string.
  	     * @example
  	     *
  	     * _.camelCase('Foo Bar');
  	     * // => 'fooBar'
  	     *
  	     * _.camelCase('--foo-bar--');
  	     * // => 'fooBar'
  	     *
  	     * _.camelCase('__FOO_BAR__');
  	     * // => 'fooBar'
  	     */
  	    var camelCase = createCompounder(function(result, word, index) {
  	      word = word.toLowerCase();
  	      return result + (index ? capitalize(word) : word);
  	    });

  	    /**
  	     * Converts the first character of `string` to upper case and the remaining
  	     * to lower case.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to capitalize.
  	     * @returns {string} Returns the capitalized string.
  	     * @example
  	     *
  	     * _.capitalize('FRED');
  	     * // => 'Fred'
  	     */
  	    function capitalize(string) {
  	      return upperFirst(toString(string).toLowerCase());
  	    }

  	    /**
  	     * Deburrs `string` by converting
  	     * [Latin-1 Supplement](https://en.wikipedia.org/wiki/Latin-1_Supplement_(Unicode_block)#Character_table)
  	     * and [Latin Extended-A](https://en.wikipedia.org/wiki/Latin_Extended-A)
  	     * letters to basic Latin letters and removing
  	     * [combining diacritical marks](https://en.wikipedia.org/wiki/Combining_Diacritical_Marks).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to deburr.
  	     * @returns {string} Returns the deburred string.
  	     * @example
  	     *
  	     * _.deburr('dj vu');
  	     * // => 'deja vu'
  	     */
  	    function deburr(string) {
  	      string = toString(string);
  	      return string && string.replace(reLatin, deburrLetter).replace(reComboMark, '');
  	    }

  	    /**
  	     * Checks if `string` ends with the given target string.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to inspect.
  	     * @param {string} [target] The string to search for.
  	     * @param {number} [position=string.length] The position to search up to.
  	     * @returns {boolean} Returns `true` if `string` ends with `target`,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.endsWith('abc', 'c');
  	     * // => true
  	     *
  	     * _.endsWith('abc', 'b');
  	     * // => false
  	     *
  	     * _.endsWith('abc', 'b', 2);
  	     * // => true
  	     */
  	    function endsWith(string, target, position) {
  	      string = toString(string);
  	      target = baseToString(target);

  	      var length = string.length;
  	      position = position === undefined$1
  	        ? length
  	        : baseClamp(toInteger(position), 0, length);

  	      var end = position;
  	      position -= target.length;
  	      return position >= 0 && string.slice(position, end) == target;
  	    }

  	    /**
  	     * Converts the characters "&", "<", ">", '"', and "'" in `string` to their
  	     * corresponding HTML entities.
  	     *
  	     * **Note:** No other characters are escaped. To escape additional
  	     * characters use a third-party library like [_he_](https://mths.be/he).
  	     *
  	     * Though the ">" character is escaped for symmetry, characters like
  	     * ">" and "/" don't need escaping in HTML and have no special meaning
  	     * unless they're part of a tag or unquoted attribute value. See
  	     * [Mathias Bynens's article](https://mathiasbynens.be/notes/ambiguous-ampersands)
  	     * (under "semi-related fun fact") for more details.
  	     *
  	     * When working with HTML you should always
  	     * [quote attribute values](http://wonko.com/post/html-escaping) to reduce
  	     * XSS vectors.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category String
  	     * @param {string} [string=''] The string to escape.
  	     * @returns {string} Returns the escaped string.
  	     * @example
  	     *
  	     * _.escape('fred, barney, & pebbles');
  	     * // => 'fred, barney, &amp; pebbles'
  	     */
  	    function escape(string) {
  	      string = toString(string);
  	      return (string && reHasUnescapedHtml.test(string))
  	        ? string.replace(reUnescapedHtml, escapeHtmlChar)
  	        : string;
  	    }

  	    /**
  	     * Escapes the `RegExp` special characters "^", "$", "\", ".", "*", "+",
  	     * "?", "(", ")", "[", "]", "{", "}", and "|" in `string`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to escape.
  	     * @returns {string} Returns the escaped string.
  	     * @example
  	     *
  	     * _.escapeRegExp('[lodash](https://lodash.com/)');
  	     * // => '\[lodash\]\(https://lodash\.com/\)'
  	     */
  	    function escapeRegExp(string) {
  	      string = toString(string);
  	      return (string && reHasRegExpChar.test(string))
  	        ? string.replace(reRegExpChar, '\\$&')
  	        : string;
  	    }

  	    /**
  	     * Converts `string` to
  	     * [kebab case](https://en.wikipedia.org/wiki/Letter_case#Special_case_styles).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the kebab cased string.
  	     * @example
  	     *
  	     * _.kebabCase('Foo Bar');
  	     * // => 'foo-bar'
  	     *
  	     * _.kebabCase('fooBar');
  	     * // => 'foo-bar'
  	     *
  	     * _.kebabCase('__FOO_BAR__');
  	     * // => 'foo-bar'
  	     */
  	    var kebabCase = createCompounder(function(result, word, index) {
  	      return result + (index ? '-' : '') + word.toLowerCase();
  	    });

  	    /**
  	     * Converts `string`, as space separated words, to lower case.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the lower cased string.
  	     * @example
  	     *
  	     * _.lowerCase('--Foo-Bar--');
  	     * // => 'foo bar'
  	     *
  	     * _.lowerCase('fooBar');
  	     * // => 'foo bar'
  	     *
  	     * _.lowerCase('__FOO_BAR__');
  	     * // => 'foo bar'
  	     */
  	    var lowerCase = createCompounder(function(result, word, index) {
  	      return result + (index ? ' ' : '') + word.toLowerCase();
  	    });

  	    /**
  	     * Converts the first character of `string` to lower case.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the converted string.
  	     * @example
  	     *
  	     * _.lowerFirst('Fred');
  	     * // => 'fred'
  	     *
  	     * _.lowerFirst('FRED');
  	     * // => 'fRED'
  	     */
  	    var lowerFirst = createCaseFirst('toLowerCase');

  	    /**
  	     * Pads `string` on the left and right sides if it's shorter than `length`.
  	     * Padding characters are truncated if they can't be evenly divided by `length`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to pad.
  	     * @param {number} [length=0] The padding length.
  	     * @param {string} [chars=' '] The string used as padding.
  	     * @returns {string} Returns the padded string.
  	     * @example
  	     *
  	     * _.pad('abc', 8);
  	     * // => '  abc   '
  	     *
  	     * _.pad('abc', 8, '_-');
  	     * // => '_-abc_-_'
  	     *
  	     * _.pad('abc', 3);
  	     * // => 'abc'
  	     */
  	    function pad(string, length, chars) {
  	      string = toString(string);
  	      length = toInteger(length);

  	      var strLength = length ? stringSize(string) : 0;
  	      if (!length || strLength >= length) {
  	        return string;
  	      }
  	      var mid = (length - strLength) / 2;
  	      return (
  	        createPadding(nativeFloor(mid), chars) +
  	        string +
  	        createPadding(nativeCeil(mid), chars)
  	      );
  	    }

  	    /**
  	     * Pads `string` on the right side if it's shorter than `length`. Padding
  	     * characters are truncated if they exceed `length`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to pad.
  	     * @param {number} [length=0] The padding length.
  	     * @param {string} [chars=' '] The string used as padding.
  	     * @returns {string} Returns the padded string.
  	     * @example
  	     *
  	     * _.padEnd('abc', 6);
  	     * // => 'abc   '
  	     *
  	     * _.padEnd('abc', 6, '_-');
  	     * // => 'abc_-_'
  	     *
  	     * _.padEnd('abc', 3);
  	     * // => 'abc'
  	     */
  	    function padEnd(string, length, chars) {
  	      string = toString(string);
  	      length = toInteger(length);

  	      var strLength = length ? stringSize(string) : 0;
  	      return (length && strLength < length)
  	        ? (string + createPadding(length - strLength, chars))
  	        : string;
  	    }

  	    /**
  	     * Pads `string` on the left side if it's shorter than `length`. Padding
  	     * characters are truncated if they exceed `length`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to pad.
  	     * @param {number} [length=0] The padding length.
  	     * @param {string} [chars=' '] The string used as padding.
  	     * @returns {string} Returns the padded string.
  	     * @example
  	     *
  	     * _.padStart('abc', 6);
  	     * // => '   abc'
  	     *
  	     * _.padStart('abc', 6, '_-');
  	     * // => '_-_abc'
  	     *
  	     * _.padStart('abc', 3);
  	     * // => 'abc'
  	     */
  	    function padStart(string, length, chars) {
  	      string = toString(string);
  	      length = toInteger(length);

  	      var strLength = length ? stringSize(string) : 0;
  	      return (length && strLength < length)
  	        ? (createPadding(length - strLength, chars) + string)
  	        : string;
  	    }

  	    /**
  	     * Converts `string` to an integer of the specified radix. If `radix` is
  	     * `undefined` or `0`, a `radix` of `10` is used unless `value` is a
  	     * hexadecimal, in which case a `radix` of `16` is used.
  	     *
  	     * **Note:** This method aligns with the
  	     * [ES5 implementation](https://es5.github.io/#x15.1.2.2) of `parseInt`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 1.1.0
  	     * @category String
  	     * @param {string} string The string to convert.
  	     * @param {number} [radix=10] The radix to interpret `value` by.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {number} Returns the converted integer.
  	     * @example
  	     *
  	     * _.parseInt('08');
  	     * // => 8
  	     *
  	     * _.map(['6', '08', '10'], _.parseInt);
  	     * // => [6, 8, 10]
  	     */
  	    function parseInt(string, radix, guard) {
  	      if (guard || radix == null) {
  	        radix = 0;
  	      } else if (radix) {
  	        radix = +radix;
  	      }
  	      return nativeParseInt(toString(string).replace(reTrimStart, ''), radix || 0);
  	    }

  	    /**
  	     * Repeats the given string `n` times.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to repeat.
  	     * @param {number} [n=1] The number of times to repeat the string.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {string} Returns the repeated string.
  	     * @example
  	     *
  	     * _.repeat('*', 3);
  	     * // => '***'
  	     *
  	     * _.repeat('abc', 2);
  	     * // => 'abcabc'
  	     *
  	     * _.repeat('abc', 0);
  	     * // => ''
  	     */
  	    function repeat(string, n, guard) {
  	      if ((guard ? isIterateeCall(string, n, guard) : n === undefined$1)) {
  	        n = 1;
  	      } else {
  	        n = toInteger(n);
  	      }
  	      return baseRepeat(toString(string), n);
  	    }

  	    /**
  	     * Replaces matches for `pattern` in `string` with `replacement`.
  	     *
  	     * **Note:** This method is based on
  	     * [`String#replace`](https://mdn.io/String/replace).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to modify.
  	     * @param {RegExp|string} pattern The pattern to replace.
  	     * @param {Function|string} replacement The match replacement.
  	     * @returns {string} Returns the modified string.
  	     * @example
  	     *
  	     * _.replace('Hi Fred', 'Fred', 'Barney');
  	     * // => 'Hi Barney'
  	     */
  	    function replace() {
  	      var args = arguments,
  	          string = toString(args[0]);

  	      return args.length < 3 ? string : string.replace(args[1], args[2]);
  	    }

  	    /**
  	     * Converts `string` to
  	     * [snake case](https://en.wikipedia.org/wiki/Snake_case).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the snake cased string.
  	     * @example
  	     *
  	     * _.snakeCase('Foo Bar');
  	     * // => 'foo_bar'
  	     *
  	     * _.snakeCase('fooBar');
  	     * // => 'foo_bar'
  	     *
  	     * _.snakeCase('--FOO-BAR--');
  	     * // => 'foo_bar'
  	     */
  	    var snakeCase = createCompounder(function(result, word, index) {
  	      return result + (index ? '_' : '') + word.toLowerCase();
  	    });

  	    /**
  	     * Splits `string` by `separator`.
  	     *
  	     * **Note:** This method is based on
  	     * [`String#split`](https://mdn.io/String/split).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to split.
  	     * @param {RegExp|string} separator The separator pattern to split by.
  	     * @param {number} [limit] The length to truncate results to.
  	     * @returns {Array} Returns the string segments.
  	     * @example
  	     *
  	     * _.split('a-b-c', '-', 2);
  	     * // => ['a', 'b']
  	     */
  	    function split(string, separator, limit) {
  	      if (limit && typeof limit != 'number' && isIterateeCall(string, separator, limit)) {
  	        separator = limit = undefined$1;
  	      }
  	      limit = limit === undefined$1 ? MAX_ARRAY_LENGTH : limit >>> 0;
  	      if (!limit) {
  	        return [];
  	      }
  	      string = toString(string);
  	      if (string && (
  	            typeof separator == 'string' ||
  	            (separator != null && !isRegExp(separator))
  	          )) {
  	        separator = baseToString(separator);
  	        if (!separator && hasUnicode(string)) {
  	          return castSlice(stringToArray(string), 0, limit);
  	        }
  	      }
  	      return string.split(separator, limit);
  	    }

  	    /**
  	     * Converts `string` to
  	     * [start case](https://en.wikipedia.org/wiki/Letter_case#Stylistic_or_specialised_usage).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.1.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the start cased string.
  	     * @example
  	     *
  	     * _.startCase('--foo-bar--');
  	     * // => 'Foo Bar'
  	     *
  	     * _.startCase('fooBar');
  	     * // => 'Foo Bar'
  	     *
  	     * _.startCase('__FOO_BAR__');
  	     * // => 'FOO BAR'
  	     */
  	    var startCase = createCompounder(function(result, word, index) {
  	      return result + (index ? ' ' : '') + upperFirst(word);
  	    });

  	    /**
  	     * Checks if `string` starts with the given target string.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to inspect.
  	     * @param {string} [target] The string to search for.
  	     * @param {number} [position=0] The position to search from.
  	     * @returns {boolean} Returns `true` if `string` starts with `target`,
  	     *  else `false`.
  	     * @example
  	     *
  	     * _.startsWith('abc', 'a');
  	     * // => true
  	     *
  	     * _.startsWith('abc', 'b');
  	     * // => false
  	     *
  	     * _.startsWith('abc', 'b', 1);
  	     * // => true
  	     */
  	    function startsWith(string, target, position) {
  	      string = toString(string);
  	      position = position == null
  	        ? 0
  	        : baseClamp(toInteger(position), 0, string.length);

  	      target = baseToString(target);
  	      return string.slice(position, position + target.length) == target;
  	    }

  	    /**
  	     * Creates a compiled template function that can interpolate data properties
  	     * in "interpolate" delimiters, HTML-escape interpolated data properties in
  	     * "escape" delimiters, and execute JavaScript in "evaluate" delimiters. Data
  	     * properties may be accessed as free variables in the template. If a setting
  	     * object is given, it takes precedence over `_.templateSettings` values.
  	     *
  	     * **Note:** In the development build `_.template` utilizes
  	     * [sourceURLs](http://www.html5rocks.com/en/tutorials/developertools/sourcemaps/#toc-sourceurl)
  	     * for easier debugging.
  	     *
  	     * For more information on precompiling templates see
  	     * [lodash's custom builds documentation](https://lodash.com/custom-builds).
  	     *
  	     * For more information on Chrome extension sandboxes see
  	     * [Chrome's extensions documentation](https://developer.chrome.com/extensions/sandboxingEval).
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category String
  	     * @param {string} [string=''] The template string.
  	     * @param {Object} [options={}] The options object.
  	     * @param {RegExp} [options.escape=_.templateSettings.escape]
  	     *  The HTML "escape" delimiter.
  	     * @param {RegExp} [options.evaluate=_.templateSettings.evaluate]
  	     *  The "evaluate" delimiter.
  	     * @param {Object} [options.imports=_.templateSettings.imports]
  	     *  An object to import into the template as free variables.
  	     * @param {RegExp} [options.interpolate=_.templateSettings.interpolate]
  	     *  The "interpolate" delimiter.
  	     * @param {string} [options.sourceURL='lodash.templateSources[n]']
  	     *  The sourceURL of the compiled template.
  	     * @param {string} [options.variable='obj']
  	     *  The data object variable name.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Function} Returns the compiled template function.
  	     * @example
  	     *
  	     * // Use the "interpolate" delimiter to create a compiled template.
  	     * var compiled = _.template('hello <%= user %>!');
  	     * compiled({ 'user': 'fred' });
  	     * // => 'hello fred!'
  	     *
  	     * // Use the HTML "escape" delimiter to escape data property values.
  	     * var compiled = _.template('<b><%- value %></b>');
  	     * compiled({ 'value': '<script>' });
  	     * // => '<b>&lt;script&gt;</b>'
  	     *
  	     * // Use the "evaluate" delimiter to execute JavaScript and generate HTML.
  	     * var compiled = _.template('<% _.forEach(users, function(user) { %><li><%- user %></li><% }); %>');
  	     * compiled({ 'users': ['fred', 'barney'] });
  	     * // => '<li>fred</li><li>barney</li>'
  	     *
  	     * // Use the internal `print` function in "evaluate" delimiters.
  	     * var compiled = _.template('<% print("hello " + user); %>!');
  	     * compiled({ 'user': 'barney' });
  	     * // => 'hello barney!'
  	     *
  	     * // Use the ES template literal delimiter as an "interpolate" delimiter.
  	     * // Disable support by replacing the "interpolate" delimiter.
  	     * var compiled = _.template('hello ${ user }!');
  	     * compiled({ 'user': 'pebbles' });
  	     * // => 'hello pebbles!'
  	     *
  	     * // Use backslashes to treat delimiters as plain text.
  	     * var compiled = _.template('<%= "\\<%- value %\\>" %>');
  	     * compiled({ 'value': 'ignored' });
  	     * // => '<%- value %>'
  	     *
  	     * // Use the `imports` option to import `jQuery` as `jq`.
  	     * var text = '<% jq.each(users, function(user) { %><li><%- user %></li><% }); %>';
  	     * var compiled = _.template(text, { 'imports': { 'jq': jQuery } });
  	     * compiled({ 'users': ['fred', 'barney'] });
  	     * // => '<li>fred</li><li>barney</li>'
  	     *
  	     * // Use the `sourceURL` option to specify a custom sourceURL for the template.
  	     * var compiled = _.template('hello <%= user %>!', { 'sourceURL': '/basic/greeting.jst' });
  	     * compiled(data);
  	     * // => Find the source of "greeting.jst" under the Sources tab or Resources panel of the web inspector.
  	     *
  	     * // Use the `variable` option to ensure a with-statement isn't used in the compiled template.
  	     * var compiled = _.template('hi <%= data.user %>!', { 'variable': 'data' });
  	     * compiled.source;
  	     * // => function(data) {
  	     * //   var __t, __p = '';
  	     * //   __p += 'hi ' + ((__t = ( data.user )) == null ? '' : __t) + '!';
  	     * //   return __p;
  	     * // }
  	     *
  	     * // Use custom template delimiters.
  	     * _.templateSettings.interpolate = /{{([\s\S]+?)}}/g;
  	     * var compiled = _.template('hello {{ user }}!');
  	     * compiled({ 'user': 'mustache' });
  	     * // => 'hello mustache!'
  	     *
  	     * // Use the `source` property to inline compiled templates for meaningful
  	     * // line numbers in error messages and stack traces.
  	     * fs.writeFileSync(path.join(process.cwd(), 'jst.js'), '\
  	     *   var JST = {\
  	     *     "main": ' + _.template(mainText).source + '\
  	     *   };\
  	     * ');
  	     */
  	    function template(string, options, guard) {
  	      // Based on John Resig's `tmpl` implementation
  	      // (http://ejohn.org/blog/javascript-micro-templating/)
  	      // and Laura Doktorova's doT.js (https://github.com/olado/doT).
  	      var settings = lodash.templateSettings;

  	      if (guard && isIterateeCall(string, options, guard)) {
  	        options = undefined$1;
  	      }
  	      string = toString(string);
  	      options = assignInWith({}, options, settings, customDefaultsAssignIn);

  	      var imports = assignInWith({}, options.imports, settings.imports, customDefaultsAssignIn),
  	          importsKeys = keys(imports),
  	          importsValues = baseValues(imports, importsKeys);

  	      var isEscaping,
  	          isEvaluating,
  	          index = 0,
  	          interpolate = options.interpolate || reNoMatch,
  	          source = "__p += '";

  	      // Compile the regexp to match each delimiter.
  	      var reDelimiters = RegExp(
  	        (options.escape || reNoMatch).source + '|' +
  	        interpolate.source + '|' +
  	        (interpolate === reInterpolate ? reEsTemplate : reNoMatch).source + '|' +
  	        (options.evaluate || reNoMatch).source + '|$'
  	      , 'g');

  	      // Use a sourceURL for easier debugging.
  	      // The sourceURL gets injected into the source that's eval-ed, so be careful
  	      // to normalize all kinds of whitespace, so e.g. newlines (and unicode versions of it) can't sneak in
  	      // and escape the comment, thus injecting code that gets evaled.
  	      var sourceURL = '//# sourceURL=' +
  	        (hasOwnProperty.call(options, 'sourceURL')
  	          ? (options.sourceURL + '').replace(/\s/g, ' ')
  	          : ('lodash.templateSources[' + (++templateCounter) + ']')
  	        ) + '\n';

  	      string.replace(reDelimiters, function(match, escapeValue, interpolateValue, esTemplateValue, evaluateValue, offset) {
  	        interpolateValue || (interpolateValue = esTemplateValue);

  	        // Escape characters that can't be included in string literals.
  	        source += string.slice(index, offset).replace(reUnescapedString, escapeStringChar);

  	        // Replace delimiters with snippets.
  	        if (escapeValue) {
  	          isEscaping = true;
  	          source += "' +\n__e(" + escapeValue + ") +\n'";
  	        }
  	        if (evaluateValue) {
  	          isEvaluating = true;
  	          source += "';\n" + evaluateValue + ";\n__p += '";
  	        }
  	        if (interpolateValue) {
  	          source += "' +\n((__t = (" + interpolateValue + ")) == null ? '' : __t) +\n'";
  	        }
  	        index = offset + match.length;

  	        // The JS engine embedded in Adobe products needs `match` returned in
  	        // order to produce the correct `offset` value.
  	        return match;
  	      });

  	      source += "';\n";

  	      // If `variable` is not specified wrap a with-statement around the generated
  	      // code to add the data object to the top of the scope chain.
  	      var variable = hasOwnProperty.call(options, 'variable') && options.variable;
  	      if (!variable) {
  	        source = 'with (obj) {\n' + source + '\n}\n';
  	      }
  	      // Throw an error if a forbidden character was found in `variable`, to prevent
  	      // potential command injection attacks.
  	      else if (reForbiddenIdentifierChars.test(variable)) {
  	        throw new Error(INVALID_TEMPL_VAR_ERROR_TEXT);
  	      }

  	      // Cleanup code by stripping empty strings.
  	      source = (isEvaluating ? source.replace(reEmptyStringLeading, '') : source)
  	        .replace(reEmptyStringMiddle, '$1')
  	        .replace(reEmptyStringTrailing, '$1;');

  	      // Frame code as the function body.
  	      source = 'function(' + (variable || 'obj') + ') {\n' +
  	        (variable
  	          ? ''
  	          : 'obj || (obj = {});\n'
  	        ) +
  	        "var __t, __p = ''" +
  	        (isEscaping
  	           ? ', __e = _.escape'
  	           : ''
  	        ) +
  	        (isEvaluating
  	          ? ', __j = Array.prototype.join;\n' +
  	            "function print() { __p += __j.call(arguments, '') }\n"
  	          : ';\n'
  	        ) +
  	        source +
  	        'return __p\n}';

  	      var result = attempt(function() {
  	        return Function(importsKeys, sourceURL + 'return ' + source)
  	          .apply(undefined$1, importsValues);
  	      });

  	      // Provide the compiled function's source by its `toString` method or
  	      // the `source` property as a convenience for inlining compiled templates.
  	      result.source = source;
  	      if (isError(result)) {
  	        throw result;
  	      }
  	      return result;
  	    }

  	    /**
  	     * Converts `string`, as a whole, to lower case just like
  	     * [String#toLowerCase](https://mdn.io/toLowerCase).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the lower cased string.
  	     * @example
  	     *
  	     * _.toLower('--Foo-Bar--');
  	     * // => '--foo-bar--'
  	     *
  	     * _.toLower('fooBar');
  	     * // => 'foobar'
  	     *
  	     * _.toLower('__FOO_BAR__');
  	     * // => '__foo_bar__'
  	     */
  	    function toLower(value) {
  	      return toString(value).toLowerCase();
  	    }

  	    /**
  	     * Converts `string`, as a whole, to upper case just like
  	     * [String#toUpperCase](https://mdn.io/toUpperCase).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the upper cased string.
  	     * @example
  	     *
  	     * _.toUpper('--foo-bar--');
  	     * // => '--FOO-BAR--'
  	     *
  	     * _.toUpper('fooBar');
  	     * // => 'FOOBAR'
  	     *
  	     * _.toUpper('__foo_bar__');
  	     * // => '__FOO_BAR__'
  	     */
  	    function toUpper(value) {
  	      return toString(value).toUpperCase();
  	    }

  	    /**
  	     * Removes leading and trailing whitespace or specified characters from `string`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to trim.
  	     * @param {string} [chars=whitespace] The characters to trim.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {string} Returns the trimmed string.
  	     * @example
  	     *
  	     * _.trim('  abc  ');
  	     * // => 'abc'
  	     *
  	     * _.trim('-_-abc-_-', '_-');
  	     * // => 'abc'
  	     *
  	     * _.map(['  foo  ', '  bar  '], _.trim);
  	     * // => ['foo', 'bar']
  	     */
  	    function trim(string, chars, guard) {
  	      string = toString(string);
  	      if (string && (guard || chars === undefined$1)) {
  	        return baseTrim(string);
  	      }
  	      if (!string || !(chars = baseToString(chars))) {
  	        return string;
  	      }
  	      var strSymbols = stringToArray(string),
  	          chrSymbols = stringToArray(chars),
  	          start = charsStartIndex(strSymbols, chrSymbols),
  	          end = charsEndIndex(strSymbols, chrSymbols) + 1;

  	      return castSlice(strSymbols, start, end).join('');
  	    }

  	    /**
  	     * Removes trailing whitespace or specified characters from `string`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to trim.
  	     * @param {string} [chars=whitespace] The characters to trim.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {string} Returns the trimmed string.
  	     * @example
  	     *
  	     * _.trimEnd('  abc  ');
  	     * // => '  abc'
  	     *
  	     * _.trimEnd('-_-abc-_-', '_-');
  	     * // => '-_-abc'
  	     */
  	    function trimEnd(string, chars, guard) {
  	      string = toString(string);
  	      if (string && (guard || chars === undefined$1)) {
  	        return string.slice(0, trimmedEndIndex(string) + 1);
  	      }
  	      if (!string || !(chars = baseToString(chars))) {
  	        return string;
  	      }
  	      var strSymbols = stringToArray(string),
  	          end = charsEndIndex(strSymbols, stringToArray(chars)) + 1;

  	      return castSlice(strSymbols, 0, end).join('');
  	    }

  	    /**
  	     * Removes leading whitespace or specified characters from `string`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to trim.
  	     * @param {string} [chars=whitespace] The characters to trim.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {string} Returns the trimmed string.
  	     * @example
  	     *
  	     * _.trimStart('  abc  ');
  	     * // => 'abc  '
  	     *
  	     * _.trimStart('-_-abc-_-', '_-');
  	     * // => 'abc-_-'
  	     */
  	    function trimStart(string, chars, guard) {
  	      string = toString(string);
  	      if (string && (guard || chars === undefined$1)) {
  	        return string.replace(reTrimStart, '');
  	      }
  	      if (!string || !(chars = baseToString(chars))) {
  	        return string;
  	      }
  	      var strSymbols = stringToArray(string),
  	          start = charsStartIndex(strSymbols, stringToArray(chars));

  	      return castSlice(strSymbols, start).join('');
  	    }

  	    /**
  	     * Truncates `string` if it's longer than the given maximum string length.
  	     * The last characters of the truncated string are replaced with the omission
  	     * string which defaults to "...".
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to truncate.
  	     * @param {Object} [options={}] The options object.
  	     * @param {number} [options.length=30] The maximum string length.
  	     * @param {string} [options.omission='...'] The string to indicate text is omitted.
  	     * @param {RegExp|string} [options.separator] The separator pattern to truncate to.
  	     * @returns {string} Returns the truncated string.
  	     * @example
  	     *
  	     * _.truncate('hi-diddly-ho there, neighborino');
  	     * // => 'hi-diddly-ho there, neighbo...'
  	     *
  	     * _.truncate('hi-diddly-ho there, neighborino', {
  	     *   'length': 24,
  	     *   'separator': ' '
  	     * });
  	     * // => 'hi-diddly-ho there,...'
  	     *
  	     * _.truncate('hi-diddly-ho there, neighborino', {
  	     *   'length': 24,
  	     *   'separator': /,? +/
  	     * });
  	     * // => 'hi-diddly-ho there...'
  	     *
  	     * _.truncate('hi-diddly-ho there, neighborino', {
  	     *   'omission': ' [...]'
  	     * });
  	     * // => 'hi-diddly-ho there, neig [...]'
  	     */
  	    function truncate(string, options) {
  	      var length = DEFAULT_TRUNC_LENGTH,
  	          omission = DEFAULT_TRUNC_OMISSION;

  	      if (isObject(options)) {
  	        var separator = 'separator' in options ? options.separator : separator;
  	        length = 'length' in options ? toInteger(options.length) : length;
  	        omission = 'omission' in options ? baseToString(options.omission) : omission;
  	      }
  	      string = toString(string);

  	      var strLength = string.length;
  	      if (hasUnicode(string)) {
  	        var strSymbols = stringToArray(string);
  	        strLength = strSymbols.length;
  	      }
  	      if (length >= strLength) {
  	        return string;
  	      }
  	      var end = length - stringSize(omission);
  	      if (end < 1) {
  	        return omission;
  	      }
  	      var result = strSymbols
  	        ? castSlice(strSymbols, 0, end).join('')
  	        : string.slice(0, end);

  	      if (separator === undefined$1) {
  	        return result + omission;
  	      }
  	      if (strSymbols) {
  	        end += (result.length - end);
  	      }
  	      if (isRegExp(separator)) {
  	        if (string.slice(end).search(separator)) {
  	          var match,
  	              substring = result;

  	          if (!separator.global) {
  	            separator = RegExp(separator.source, toString(reFlags.exec(separator)) + 'g');
  	          }
  	          separator.lastIndex = 0;
  	          while ((match = separator.exec(substring))) {
  	            var newEnd = match.index;
  	          }
  	          result = result.slice(0, newEnd === undefined$1 ? end : newEnd);
  	        }
  	      } else if (string.indexOf(baseToString(separator), end) != end) {
  	        var index = result.lastIndexOf(separator);
  	        if (index > -1) {
  	          result = result.slice(0, index);
  	        }
  	      }
  	      return result + omission;
  	    }

  	    /**
  	     * The inverse of `_.escape`; this method converts the HTML entities
  	     * `&amp;`, `&lt;`, `&gt;`, `&quot;`, and `&#39;` in `string` to
  	     * their corresponding characters.
  	     *
  	     * **Note:** No other HTML entities are unescaped. To unescape additional
  	     * HTML entities use a third-party library like [_he_](https://mths.be/he).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 0.6.0
  	     * @category String
  	     * @param {string} [string=''] The string to unescape.
  	     * @returns {string} Returns the unescaped string.
  	     * @example
  	     *
  	     * _.unescape('fred, barney, &amp; pebbles');
  	     * // => 'fred, barney, & pebbles'
  	     */
  	    function unescape(string) {
  	      string = toString(string);
  	      return (string && reHasEscapedHtml.test(string))
  	        ? string.replace(reEscapedHtml, unescapeHtmlChar)
  	        : string;
  	    }

  	    /**
  	     * Converts `string`, as space separated words, to upper case.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the upper cased string.
  	     * @example
  	     *
  	     * _.upperCase('--foo-bar');
  	     * // => 'FOO BAR'
  	     *
  	     * _.upperCase('fooBar');
  	     * // => 'FOO BAR'
  	     *
  	     * _.upperCase('__foo_bar__');
  	     * // => 'FOO BAR'
  	     */
  	    var upperCase = createCompounder(function(result, word, index) {
  	      return result + (index ? ' ' : '') + word.toUpperCase();
  	    });

  	    /**
  	     * Converts the first character of `string` to upper case.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to convert.
  	     * @returns {string} Returns the converted string.
  	     * @example
  	     *
  	     * _.upperFirst('fred');
  	     * // => 'Fred'
  	     *
  	     * _.upperFirst('FRED');
  	     * // => 'FRED'
  	     */
  	    var upperFirst = createCaseFirst('toUpperCase');

  	    /**
  	     * Splits `string` into an array of its words.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category String
  	     * @param {string} [string=''] The string to inspect.
  	     * @param {RegExp|string} [pattern] The pattern to match words.
  	     * @param- {Object} [guard] Enables use as an iteratee for methods like `_.map`.
  	     * @returns {Array} Returns the words of `string`.
  	     * @example
  	     *
  	     * _.words('fred, barney, & pebbles');
  	     * // => ['fred', 'barney', 'pebbles']
  	     *
  	     * _.words('fred, barney, & pebbles', /[^, ]+/g);
  	     * // => ['fred', 'barney', '&', 'pebbles']
  	     */
  	    function words(string, pattern, guard) {
  	      string = toString(string);
  	      pattern = guard ? undefined$1 : pattern;

  	      if (pattern === undefined$1) {
  	        return hasUnicodeWord(string) ? unicodeWords(string) : asciiWords(string);
  	      }
  	      return string.match(pattern) || [];
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Attempts to invoke `func`, returning either the result or the caught error
  	     * object. Any additional arguments are provided to `func` when it's invoked.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Util
  	     * @param {Function} func The function to attempt.
  	     * @param {...*} [args] The arguments to invoke `func` with.
  	     * @returns {*} Returns the `func` result or error object.
  	     * @example
  	     *
  	     * // Avoid throwing errors for invalid selectors.
  	     * var elements = _.attempt(function(selector) {
  	     *   return document.querySelectorAll(selector);
  	     * }, '>_>');
  	     *
  	     * if (_.isError(elements)) {
  	     *   elements = [];
  	     * }
  	     */
  	    var attempt = baseRest(function(func, args) {
  	      try {
  	        return apply(func, undefined$1, args);
  	      } catch (e) {
  	        return isError(e) ? e : new Error(e);
  	      }
  	    });

  	    /**
  	     * Binds methods of an object to the object itself, overwriting the existing
  	     * method.
  	     *
  	     * **Note:** This method doesn't set the "length" property of bound functions.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {Object} object The object to bind and assign the bound methods to.
  	     * @param {...(string|string[])} methodNames The object method names to bind.
  	     * @returns {Object} Returns `object`.
  	     * @example
  	     *
  	     * var view = {
  	     *   'label': 'docs',
  	     *   'click': function() {
  	     *     console.log('clicked ' + this.label);
  	     *   }
  	     * };
  	     *
  	     * _.bindAll(view, ['click']);
  	     * jQuery(element).on('click', view.click);
  	     * // => Logs 'clicked docs' when clicked.
  	     */
  	    var bindAll = flatRest(function(object, methodNames) {
  	      arrayEach(methodNames, function(key) {
  	        key = toKey(key);
  	        baseAssignValue(object, key, bind(object[key], object));
  	      });
  	      return object;
  	    });

  	    /**
  	     * Creates a function that iterates over `pairs` and invokes the corresponding
  	     * function of the first predicate to return truthy. The predicate-function
  	     * pairs are invoked with the `this` binding and arguments of the created
  	     * function.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {Array} pairs The predicate-function pairs.
  	     * @returns {Function} Returns the new composite function.
  	     * @example
  	     *
  	     * var func = _.cond([
  	     *   [_.matches({ 'a': 1 }),           _.constant('matches A')],
  	     *   [_.conforms({ 'b': _.isNumber }), _.constant('matches B')],
  	     *   [_.stubTrue,                      _.constant('no match')]
  	     * ]);
  	     *
  	     * func({ 'a': 1, 'b': 2 });
  	     * // => 'matches A'
  	     *
  	     * func({ 'a': 0, 'b': 1 });
  	     * // => 'matches B'
  	     *
  	     * func({ 'a': '1', 'b': '2' });
  	     * // => 'no match'
  	     */
  	    function cond(pairs) {
  	      var length = pairs == null ? 0 : pairs.length,
  	          toIteratee = getIteratee();

  	      pairs = !length ? [] : arrayMap(pairs, function(pair) {
  	        if (typeof pair[1] != 'function') {
  	          throw new TypeError(FUNC_ERROR_TEXT);
  	        }
  	        return [toIteratee(pair[0]), pair[1]];
  	      });

  	      return baseRest(function(args) {
  	        var index = -1;
  	        while (++index < length) {
  	          var pair = pairs[index];
  	          if (apply(pair[0], this, args)) {
  	            return apply(pair[1], this, args);
  	          }
  	        }
  	      });
  	    }

  	    /**
  	     * Creates a function that invokes the predicate properties of `source` with
  	     * the corresponding property values of a given object, returning `true` if
  	     * all predicates return truthy, else `false`.
  	     *
  	     * **Note:** The created function is equivalent to `_.conformsTo` with
  	     * `source` partially applied.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {Object} source The object of property predicates to conform to.
  	     * @returns {Function} Returns the new spec function.
  	     * @example
  	     *
  	     * var objects = [
  	     *   { 'a': 2, 'b': 1 },
  	     *   { 'a': 1, 'b': 2 }
  	     * ];
  	     *
  	     * _.filter(objects, _.conforms({ 'b': function(n) { return n > 1; } }));
  	     * // => [{ 'a': 1, 'b': 2 }]
  	     */
  	    function conforms(source) {
  	      return baseConforms(baseClone(source, CLONE_DEEP_FLAG));
  	    }

  	    /**
  	     * Creates a function that returns `value`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.4.0
  	     * @category Util
  	     * @param {*} value The value to return from the new function.
  	     * @returns {Function} Returns the new constant function.
  	     * @example
  	     *
  	     * var objects = _.times(2, _.constant({ 'a': 1 }));
  	     *
  	     * console.log(objects);
  	     * // => [{ 'a': 1 }, { 'a': 1 }]
  	     *
  	     * console.log(objects[0] === objects[1]);
  	     * // => true
  	     */
  	    function constant(value) {
  	      return function() {
  	        return value;
  	      };
  	    }

  	    /**
  	     * Checks `value` to determine whether a default value should be returned in
  	     * its place. The `defaultValue` is returned if `value` is `NaN`, `null`,
  	     * or `undefined`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.14.0
  	     * @category Util
  	     * @param {*} value The value to check.
  	     * @param {*} defaultValue The default value.
  	     * @returns {*} Returns the resolved value.
  	     * @example
  	     *
  	     * _.defaultTo(1, 10);
  	     * // => 1
  	     *
  	     * _.defaultTo(undefined, 10);
  	     * // => 10
  	     */
  	    function defaultTo(value, defaultValue) {
  	      return (value == null || value !== value) ? defaultValue : value;
  	    }

  	    /**
  	     * Creates a function that returns the result of invoking the given functions
  	     * with the `this` binding of the created function, where each successive
  	     * invocation is supplied the return value of the previous.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Util
  	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
  	     * @returns {Function} Returns the new composite function.
  	     * @see _.flowRight
  	     * @example
  	     *
  	     * function square(n) {
  	     *   return n * n;
  	     * }
  	     *
  	     * var addSquare = _.flow([_.add, square]);
  	     * addSquare(1, 2);
  	     * // => 9
  	     */
  	    var flow = createFlow();

  	    /**
  	     * This method is like `_.flow` except that it creates a function that
  	     * invokes the given functions from right to left.
  	     *
  	     * @static
  	     * @since 3.0.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {...(Function|Function[])} [funcs] The functions to invoke.
  	     * @returns {Function} Returns the new composite function.
  	     * @see _.flow
  	     * @example
  	     *
  	     * function square(n) {
  	     *   return n * n;
  	     * }
  	     *
  	     * var addSquare = _.flowRight([square, _.add]);
  	     * addSquare(1, 2);
  	     * // => 9
  	     */
  	    var flowRight = createFlow(true);

  	    /**
  	     * This method returns the first argument it receives.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {*} value Any value.
  	     * @returns {*} Returns `value`.
  	     * @example
  	     *
  	     * var object = { 'a': 1 };
  	     *
  	     * console.log(_.identity(object) === object);
  	     * // => true
  	     */
  	    function identity(value) {
  	      return value;
  	    }

  	    /**
  	     * Creates a function that invokes `func` with the arguments of the created
  	     * function. If `func` is a property name, the created function returns the
  	     * property value for a given element. If `func` is an array or object, the
  	     * created function returns `true` for elements that contain the equivalent
  	     * source properties, otherwise it returns `false`.
  	     *
  	     * @static
  	     * @since 4.0.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {*} [func=_.identity] The value to convert to a callback.
  	     * @returns {Function} Returns the callback.
  	     * @example
  	     *
  	     * var users = [
  	     *   { 'user': 'barney', 'age': 36, 'active': true },
  	     *   { 'user': 'fred',   'age': 40, 'active': false }
  	     * ];
  	     *
  	     * // The `_.matches` iteratee shorthand.
  	     * _.filter(users, _.iteratee({ 'user': 'barney', 'active': true }));
  	     * // => [{ 'user': 'barney', 'age': 36, 'active': true }]
  	     *
  	     * // The `_.matchesProperty` iteratee shorthand.
  	     * _.filter(users, _.iteratee(['user', 'fred']));
  	     * // => [{ 'user': 'fred', 'age': 40 }]
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.map(users, _.iteratee('user'));
  	     * // => ['barney', 'fred']
  	     *
  	     * // Create custom iteratee shorthands.
  	     * _.iteratee = _.wrap(_.iteratee, function(iteratee, func) {
  	     *   return !_.isRegExp(func) ? iteratee(func) : function(string) {
  	     *     return func.test(string);
  	     *   };
  	     * });
  	     *
  	     * _.filter(['abc', 'def'], /ef/);
  	     * // => ['def']
  	     */
  	    function iteratee(func) {
  	      return baseIteratee(typeof func == 'function' ? func : baseClone(func, CLONE_DEEP_FLAG));
  	    }

  	    /**
  	     * Creates a function that performs a partial deep comparison between a given
  	     * object and `source`, returning `true` if the given object has equivalent
  	     * property values, else `false`.
  	     *
  	     * **Note:** The created function is equivalent to `_.isMatch` with `source`
  	     * partially applied.
  	     *
  	     * Partial comparisons will match empty array and empty object `source`
  	     * values against any array or object value, respectively. See `_.isEqual`
  	     * for a list of supported value comparisons.
  	     *
  	     * **Note:** Multiple values can be checked by combining several matchers
  	     * using `_.overSome`
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Util
  	     * @param {Object} source The object of property values to match.
  	     * @returns {Function} Returns the new spec function.
  	     * @example
  	     *
  	     * var objects = [
  	     *   { 'a': 1, 'b': 2, 'c': 3 },
  	     *   { 'a': 4, 'b': 5, 'c': 6 }
  	     * ];
  	     *
  	     * _.filter(objects, _.matches({ 'a': 4, 'c': 6 }));
  	     * // => [{ 'a': 4, 'b': 5, 'c': 6 }]
  	     *
  	     * // Checking for several possible values
  	     * _.filter(objects, _.overSome([_.matches({ 'a': 1 }), _.matches({ 'a': 4 })]));
  	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
  	     */
  	    function matches(source) {
  	      return baseMatches(baseClone(source, CLONE_DEEP_FLAG));
  	    }

  	    /**
  	     * Creates a function that performs a partial deep comparison between the
  	     * value at `path` of a given object to `srcValue`, returning `true` if the
  	     * object value is equivalent, else `false`.
  	     *
  	     * **Note:** Partial comparisons will match empty array and empty object
  	     * `srcValue` values against any array or object value, respectively. See
  	     * `_.isEqual` for a list of supported value comparisons.
  	     *
  	     * **Note:** Multiple values can be checked by combining several matchers
  	     * using `_.overSome`
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.2.0
  	     * @category Util
  	     * @param {Array|string} path The path of the property to get.
  	     * @param {*} srcValue The value to match.
  	     * @returns {Function} Returns the new spec function.
  	     * @example
  	     *
  	     * var objects = [
  	     *   { 'a': 1, 'b': 2, 'c': 3 },
  	     *   { 'a': 4, 'b': 5, 'c': 6 }
  	     * ];
  	     *
  	     * _.find(objects, _.matchesProperty('a', 4));
  	     * // => { 'a': 4, 'b': 5, 'c': 6 }
  	     *
  	     * // Checking for several possible values
  	     * _.filter(objects, _.overSome([_.matchesProperty('a', 1), _.matchesProperty('a', 4)]));
  	     * // => [{ 'a': 1, 'b': 2, 'c': 3 }, { 'a': 4, 'b': 5, 'c': 6 }]
  	     */
  	    function matchesProperty(path, srcValue) {
  	      return baseMatchesProperty(path, baseClone(srcValue, CLONE_DEEP_FLAG));
  	    }

  	    /**
  	     * Creates a function that invokes the method at `path` of a given object.
  	     * Any additional arguments are provided to the invoked method.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.7.0
  	     * @category Util
  	     * @param {Array|string} path The path of the method to invoke.
  	     * @param {...*} [args] The arguments to invoke the method with.
  	     * @returns {Function} Returns the new invoker function.
  	     * @example
  	     *
  	     * var objects = [
  	     *   { 'a': { 'b': _.constant(2) } },
  	     *   { 'a': { 'b': _.constant(1) } }
  	     * ];
  	     *
  	     * _.map(objects, _.method('a.b'));
  	     * // => [2, 1]
  	     *
  	     * _.map(objects, _.method(['a', 'b']));
  	     * // => [2, 1]
  	     */
  	    var method = baseRest(function(path, args) {
  	      return function(object) {
  	        return baseInvoke(object, path, args);
  	      };
  	    });

  	    /**
  	     * The opposite of `_.method`; this method creates a function that invokes
  	     * the method at a given path of `object`. Any additional arguments are
  	     * provided to the invoked method.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.7.0
  	     * @category Util
  	     * @param {Object} object The object to query.
  	     * @param {...*} [args] The arguments to invoke the method with.
  	     * @returns {Function} Returns the new invoker function.
  	     * @example
  	     *
  	     * var array = _.times(3, _.constant),
  	     *     object = { 'a': array, 'b': array, 'c': array };
  	     *
  	     * _.map(['a[2]', 'c[0]'], _.methodOf(object));
  	     * // => [2, 0]
  	     *
  	     * _.map([['a', '2'], ['c', '0']], _.methodOf(object));
  	     * // => [2, 0]
  	     */
  	    var methodOf = baseRest(function(object, args) {
  	      return function(path) {
  	        return baseInvoke(object, path, args);
  	      };
  	    });

  	    /**
  	     * Adds all own enumerable string keyed function properties of a source
  	     * object to the destination object. If `object` is a function, then methods
  	     * are added to its prototype as well.
  	     *
  	     * **Note:** Use `_.runInContext` to create a pristine `lodash` function to
  	     * avoid conflicts caused by modifying the original.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {Function|Object} [object=lodash] The destination object.
  	     * @param {Object} source The object of functions to add.
  	     * @param {Object} [options={}] The options object.
  	     * @param {boolean} [options.chain=true] Specify whether mixins are chainable.
  	     * @returns {Function|Object} Returns `object`.
  	     * @example
  	     *
  	     * function vowels(string) {
  	     *   return _.filter(string, function(v) {
  	     *     return /[aeiou]/i.test(v);
  	     *   });
  	     * }
  	     *
  	     * _.mixin({ 'vowels': vowels });
  	     * _.vowels('fred');
  	     * // => ['e']
  	     *
  	     * _('fred').vowels().value();
  	     * // => ['e']
  	     *
  	     * _.mixin({ 'vowels': vowels }, { 'chain': false });
  	     * _('fred').vowels();
  	     * // => ['e']
  	     */
  	    function mixin(object, source, options) {
  	      var props = keys(source),
  	          methodNames = baseFunctions(source, props);

  	      if (options == null &&
  	          !(isObject(source) && (methodNames.length || !props.length))) {
  	        options = source;
  	        source = object;
  	        object = this;
  	        methodNames = baseFunctions(source, keys(source));
  	      }
  	      var chain = !(isObject(options) && 'chain' in options) || !!options.chain,
  	          isFunc = isFunction(object);

  	      arrayEach(methodNames, function(methodName) {
  	        var func = source[methodName];
  	        object[methodName] = func;
  	        if (isFunc) {
  	          object.prototype[methodName] = function() {
  	            var chainAll = this.__chain__;
  	            if (chain || chainAll) {
  	              var result = object(this.__wrapped__),
  	                  actions = result.__actions__ = copyArray(this.__actions__);

  	              actions.push({ 'func': func, 'args': arguments, 'thisArg': object });
  	              result.__chain__ = chainAll;
  	              return result;
  	            }
  	            return func.apply(object, arrayPush([this.value()], arguments));
  	          };
  	        }
  	      });

  	      return object;
  	    }

  	    /**
  	     * Reverts the `_` variable to its previous value and returns a reference to
  	     * the `lodash` function.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @returns {Function} Returns the `lodash` function.
  	     * @example
  	     *
  	     * var lodash = _.noConflict();
  	     */
  	    function noConflict() {
  	      if (root._ === this) {
  	        root._ = oldDash;
  	      }
  	      return this;
  	    }

  	    /**
  	     * This method returns `undefined`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.3.0
  	     * @category Util
  	     * @example
  	     *
  	     * _.times(2, _.noop);
  	     * // => [undefined, undefined]
  	     */
  	    function noop() {
  	      // No operation performed.
  	    }

  	    /**
  	     * Creates a function that gets the argument at index `n`. If `n` is negative,
  	     * the nth argument from the end is returned.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {number} [n=0] The index of the argument to return.
  	     * @returns {Function} Returns the new pass-thru function.
  	     * @example
  	     *
  	     * var func = _.nthArg(1);
  	     * func('a', 'b', 'c', 'd');
  	     * // => 'b'
  	     *
  	     * var func = _.nthArg(-2);
  	     * func('a', 'b', 'c', 'd');
  	     * // => 'c'
  	     */
  	    function nthArg(n) {
  	      n = toInteger(n);
  	      return baseRest(function(args) {
  	        return baseNth(args, n);
  	      });
  	    }

  	    /**
  	     * Creates a function that invokes `iteratees` with the arguments it receives
  	     * and returns their results.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {...(Function|Function[])} [iteratees=[_.identity]]
  	     *  The iteratees to invoke.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var func = _.over([Math.max, Math.min]);
  	     *
  	     * func(1, 2, 3, 4);
  	     * // => [4, 1]
  	     */
  	    var over = createOver(arrayMap);

  	    /**
  	     * Creates a function that checks if **all** of the `predicates` return
  	     * truthy when invoked with the arguments it receives.
  	     *
  	     * Following shorthands are possible for providing predicates.
  	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
  	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {...(Function|Function[])} [predicates=[_.identity]]
  	     *  The predicates to check.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var func = _.overEvery([Boolean, isFinite]);
  	     *
  	     * func('1');
  	     * // => true
  	     *
  	     * func(null);
  	     * // => false
  	     *
  	     * func(NaN);
  	     * // => false
  	     */
  	    var overEvery = createOver(arrayEvery);

  	    /**
  	     * Creates a function that checks if **any** of the `predicates` return
  	     * truthy when invoked with the arguments it receives.
  	     *
  	     * Following shorthands are possible for providing predicates.
  	     * Pass an `Object` and it will be used as an parameter for `_.matches` to create the predicate.
  	     * Pass an `Array` of parameters for `_.matchesProperty` and the predicate will be created using them.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {...(Function|Function[])} [predicates=[_.identity]]
  	     *  The predicates to check.
  	     * @returns {Function} Returns the new function.
  	     * @example
  	     *
  	     * var func = _.overSome([Boolean, isFinite]);
  	     *
  	     * func('1');
  	     * // => true
  	     *
  	     * func(null);
  	     * // => true
  	     *
  	     * func(NaN);
  	     * // => false
  	     *
  	     * var matchesFunc = _.overSome([{ 'a': 1 }, { 'a': 2 }])
  	     * var matchesPropertyFunc = _.overSome([['a', 1], ['a', 2]])
  	     */
  	    var overSome = createOver(arraySome);

  	    /**
  	     * Creates a function that returns the value at `path` of a given object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 2.4.0
  	     * @category Util
  	     * @param {Array|string} path The path of the property to get.
  	     * @returns {Function} Returns the new accessor function.
  	     * @example
  	     *
  	     * var objects = [
  	     *   { 'a': { 'b': 2 } },
  	     *   { 'a': { 'b': 1 } }
  	     * ];
  	     *
  	     * _.map(objects, _.property('a.b'));
  	     * // => [2, 1]
  	     *
  	     * _.map(_.sortBy(objects, _.property(['a', 'b'])), 'a.b');
  	     * // => [1, 2]
  	     */
  	    function property(path) {
  	      return isKey(path) ? baseProperty(toKey(path)) : basePropertyDeep(path);
  	    }

  	    /**
  	     * The opposite of `_.property`; this method creates a function that returns
  	     * the value at a given path of `object`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.0.0
  	     * @category Util
  	     * @param {Object} object The object to query.
  	     * @returns {Function} Returns the new accessor function.
  	     * @example
  	     *
  	     * var array = [0, 1, 2],
  	     *     object = { 'a': array, 'b': array, 'c': array };
  	     *
  	     * _.map(['a[2]', 'c[0]'], _.propertyOf(object));
  	     * // => [2, 0]
  	     *
  	     * _.map([['a', '2'], ['c', '0']], _.propertyOf(object));
  	     * // => [2, 0]
  	     */
  	    function propertyOf(object) {
  	      return function(path) {
  	        return object == null ? undefined$1 : baseGet(object, path);
  	      };
  	    }

  	    /**
  	     * Creates an array of numbers (positive and/or negative) progressing from
  	     * `start` up to, but not including, `end`. A step of `-1` is used if a negative
  	     * `start` is specified without an `end` or `step`. If `end` is not specified,
  	     * it's set to `start` with `start` then set to `0`.
  	     *
  	     * **Note:** JavaScript follows the IEEE-754 standard for resolving
  	     * floating-point values which can produce unexpected results.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {number} [start=0] The start of the range.
  	     * @param {number} end The end of the range.
  	     * @param {number} [step=1] The value to increment or decrement by.
  	     * @returns {Array} Returns the range of numbers.
  	     * @see _.inRange, _.rangeRight
  	     * @example
  	     *
  	     * _.range(4);
  	     * // => [0, 1, 2, 3]
  	     *
  	     * _.range(-4);
  	     * // => [0, -1, -2, -3]
  	     *
  	     * _.range(1, 5);
  	     * // => [1, 2, 3, 4]
  	     *
  	     * _.range(0, 20, 5);
  	     * // => [0, 5, 10, 15]
  	     *
  	     * _.range(0, -4, -1);
  	     * // => [0, -1, -2, -3]
  	     *
  	     * _.range(1, 4, 0);
  	     * // => [1, 1, 1]
  	     *
  	     * _.range(0);
  	     * // => []
  	     */
  	    var range = createRange();

  	    /**
  	     * This method is like `_.range` except that it populates values in
  	     * descending order.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {number} [start=0] The start of the range.
  	     * @param {number} end The end of the range.
  	     * @param {number} [step=1] The value to increment or decrement by.
  	     * @returns {Array} Returns the range of numbers.
  	     * @see _.inRange, _.range
  	     * @example
  	     *
  	     * _.rangeRight(4);
  	     * // => [3, 2, 1, 0]
  	     *
  	     * _.rangeRight(-4);
  	     * // => [-3, -2, -1, 0]
  	     *
  	     * _.rangeRight(1, 5);
  	     * // => [4, 3, 2, 1]
  	     *
  	     * _.rangeRight(0, 20, 5);
  	     * // => [15, 10, 5, 0]
  	     *
  	     * _.rangeRight(0, -4, -1);
  	     * // => [-3, -2, -1, 0]
  	     *
  	     * _.rangeRight(1, 4, 0);
  	     * // => [1, 1, 1]
  	     *
  	     * _.rangeRight(0);
  	     * // => []
  	     */
  	    var rangeRight = createRange(true);

  	    /**
  	     * This method returns a new empty array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.13.0
  	     * @category Util
  	     * @returns {Array} Returns the new empty array.
  	     * @example
  	     *
  	     * var arrays = _.times(2, _.stubArray);
  	     *
  	     * console.log(arrays);
  	     * // => [[], []]
  	     *
  	     * console.log(arrays[0] === arrays[1]);
  	     * // => false
  	     */
  	    function stubArray() {
  	      return [];
  	    }

  	    /**
  	     * This method returns `false`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.13.0
  	     * @category Util
  	     * @returns {boolean} Returns `false`.
  	     * @example
  	     *
  	     * _.times(2, _.stubFalse);
  	     * // => [false, false]
  	     */
  	    function stubFalse() {
  	      return false;
  	    }

  	    /**
  	     * This method returns a new empty object.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.13.0
  	     * @category Util
  	     * @returns {Object} Returns the new empty object.
  	     * @example
  	     *
  	     * var objects = _.times(2, _.stubObject);
  	     *
  	     * console.log(objects);
  	     * // => [{}, {}]
  	     *
  	     * console.log(objects[0] === objects[1]);
  	     * // => false
  	     */
  	    function stubObject() {
  	      return {};
  	    }

  	    /**
  	     * This method returns an empty string.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.13.0
  	     * @category Util
  	     * @returns {string} Returns the empty string.
  	     * @example
  	     *
  	     * _.times(2, _.stubString);
  	     * // => ['', '']
  	     */
  	    function stubString() {
  	      return '';
  	    }

  	    /**
  	     * This method returns `true`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.13.0
  	     * @category Util
  	     * @returns {boolean} Returns `true`.
  	     * @example
  	     *
  	     * _.times(2, _.stubTrue);
  	     * // => [true, true]
  	     */
  	    function stubTrue() {
  	      return true;
  	    }

  	    /**
  	     * Invokes the iteratee `n` times, returning an array of the results of
  	     * each invocation. The iteratee is invoked with one argument; (index).
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {number} n The number of times to invoke `iteratee`.
  	     * @param {Function} [iteratee=_.identity] The function invoked per iteration.
  	     * @returns {Array} Returns the array of results.
  	     * @example
  	     *
  	     * _.times(3, String);
  	     * // => ['0', '1', '2']
  	     *
  	     *  _.times(4, _.constant(0));
  	     * // => [0, 0, 0, 0]
  	     */
  	    function times(n, iteratee) {
  	      n = toInteger(n);
  	      if (n < 1 || n > MAX_SAFE_INTEGER) {
  	        return [];
  	      }
  	      var index = MAX_ARRAY_LENGTH,
  	          length = nativeMin(n, MAX_ARRAY_LENGTH);

  	      iteratee = getIteratee(iteratee);
  	      n -= MAX_ARRAY_LENGTH;

  	      var result = baseTimes(length, iteratee);
  	      while (++index < n) {
  	        iteratee(index);
  	      }
  	      return result;
  	    }

  	    /**
  	     * Converts `value` to a property path array.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Util
  	     * @param {*} value The value to convert.
  	     * @returns {Array} Returns the new property path array.
  	     * @example
  	     *
  	     * _.toPath('a.b.c');
  	     * // => ['a', 'b', 'c']
  	     *
  	     * _.toPath('a[0].b.c');
  	     * // => ['a', '0', 'b', 'c']
  	     */
  	    function toPath(value) {
  	      if (isArray(value)) {
  	        return arrayMap(value, toKey);
  	      }
  	      return isSymbol(value) ? [value] : copyArray(stringToPath(toString(value)));
  	    }

  	    /**
  	     * Generates a unique ID. If `prefix` is given, the ID is appended to it.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Util
  	     * @param {string} [prefix=''] The value to prefix the ID with.
  	     * @returns {string} Returns the unique ID.
  	     * @example
  	     *
  	     * _.uniqueId('contact_');
  	     * // => 'contact_104'
  	     *
  	     * _.uniqueId();
  	     * // => '105'
  	     */
  	    function uniqueId(prefix) {
  	      var id = ++idCounter;
  	      return toString(prefix) + id;
  	    }

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * Adds two numbers.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.4.0
  	     * @category Math
  	     * @param {number} augend The first number in an addition.
  	     * @param {number} addend The second number in an addition.
  	     * @returns {number} Returns the total.
  	     * @example
  	     *
  	     * _.add(6, 4);
  	     * // => 10
  	     */
  	    var add = createMathOperation(function(augend, addend) {
  	      return augend + addend;
  	    }, 0);

  	    /**
  	     * Computes `number` rounded up to `precision`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.10.0
  	     * @category Math
  	     * @param {number} number The number to round up.
  	     * @param {number} [precision=0] The precision to round up to.
  	     * @returns {number} Returns the rounded up number.
  	     * @example
  	     *
  	     * _.ceil(4.006);
  	     * // => 5
  	     *
  	     * _.ceil(6.004, 2);
  	     * // => 6.01
  	     *
  	     * _.ceil(6040, -2);
  	     * // => 6100
  	     */
  	    var ceil = createRound('ceil');

  	    /**
  	     * Divide two numbers.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.7.0
  	     * @category Math
  	     * @param {number} dividend The first number in a division.
  	     * @param {number} divisor The second number in a division.
  	     * @returns {number} Returns the quotient.
  	     * @example
  	     *
  	     * _.divide(6, 4);
  	     * // => 1.5
  	     */
  	    var divide = createMathOperation(function(dividend, divisor) {
  	      return dividend / divisor;
  	    }, 1);

  	    /**
  	     * Computes `number` rounded down to `precision`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.10.0
  	     * @category Math
  	     * @param {number} number The number to round down.
  	     * @param {number} [precision=0] The precision to round down to.
  	     * @returns {number} Returns the rounded down number.
  	     * @example
  	     *
  	     * _.floor(4.006);
  	     * // => 4
  	     *
  	     * _.floor(0.046, 2);
  	     * // => 0.04
  	     *
  	     * _.floor(4060, -2);
  	     * // => 4000
  	     */
  	    var floor = createRound('floor');

  	    /**
  	     * Computes the maximum value of `array`. If `array` is empty or falsey,
  	     * `undefined` is returned.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @returns {*} Returns the maximum value.
  	     * @example
  	     *
  	     * _.max([4, 2, 8, 6]);
  	     * // => 8
  	     *
  	     * _.max([]);
  	     * // => undefined
  	     */
  	    function max(array) {
  	      return (array && array.length)
  	        ? baseExtremum(array, identity, baseGt)
  	        : undefined$1;
  	    }

  	    /**
  	     * This method is like `_.max` except that it accepts `iteratee` which is
  	     * invoked for each element in `array` to generate the criterion by which
  	     * the value is ranked. The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {*} Returns the maximum value.
  	     * @example
  	     *
  	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
  	     *
  	     * _.maxBy(objects, function(o) { return o.n; });
  	     * // => { 'n': 2 }
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.maxBy(objects, 'n');
  	     * // => { 'n': 2 }
  	     */
  	    function maxBy(array, iteratee) {
  	      return (array && array.length)
  	        ? baseExtremum(array, getIteratee(iteratee, 2), baseGt)
  	        : undefined$1;
  	    }

  	    /**
  	     * Computes the mean of the values in `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @returns {number} Returns the mean.
  	     * @example
  	     *
  	     * _.mean([4, 2, 8, 6]);
  	     * // => 5
  	     */
  	    function mean(array) {
  	      return baseMean(array, identity);
  	    }

  	    /**
  	     * This method is like `_.mean` except that it accepts `iteratee` which is
  	     * invoked for each element in `array` to generate the value to be averaged.
  	     * The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.7.0
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {number} Returns the mean.
  	     * @example
  	     *
  	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
  	     *
  	     * _.meanBy(objects, function(o) { return o.n; });
  	     * // => 5
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.meanBy(objects, 'n');
  	     * // => 5
  	     */
  	    function meanBy(array, iteratee) {
  	      return baseMean(array, getIteratee(iteratee, 2));
  	    }

  	    /**
  	     * Computes the minimum value of `array`. If `array` is empty or falsey,
  	     * `undefined` is returned.
  	     *
  	     * @static
  	     * @since 0.1.0
  	     * @memberOf _
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @returns {*} Returns the minimum value.
  	     * @example
  	     *
  	     * _.min([4, 2, 8, 6]);
  	     * // => 2
  	     *
  	     * _.min([]);
  	     * // => undefined
  	     */
  	    function min(array) {
  	      return (array && array.length)
  	        ? baseExtremum(array, identity, baseLt)
  	        : undefined$1;
  	    }

  	    /**
  	     * This method is like `_.min` except that it accepts `iteratee` which is
  	     * invoked for each element in `array` to generate the criterion by which
  	     * the value is ranked. The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {*} Returns the minimum value.
  	     * @example
  	     *
  	     * var objects = [{ 'n': 1 }, { 'n': 2 }];
  	     *
  	     * _.minBy(objects, function(o) { return o.n; });
  	     * // => { 'n': 1 }
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.minBy(objects, 'n');
  	     * // => { 'n': 1 }
  	     */
  	    function minBy(array, iteratee) {
  	      return (array && array.length)
  	        ? baseExtremum(array, getIteratee(iteratee, 2), baseLt)
  	        : undefined$1;
  	    }

  	    /**
  	     * Multiply two numbers.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.7.0
  	     * @category Math
  	     * @param {number} multiplier The first number in a multiplication.
  	     * @param {number} multiplicand The second number in a multiplication.
  	     * @returns {number} Returns the product.
  	     * @example
  	     *
  	     * _.multiply(6, 4);
  	     * // => 24
  	     */
  	    var multiply = createMathOperation(function(multiplier, multiplicand) {
  	      return multiplier * multiplicand;
  	    }, 1);

  	    /**
  	     * Computes `number` rounded to `precision`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.10.0
  	     * @category Math
  	     * @param {number} number The number to round.
  	     * @param {number} [precision=0] The precision to round to.
  	     * @returns {number} Returns the rounded number.
  	     * @example
  	     *
  	     * _.round(4.006);
  	     * // => 4
  	     *
  	     * _.round(4.006, 2);
  	     * // => 4.01
  	     *
  	     * _.round(4060, -2);
  	     * // => 4100
  	     */
  	    var round = createRound('round');

  	    /**
  	     * Subtract two numbers.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Math
  	     * @param {number} minuend The first number in a subtraction.
  	     * @param {number} subtrahend The second number in a subtraction.
  	     * @returns {number} Returns the difference.
  	     * @example
  	     *
  	     * _.subtract(6, 4);
  	     * // => 2
  	     */
  	    var subtract = createMathOperation(function(minuend, subtrahend) {
  	      return minuend - subtrahend;
  	    }, 0);

  	    /**
  	     * Computes the sum of the values in `array`.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 3.4.0
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @returns {number} Returns the sum.
  	     * @example
  	     *
  	     * _.sum([4, 2, 8, 6]);
  	     * // => 20
  	     */
  	    function sum(array) {
  	      return (array && array.length)
  	        ? baseSum(array, identity)
  	        : 0;
  	    }

  	    /**
  	     * This method is like `_.sum` except that it accepts `iteratee` which is
  	     * invoked for each element in `array` to generate the value to be summed.
  	     * The iteratee is invoked with one argument: (value).
  	     *
  	     * @static
  	     * @memberOf _
  	     * @since 4.0.0
  	     * @category Math
  	     * @param {Array} array The array to iterate over.
  	     * @param {Function} [iteratee=_.identity] The iteratee invoked per element.
  	     * @returns {number} Returns the sum.
  	     * @example
  	     *
  	     * var objects = [{ 'n': 4 }, { 'n': 2 }, { 'n': 8 }, { 'n': 6 }];
  	     *
  	     * _.sumBy(objects, function(o) { return o.n; });
  	     * // => 20
  	     *
  	     * // The `_.property` iteratee shorthand.
  	     * _.sumBy(objects, 'n');
  	     * // => 20
  	     */
  	    function sumBy(array, iteratee) {
  	      return (array && array.length)
  	        ? baseSum(array, getIteratee(iteratee, 2))
  	        : 0;
  	    }

  	    /*------------------------------------------------------------------------*/

  	    // Add methods that return wrapped values in chain sequences.
  	    lodash.after = after;
  	    lodash.ary = ary;
  	    lodash.assign = assign;
  	    lodash.assignIn = assignIn;
  	    lodash.assignInWith = assignInWith;
  	    lodash.assignWith = assignWith;
  	    lodash.at = at;
  	    lodash.before = before;
  	    lodash.bind = bind;
  	    lodash.bindAll = bindAll;
  	    lodash.bindKey = bindKey;
  	    lodash.castArray = castArray;
  	    lodash.chain = chain;
  	    lodash.chunk = chunk;
  	    lodash.compact = compact;
  	    lodash.concat = concat;
  	    lodash.cond = cond;
  	    lodash.conforms = conforms;
  	    lodash.constant = constant;
  	    lodash.countBy = countBy;
  	    lodash.create = create;
  	    lodash.curry = curry;
  	    lodash.curryRight = curryRight;
  	    lodash.debounce = debounce;
  	    lodash.defaults = defaults;
  	    lodash.defaultsDeep = defaultsDeep;
  	    lodash.defer = defer;
  	    lodash.delay = delay;
  	    lodash.difference = difference;
  	    lodash.differenceBy = differenceBy;
  	    lodash.differenceWith = differenceWith;
  	    lodash.drop = drop;
  	    lodash.dropRight = dropRight;
  	    lodash.dropRightWhile = dropRightWhile;
  	    lodash.dropWhile = dropWhile;
  	    lodash.fill = fill;
  	    lodash.filter = filter;
  	    lodash.flatMap = flatMap;
  	    lodash.flatMapDeep = flatMapDeep;
  	    lodash.flatMapDepth = flatMapDepth;
  	    lodash.flatten = flatten;
  	    lodash.flattenDeep = flattenDeep;
  	    lodash.flattenDepth = flattenDepth;
  	    lodash.flip = flip;
  	    lodash.flow = flow;
  	    lodash.flowRight = flowRight;
  	    lodash.fromPairs = fromPairs;
  	    lodash.functions = functions;
  	    lodash.functionsIn = functionsIn;
  	    lodash.groupBy = groupBy;
  	    lodash.initial = initial;
  	    lodash.intersection = intersection;
  	    lodash.intersectionBy = intersectionBy;
  	    lodash.intersectionWith = intersectionWith;
  	    lodash.invert = invert;
  	    lodash.invertBy = invertBy;
  	    lodash.invokeMap = invokeMap;
  	    lodash.iteratee = iteratee;
  	    lodash.keyBy = keyBy;
  	    lodash.keys = keys;
  	    lodash.keysIn = keysIn;
  	    lodash.map = map;
  	    lodash.mapKeys = mapKeys;
  	    lodash.mapValues = mapValues;
  	    lodash.matches = matches;
  	    lodash.matchesProperty = matchesProperty;
  	    lodash.memoize = memoize;
  	    lodash.merge = merge;
  	    lodash.mergeWith = mergeWith;
  	    lodash.method = method;
  	    lodash.methodOf = methodOf;
  	    lodash.mixin = mixin;
  	    lodash.negate = negate;
  	    lodash.nthArg = nthArg;
  	    lodash.omit = omit;
  	    lodash.omitBy = omitBy;
  	    lodash.once = once;
  	    lodash.orderBy = orderBy;
  	    lodash.over = over;
  	    lodash.overArgs = overArgs;
  	    lodash.overEvery = overEvery;
  	    lodash.overSome = overSome;
  	    lodash.partial = partial;
  	    lodash.partialRight = partialRight;
  	    lodash.partition = partition;
  	    lodash.pick = pick;
  	    lodash.pickBy = pickBy;
  	    lodash.property = property;
  	    lodash.propertyOf = propertyOf;
  	    lodash.pull = pull;
  	    lodash.pullAll = pullAll;
  	    lodash.pullAllBy = pullAllBy;
  	    lodash.pullAllWith = pullAllWith;
  	    lodash.pullAt = pullAt;
  	    lodash.range = range;
  	    lodash.rangeRight = rangeRight;
  	    lodash.rearg = rearg;
  	    lodash.reject = reject;
  	    lodash.remove = remove;
  	    lodash.rest = rest;
  	    lodash.reverse = reverse;
  	    lodash.sampleSize = sampleSize;
  	    lodash.set = set;
  	    lodash.setWith = setWith;
  	    lodash.shuffle = shuffle;
  	    lodash.slice = slice;
  	    lodash.sortBy = sortBy;
  	    lodash.sortedUniq = sortedUniq;
  	    lodash.sortedUniqBy = sortedUniqBy;
  	    lodash.split = split;
  	    lodash.spread = spread;
  	    lodash.tail = tail;
  	    lodash.take = take;
  	    lodash.takeRight = takeRight;
  	    lodash.takeRightWhile = takeRightWhile;
  	    lodash.takeWhile = takeWhile;
  	    lodash.tap = tap;
  	    lodash.throttle = throttle;
  	    lodash.thru = thru;
  	    lodash.toArray = toArray;
  	    lodash.toPairs = toPairs;
  	    lodash.toPairsIn = toPairsIn;
  	    lodash.toPath = toPath;
  	    lodash.toPlainObject = toPlainObject;
  	    lodash.transform = transform;
  	    lodash.unary = unary;
  	    lodash.union = union;
  	    lodash.unionBy = unionBy;
  	    lodash.unionWith = unionWith;
  	    lodash.uniq = uniq;
  	    lodash.uniqBy = uniqBy;
  	    lodash.uniqWith = uniqWith;
  	    lodash.unset = unset;
  	    lodash.unzip = unzip;
  	    lodash.unzipWith = unzipWith;
  	    lodash.update = update;
  	    lodash.updateWith = updateWith;
  	    lodash.values = values;
  	    lodash.valuesIn = valuesIn;
  	    lodash.without = without;
  	    lodash.words = words;
  	    lodash.wrap = wrap;
  	    lodash.xor = xor;
  	    lodash.xorBy = xorBy;
  	    lodash.xorWith = xorWith;
  	    lodash.zip = zip;
  	    lodash.zipObject = zipObject;
  	    lodash.zipObjectDeep = zipObjectDeep;
  	    lodash.zipWith = zipWith;

  	    // Add aliases.
  	    lodash.entries = toPairs;
  	    lodash.entriesIn = toPairsIn;
  	    lodash.extend = assignIn;
  	    lodash.extendWith = assignInWith;

  	    // Add methods to `lodash.prototype`.
  	    mixin(lodash, lodash);

  	    /*------------------------------------------------------------------------*/

  	    // Add methods that return unwrapped values in chain sequences.
  	    lodash.add = add;
  	    lodash.attempt = attempt;
  	    lodash.camelCase = camelCase;
  	    lodash.capitalize = capitalize;
  	    lodash.ceil = ceil;
  	    lodash.clamp = clamp;
  	    lodash.clone = clone;
  	    lodash.cloneDeep = cloneDeep;
  	    lodash.cloneDeepWith = cloneDeepWith;
  	    lodash.cloneWith = cloneWith;
  	    lodash.conformsTo = conformsTo;
  	    lodash.deburr = deburr;
  	    lodash.defaultTo = defaultTo;
  	    lodash.divide = divide;
  	    lodash.endsWith = endsWith;
  	    lodash.eq = eq;
  	    lodash.escape = escape;
  	    lodash.escapeRegExp = escapeRegExp;
  	    lodash.every = every;
  	    lodash.find = find;
  	    lodash.findIndex = findIndex;
  	    lodash.findKey = findKey;
  	    lodash.findLast = findLast;
  	    lodash.findLastIndex = findLastIndex;
  	    lodash.findLastKey = findLastKey;
  	    lodash.floor = floor;
  	    lodash.forEach = forEach;
  	    lodash.forEachRight = forEachRight;
  	    lodash.forIn = forIn;
  	    lodash.forInRight = forInRight;
  	    lodash.forOwn = forOwn;
  	    lodash.forOwnRight = forOwnRight;
  	    lodash.get = get;
  	    lodash.gt = gt;
  	    lodash.gte = gte;
  	    lodash.has = has;
  	    lodash.hasIn = hasIn;
  	    lodash.head = head;
  	    lodash.identity = identity;
  	    lodash.includes = includes;
  	    lodash.indexOf = indexOf;
  	    lodash.inRange = inRange;
  	    lodash.invoke = invoke;
  	    lodash.isArguments = isArguments;
  	    lodash.isArray = isArray;
  	    lodash.isArrayBuffer = isArrayBuffer;
  	    lodash.isArrayLike = isArrayLike;
  	    lodash.isArrayLikeObject = isArrayLikeObject;
  	    lodash.isBoolean = isBoolean;
  	    lodash.isBuffer = isBuffer;
  	    lodash.isDate = isDate;
  	    lodash.isElement = isElement;
  	    lodash.isEmpty = isEmpty;
  	    lodash.isEqual = isEqual;
  	    lodash.isEqualWith = isEqualWith;
  	    lodash.isError = isError;
  	    lodash.isFinite = isFinite;
  	    lodash.isFunction = isFunction;
  	    lodash.isInteger = isInteger;
  	    lodash.isLength = isLength;
  	    lodash.isMap = isMap;
  	    lodash.isMatch = isMatch;
  	    lodash.isMatchWith = isMatchWith;
  	    lodash.isNaN = isNaN;
  	    lodash.isNative = isNative;
  	    lodash.isNil = isNil;
  	    lodash.isNull = isNull;
  	    lodash.isNumber = isNumber;
  	    lodash.isObject = isObject;
  	    lodash.isObjectLike = isObjectLike;
  	    lodash.isPlainObject = isPlainObject;
  	    lodash.isRegExp = isRegExp;
  	    lodash.isSafeInteger = isSafeInteger;
  	    lodash.isSet = isSet;
  	    lodash.isString = isString;
  	    lodash.isSymbol = isSymbol;
  	    lodash.isTypedArray = isTypedArray;
  	    lodash.isUndefined = isUndefined;
  	    lodash.isWeakMap = isWeakMap;
  	    lodash.isWeakSet = isWeakSet;
  	    lodash.join = join;
  	    lodash.kebabCase = kebabCase;
  	    lodash.last = last;
  	    lodash.lastIndexOf = lastIndexOf;
  	    lodash.lowerCase = lowerCase;
  	    lodash.lowerFirst = lowerFirst;
  	    lodash.lt = lt;
  	    lodash.lte = lte;
  	    lodash.max = max;
  	    lodash.maxBy = maxBy;
  	    lodash.mean = mean;
  	    lodash.meanBy = meanBy;
  	    lodash.min = min;
  	    lodash.minBy = minBy;
  	    lodash.stubArray = stubArray;
  	    lodash.stubFalse = stubFalse;
  	    lodash.stubObject = stubObject;
  	    lodash.stubString = stubString;
  	    lodash.stubTrue = stubTrue;
  	    lodash.multiply = multiply;
  	    lodash.nth = nth;
  	    lodash.noConflict = noConflict;
  	    lodash.noop = noop;
  	    lodash.now = now;
  	    lodash.pad = pad;
  	    lodash.padEnd = padEnd;
  	    lodash.padStart = padStart;
  	    lodash.parseInt = parseInt;
  	    lodash.random = random;
  	    lodash.reduce = reduce;
  	    lodash.reduceRight = reduceRight;
  	    lodash.repeat = repeat;
  	    lodash.replace = replace;
  	    lodash.result = result;
  	    lodash.round = round;
  	    lodash.runInContext = runInContext;
  	    lodash.sample = sample;
  	    lodash.size = size;
  	    lodash.snakeCase = snakeCase;
  	    lodash.some = some;
  	    lodash.sortedIndex = sortedIndex;
  	    lodash.sortedIndexBy = sortedIndexBy;
  	    lodash.sortedIndexOf = sortedIndexOf;
  	    lodash.sortedLastIndex = sortedLastIndex;
  	    lodash.sortedLastIndexBy = sortedLastIndexBy;
  	    lodash.sortedLastIndexOf = sortedLastIndexOf;
  	    lodash.startCase = startCase;
  	    lodash.startsWith = startsWith;
  	    lodash.subtract = subtract;
  	    lodash.sum = sum;
  	    lodash.sumBy = sumBy;
  	    lodash.template = template;
  	    lodash.times = times;
  	    lodash.toFinite = toFinite;
  	    lodash.toInteger = toInteger;
  	    lodash.toLength = toLength;
  	    lodash.toLower = toLower;
  	    lodash.toNumber = toNumber;
  	    lodash.toSafeInteger = toSafeInteger;
  	    lodash.toString = toString;
  	    lodash.toUpper = toUpper;
  	    lodash.trim = trim;
  	    lodash.trimEnd = trimEnd;
  	    lodash.trimStart = trimStart;
  	    lodash.truncate = truncate;
  	    lodash.unescape = unescape;
  	    lodash.uniqueId = uniqueId;
  	    lodash.upperCase = upperCase;
  	    lodash.upperFirst = upperFirst;

  	    // Add aliases.
  	    lodash.each = forEach;
  	    lodash.eachRight = forEachRight;
  	    lodash.first = head;

  	    mixin(lodash, (function() {
  	      var source = {};
  	      baseForOwn(lodash, function(func, methodName) {
  	        if (!hasOwnProperty.call(lodash.prototype, methodName)) {
  	          source[methodName] = func;
  	        }
  	      });
  	      return source;
  	    }()), { 'chain': false });

  	    /*------------------------------------------------------------------------*/

  	    /**
  	     * The semantic version number.
  	     *
  	     * @static
  	     * @memberOf _
  	     * @type {string}
  	     */
  	    lodash.VERSION = VERSION;

  	    // Assign default placeholders.
  	    arrayEach(['bind', 'bindKey', 'curry', 'curryRight', 'partial', 'partialRight'], function(methodName) {
  	      lodash[methodName].placeholder = lodash;
  	    });

  	    // Add `LazyWrapper` methods for `_.drop` and `_.take` variants.
  	    arrayEach(['drop', 'take'], function(methodName, index) {
  	      LazyWrapper.prototype[methodName] = function(n) {
  	        n = n === undefined$1 ? 1 : nativeMax(toInteger(n), 0);

  	        var result = (this.__filtered__ && !index)
  	          ? new LazyWrapper(this)
  	          : this.clone();

  	        if (result.__filtered__) {
  	          result.__takeCount__ = nativeMin(n, result.__takeCount__);
  	        } else {
  	          result.__views__.push({
  	            'size': nativeMin(n, MAX_ARRAY_LENGTH),
  	            'type': methodName + (result.__dir__ < 0 ? 'Right' : '')
  	          });
  	        }
  	        return result;
  	      };

  	      LazyWrapper.prototype[methodName + 'Right'] = function(n) {
  	        return this.reverse()[methodName](n).reverse();
  	      };
  	    });

  	    // Add `LazyWrapper` methods that accept an `iteratee` value.
  	    arrayEach(['filter', 'map', 'takeWhile'], function(methodName, index) {
  	      var type = index + 1,
  	          isFilter = type == LAZY_FILTER_FLAG || type == LAZY_WHILE_FLAG;

  	      LazyWrapper.prototype[methodName] = function(iteratee) {
  	        var result = this.clone();
  	        result.__iteratees__.push({
  	          'iteratee': getIteratee(iteratee, 3),
  	          'type': type
  	        });
  	        result.__filtered__ = result.__filtered__ || isFilter;
  	        return result;
  	      };
  	    });

  	    // Add `LazyWrapper` methods for `_.head` and `_.last`.
  	    arrayEach(['head', 'last'], function(methodName, index) {
  	      var takeName = 'take' + (index ? 'Right' : '');

  	      LazyWrapper.prototype[methodName] = function() {
  	        return this[takeName](1).value()[0];
  	      };
  	    });

  	    // Add `LazyWrapper` methods for `_.initial` and `_.tail`.
  	    arrayEach(['initial', 'tail'], function(methodName, index) {
  	      var dropName = 'drop' + (index ? '' : 'Right');

  	      LazyWrapper.prototype[methodName] = function() {
  	        return this.__filtered__ ? new LazyWrapper(this) : this[dropName](1);
  	      };
  	    });

  	    LazyWrapper.prototype.compact = function() {
  	      return this.filter(identity);
  	    };

  	    LazyWrapper.prototype.find = function(predicate) {
  	      return this.filter(predicate).head();
  	    };

  	    LazyWrapper.prototype.findLast = function(predicate) {
  	      return this.reverse().find(predicate);
  	    };

  	    LazyWrapper.prototype.invokeMap = baseRest(function(path, args) {
  	      if (typeof path == 'function') {
  	        return new LazyWrapper(this);
  	      }
  	      return this.map(function(value) {
  	        return baseInvoke(value, path, args);
  	      });
  	    });

  	    LazyWrapper.prototype.reject = function(predicate) {
  	      return this.filter(negate(getIteratee(predicate)));
  	    };

  	    LazyWrapper.prototype.slice = function(start, end) {
  	      start = toInteger(start);

  	      var result = this;
  	      if (result.__filtered__ && (start > 0 || end < 0)) {
  	        return new LazyWrapper(result);
  	      }
  	      if (start < 0) {
  	        result = result.takeRight(-start);
  	      } else if (start) {
  	        result = result.drop(start);
  	      }
  	      if (end !== undefined$1) {
  	        end = toInteger(end);
  	        result = end < 0 ? result.dropRight(-end) : result.take(end - start);
  	      }
  	      return result;
  	    };

  	    LazyWrapper.prototype.takeRightWhile = function(predicate) {
  	      return this.reverse().takeWhile(predicate).reverse();
  	    };

  	    LazyWrapper.prototype.toArray = function() {
  	      return this.take(MAX_ARRAY_LENGTH);
  	    };

  	    // Add `LazyWrapper` methods to `lodash.prototype`.
  	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
  	      var checkIteratee = /^(?:filter|find|map|reject)|While$/.test(methodName),
  	          isTaker = /^(?:head|last)$/.test(methodName),
  	          lodashFunc = lodash[isTaker ? ('take' + (methodName == 'last' ? 'Right' : '')) : methodName],
  	          retUnwrapped = isTaker || /^find/.test(methodName);

  	      if (!lodashFunc) {
  	        return;
  	      }
  	      lodash.prototype[methodName] = function() {
  	        var value = this.__wrapped__,
  	            args = isTaker ? [1] : arguments,
  	            isLazy = value instanceof LazyWrapper,
  	            iteratee = args[0],
  	            useLazy = isLazy || isArray(value);

  	        var interceptor = function(value) {
  	          var result = lodashFunc.apply(lodash, arrayPush([value], args));
  	          return (isTaker && chainAll) ? result[0] : result;
  	        };

  	        if (useLazy && checkIteratee && typeof iteratee == 'function' && iteratee.length != 1) {
  	          // Avoid lazy use if the iteratee has a "length" value other than `1`.
  	          isLazy = useLazy = false;
  	        }
  	        var chainAll = this.__chain__,
  	            isHybrid = !!this.__actions__.length,
  	            isUnwrapped = retUnwrapped && !chainAll,
  	            onlyLazy = isLazy && !isHybrid;

  	        if (!retUnwrapped && useLazy) {
  	          value = onlyLazy ? value : new LazyWrapper(this);
  	          var result = func.apply(value, args);
  	          result.__actions__.push({ 'func': thru, 'args': [interceptor], 'thisArg': undefined$1 });
  	          return new LodashWrapper(result, chainAll);
  	        }
  	        if (isUnwrapped && onlyLazy) {
  	          return func.apply(this, args);
  	        }
  	        result = this.thru(interceptor);
  	        return isUnwrapped ? (isTaker ? result.value()[0] : result.value()) : result;
  	      };
  	    });

  	    // Add `Array` methods to `lodash.prototype`.
  	    arrayEach(['pop', 'push', 'shift', 'sort', 'splice', 'unshift'], function(methodName) {
  	      var func = arrayProto[methodName],
  	          chainName = /^(?:push|sort|unshift)$/.test(methodName) ? 'tap' : 'thru',
  	          retUnwrapped = /^(?:pop|shift)$/.test(methodName);

  	      lodash.prototype[methodName] = function() {
  	        var args = arguments;
  	        if (retUnwrapped && !this.__chain__) {
  	          var value = this.value();
  	          return func.apply(isArray(value) ? value : [], args);
  	        }
  	        return this[chainName](function(value) {
  	          return func.apply(isArray(value) ? value : [], args);
  	        });
  	      };
  	    });

  	    // Map minified method names to their real names.
  	    baseForOwn(LazyWrapper.prototype, function(func, methodName) {
  	      var lodashFunc = lodash[methodName];
  	      if (lodashFunc) {
  	        var key = lodashFunc.name + '';
  	        if (!hasOwnProperty.call(realNames, key)) {
  	          realNames[key] = [];
  	        }
  	        realNames[key].push({ 'name': methodName, 'func': lodashFunc });
  	      }
  	    });

  	    realNames[createHybrid(undefined$1, WRAP_BIND_KEY_FLAG).name] = [{
  	      'name': 'wrapper',
  	      'func': undefined$1
  	    }];

  	    // Add methods to `LazyWrapper`.
  	    LazyWrapper.prototype.clone = lazyClone;
  	    LazyWrapper.prototype.reverse = lazyReverse;
  	    LazyWrapper.prototype.value = lazyValue;

  	    // Add chain sequence methods to the `lodash` wrapper.
  	    lodash.prototype.at = wrapperAt;
  	    lodash.prototype.chain = wrapperChain;
  	    lodash.prototype.commit = wrapperCommit;
  	    lodash.prototype.next = wrapperNext;
  	    lodash.prototype.plant = wrapperPlant;
  	    lodash.prototype.reverse = wrapperReverse;
  	    lodash.prototype.toJSON = lodash.prototype.valueOf = lodash.prototype.value = wrapperValue;

  	    // Add lazy aliases.
  	    lodash.prototype.first = lodash.prototype.head;

  	    if (symIterator) {
  	      lodash.prototype[symIterator] = wrapperToIterator;
  	    }
  	    return lodash;
  	  });

  	  /*--------------------------------------------------------------------------*/

  	  // Export lodash.
  	  var _ = runInContext();

  	  // Some AMD build optimizers, like r.js, check for condition patterns like:
  	  if (freeModule) {
  	    // Export for Node.js.
  	    (freeModule.exports = _)._ = _;
  	    // Export for CommonJS support.
  	    freeExports._ = _;
  	  }
  	  else {
  	    // Export to the global object.
  	    root._ = _;
  	  }
  	}.call(commonjsGlobal));
  } (lodash, lodash.exports));

  var _ = lodash.exports;

  /**
   * lodash (Custom Build) <https://lodash.com/>
   * Build: `lodash modularize exports="npm" -o ./`
   * Copyright jQuery Foundation and other contributors <https://jquery.org/>
   * Released under MIT license <https://lodash.com/license>
   * Based on Underscore.js 1.8.3 <http://underscorejs.org/LICENSE>
   * Copyright Jeremy Ashkenas, DocumentCloud and Investigative Reporters & Editors
   */

  /** Used as the size to enable large array optimizations. */
  var LARGE_ARRAY_SIZE = 200;

  /** Used to stand-in for `undefined` hash values. */
  var HASH_UNDEFINED = '__lodash_hash_undefined__';

  /** Used as references for various `Number` constants. */
  var MAX_SAFE_INTEGER = 9007199254740991;

  /** `Object#toString` result references. */
  var argsTag = '[object Arguments]',
      arrayTag = '[object Array]',
      boolTag = '[object Boolean]',
      dateTag = '[object Date]',
      errorTag = '[object Error]',
      funcTag = '[object Function]',
      genTag = '[object GeneratorFunction]',
      mapTag = '[object Map]',
      numberTag = '[object Number]',
      objectTag = '[object Object]',
      promiseTag = '[object Promise]',
      regexpTag = '[object RegExp]',
      setTag = '[object Set]',
      stringTag = '[object String]',
      symbolTag = '[object Symbol]',
      weakMapTag = '[object WeakMap]';

  var arrayBufferTag = '[object ArrayBuffer]',
      dataViewTag = '[object DataView]',
      float32Tag = '[object Float32Array]',
      float64Tag = '[object Float64Array]',
      int8Tag = '[object Int8Array]',
      int16Tag = '[object Int16Array]',
      int32Tag = '[object Int32Array]',
      uint8Tag = '[object Uint8Array]',
      uint8ClampedTag = '[object Uint8ClampedArray]',
      uint16Tag = '[object Uint16Array]',
      uint32Tag = '[object Uint32Array]';

  /**
   * Used to match `RegExp`
   * [syntax characters](http://ecma-international.org/ecma-262/7.0/#sec-patterns).
   */
  var reRegExpChar = /[\\^$.*+?()[\]{}|]/g;

  /** Used to match `RegExp` flags from their coerced string values. */
  var reFlags = /\w*$/;

  /** Used to detect host constructors (Safari). */
  var reIsHostCtor = /^\[object .+?Constructor\]$/;

  /** Used to detect unsigned integer values. */
  var reIsUint = /^(?:0|[1-9]\d*)$/;

  /** Used to identify `toStringTag` values supported by `_.clone`. */
  var cloneableTags = {};
  cloneableTags[argsTag] = cloneableTags[arrayTag] =
  cloneableTags[arrayBufferTag] = cloneableTags[dataViewTag] =
  cloneableTags[boolTag] = cloneableTags[dateTag] =
  cloneableTags[float32Tag] = cloneableTags[float64Tag] =
  cloneableTags[int8Tag] = cloneableTags[int16Tag] =
  cloneableTags[int32Tag] = cloneableTags[mapTag] =
  cloneableTags[numberTag] = cloneableTags[objectTag] =
  cloneableTags[regexpTag] = cloneableTags[setTag] =
  cloneableTags[stringTag] = cloneableTags[symbolTag] =
  cloneableTags[uint8Tag] = cloneableTags[uint8ClampedTag] =
  cloneableTags[uint16Tag] = cloneableTags[uint32Tag] = true;
  cloneableTags[errorTag] = cloneableTags[funcTag] =
  cloneableTags[weakMapTag] = false;

  /** Detect free variable `global` from Node.js. */
  var freeGlobal = typeof global == 'object' && global && global.Object === Object && global;

  /** Detect free variable `self`. */
  var freeSelf = typeof self == 'object' && self && self.Object === Object && self;

  /** Used as a reference to the global object. */
  var root = freeGlobal || freeSelf || Function('return this')();

  /** Detect free variable `exports`. */
  var freeExports = typeof exports == 'object' && exports && !exports.nodeType && exports;

  /** Detect free variable `module`. */
  var freeModule = freeExports && typeof module == 'object' && module && !module.nodeType && module;

  /** Detect the popular CommonJS extension `module.exports`. */
  var moduleExports = freeModule && freeModule.exports === freeExports;

  /**
   * Adds the key-value `pair` to `map`.
   *
   * @private
   * @param {Object} map The map to modify.
   * @param {Array} pair The key-value pair to add.
   * @returns {Object} Returns `map`.
   */
  function addMapEntry(map, pair) {
    // Don't return `map.set` because it's not chainable in IE 11.
    map.set(pair[0], pair[1]);
    return map;
  }

  /**
   * Adds `value` to `set`.
   *
   * @private
   * @param {Object} set The set to modify.
   * @param {*} value The value to add.
   * @returns {Object} Returns `set`.
   */
  function addSetEntry(set, value) {
    // Don't return `set.add` because it's not chainable in IE 11.
    set.add(value);
    return set;
  }

  /**
   * A specialized version of `_.forEach` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns `array`.
   */
  function arrayEach(array, iteratee) {
    var index = -1,
        length = array ? array.length : 0;

    while (++index < length) {
      if (iteratee(array[index], index, array) === false) {
        break;
      }
    }
    return array;
  }

  /**
   * Appends the elements of `values` to `array`.
   *
   * @private
   * @param {Array} array The array to modify.
   * @param {Array} values The values to append.
   * @returns {Array} Returns `array`.
   */
  function arrayPush(array, values) {
    var index = -1,
        length = values.length,
        offset = array.length;

    while (++index < length) {
      array[offset + index] = values[index];
    }
    return array;
  }

  /**
   * A specialized version of `_.reduce` for arrays without support for
   * iteratee shorthands.
   *
   * @private
   * @param {Array} [array] The array to iterate over.
   * @param {Function} iteratee The function invoked per iteration.
   * @param {*} [accumulator] The initial value.
   * @param {boolean} [initAccum] Specify using the first element of `array` as
   *  the initial value.
   * @returns {*} Returns the accumulated value.
   */
  function arrayReduce(array, iteratee, accumulator, initAccum) {
    var index = -1,
        length = array ? array.length : 0;

    if (initAccum && length) {
      accumulator = array[++index];
    }
    while (++index < length) {
      accumulator = iteratee(accumulator, array[index], index, array);
    }
    return accumulator;
  }

  /**
   * The base implementation of `_.times` without support for iteratee shorthands
   * or max array length checks.
   *
   * @private
   * @param {number} n The number of times to invoke `iteratee`.
   * @param {Function} iteratee The function invoked per iteration.
   * @returns {Array} Returns the array of results.
   */
  function baseTimes(n, iteratee) {
    var index = -1,
        result = Array(n);

    while (++index < n) {
      result[index] = iteratee(index);
    }
    return result;
  }

  /**
   * Gets the value at `key` of `object`.
   *
   * @private
   * @param {Object} [object] The object to query.
   * @param {string} key The key of the property to get.
   * @returns {*} Returns the property value.
   */
  function getValue(object, key) {
    return object == null ? undefined : object[key];
  }

  /**
   * Checks if `value` is a host object in IE < 9.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a host object, else `false`.
   */
  function isHostObject(value) {
    // Many host objects are `Object` objects that can coerce to strings
    // despite having improperly defined `toString` methods.
    var result = false;
    if (value != null && typeof value.toString != 'function') {
      try {
        result = !!(value + '');
      } catch (e) {}
    }
    return result;
  }

  /**
   * Converts `map` to its key-value pairs.
   *
   * @private
   * @param {Object} map The map to convert.
   * @returns {Array} Returns the key-value pairs.
   */
  function mapToArray(map) {
    var index = -1,
        result = Array(map.size);

    map.forEach(function(value, key) {
      result[++index] = [key, value];
    });
    return result;
  }

  /**
   * Creates a unary function that invokes `func` with its argument transformed.
   *
   * @private
   * @param {Function} func The function to wrap.
   * @param {Function} transform The argument transform.
   * @returns {Function} Returns the new function.
   */
  function overArg(func, transform) {
    return function(arg) {
      return func(transform(arg));
    };
  }

  /**
   * Converts `set` to an array of its values.
   *
   * @private
   * @param {Object} set The set to convert.
   * @returns {Array} Returns the values.
   */
  function setToArray(set) {
    var index = -1,
        result = Array(set.size);

    set.forEach(function(value) {
      result[++index] = value;
    });
    return result;
  }

  /** Used for built-in method references. */
  var arrayProto = Array.prototype,
      funcProto = Function.prototype,
      objectProto = Object.prototype;

  /** Used to detect overreaching core-js shims. */
  var coreJsData = root['__core-js_shared__'];

  /** Used to detect methods masquerading as native. */
  var maskSrcKey = (function() {
    var uid = /[^.]+$/.exec(coreJsData && coreJsData.keys && coreJsData.keys.IE_PROTO || '');
    return uid ? ('Symbol(src)_1.' + uid) : '';
  }());

  /** Used to resolve the decompiled source of functions. */
  var funcToString = funcProto.toString;

  /** Used to check objects for own properties. */
  var hasOwnProperty = objectProto.hasOwnProperty;

  /**
   * Used to resolve the
   * [`toStringTag`](http://ecma-international.org/ecma-262/7.0/#sec-object.prototype.tostring)
   * of values.
   */
  var objectToString = objectProto.toString;

  /** Used to detect if a method is native. */
  var reIsNative = RegExp('^' +
    funcToString.call(hasOwnProperty).replace(reRegExpChar, '\\$&')
    .replace(/hasOwnProperty|(function).*?(?=\\\()| for .+?(?=\\\])/g, '$1.*?') + '$'
  );

  /** Built-in value references. */
  var Buffer$1 = moduleExports ? root.Buffer : undefined,
      Symbol$1 = root.Symbol,
      Uint8Array$1 = root.Uint8Array,
      getPrototype = overArg(Object.getPrototypeOf, Object),
      objectCreate = Object.create,
      propertyIsEnumerable = objectProto.propertyIsEnumerable,
      splice = arrayProto.splice;

  /* Built-in method references for those with the same name as other `lodash` methods. */
  var nativeGetSymbols = Object.getOwnPropertySymbols,
      nativeIsBuffer = Buffer$1 ? Buffer$1.isBuffer : undefined,
      nativeKeys = overArg(Object.keys, Object);

  /* Built-in method references that are verified to be native. */
  var DataView$1 = getNative(root, 'DataView'),
      Map$1 = getNative(root, 'Map'),
      Promise$1 = getNative(root, 'Promise'),
      Set$1 = getNative(root, 'Set'),
      WeakMap = getNative(root, 'WeakMap'),
      nativeCreate = getNative(Object, 'create');

  /** Used to detect maps, sets, and weakmaps. */
  var dataViewCtorString = toSource(DataView$1),
      mapCtorString = toSource(Map$1),
      promiseCtorString = toSource(Promise$1),
      setCtorString = toSource(Set$1),
      weakMapCtorString = toSource(WeakMap);

  /** Used to convert symbols to primitives and strings. */
  var symbolProto = Symbol$1 ? Symbol$1.prototype : undefined,
      symbolValueOf = symbolProto ? symbolProto.valueOf : undefined;

  /**
   * Creates a hash object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Hash(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the hash.
   *
   * @private
   * @name clear
   * @memberOf Hash
   */
  function hashClear() {
    this.__data__ = nativeCreate ? nativeCreate(null) : {};
  }

  /**
   * Removes `key` and its value from the hash.
   *
   * @private
   * @name delete
   * @memberOf Hash
   * @param {Object} hash The hash to modify.
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function hashDelete(key) {
    return this.has(key) && delete this.__data__[key];
  }

  /**
   * Gets the hash value for `key`.
   *
   * @private
   * @name get
   * @memberOf Hash
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function hashGet(key) {
    var data = this.__data__;
    if (nativeCreate) {
      var result = data[key];
      return result === HASH_UNDEFINED ? undefined : result;
    }
    return hasOwnProperty.call(data, key) ? data[key] : undefined;
  }

  /**
   * Checks if a hash value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Hash
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function hashHas(key) {
    var data = this.__data__;
    return nativeCreate ? data[key] !== undefined : hasOwnProperty.call(data, key);
  }

  /**
   * Sets the hash `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Hash
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the hash instance.
   */
  function hashSet(key, value) {
    var data = this.__data__;
    data[key] = (nativeCreate && value === undefined) ? HASH_UNDEFINED : value;
    return this;
  }

  // Add methods to `Hash`.
  Hash.prototype.clear = hashClear;
  Hash.prototype['delete'] = hashDelete;
  Hash.prototype.get = hashGet;
  Hash.prototype.has = hashHas;
  Hash.prototype.set = hashSet;

  /**
   * Creates an list cache object.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function ListCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the list cache.
   *
   * @private
   * @name clear
   * @memberOf ListCache
   */
  function listCacheClear() {
    this.__data__ = [];
  }

  /**
   * Removes `key` and its value from the list cache.
   *
   * @private
   * @name delete
   * @memberOf ListCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function listCacheDelete(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      return false;
    }
    var lastIndex = data.length - 1;
    if (index == lastIndex) {
      data.pop();
    } else {
      splice.call(data, index, 1);
    }
    return true;
  }

  /**
   * Gets the list cache value for `key`.
   *
   * @private
   * @name get
   * @memberOf ListCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function listCacheGet(key) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    return index < 0 ? undefined : data[index][1];
  }

  /**
   * Checks if a list cache value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf ListCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function listCacheHas(key) {
    return assocIndexOf(this.__data__, key) > -1;
  }

  /**
   * Sets the list cache `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf ListCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the list cache instance.
   */
  function listCacheSet(key, value) {
    var data = this.__data__,
        index = assocIndexOf(data, key);

    if (index < 0) {
      data.push([key, value]);
    } else {
      data[index][1] = value;
    }
    return this;
  }

  // Add methods to `ListCache`.
  ListCache.prototype.clear = listCacheClear;
  ListCache.prototype['delete'] = listCacheDelete;
  ListCache.prototype.get = listCacheGet;
  ListCache.prototype.has = listCacheHas;
  ListCache.prototype.set = listCacheSet;

  /**
   * Creates a map cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function MapCache(entries) {
    var index = -1,
        length = entries ? entries.length : 0;

    this.clear();
    while (++index < length) {
      var entry = entries[index];
      this.set(entry[0], entry[1]);
    }
  }

  /**
   * Removes all key-value entries from the map.
   *
   * @private
   * @name clear
   * @memberOf MapCache
   */
  function mapCacheClear() {
    this.__data__ = {
      'hash': new Hash,
      'map': new (Map$1 || ListCache),
      'string': new Hash
    };
  }

  /**
   * Removes `key` and its value from the map.
   *
   * @private
   * @name delete
   * @memberOf MapCache
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function mapCacheDelete(key) {
    return getMapData(this, key)['delete'](key);
  }

  /**
   * Gets the map value for `key`.
   *
   * @private
   * @name get
   * @memberOf MapCache
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function mapCacheGet(key) {
    return getMapData(this, key).get(key);
  }

  /**
   * Checks if a map value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf MapCache
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function mapCacheHas(key) {
    return getMapData(this, key).has(key);
  }

  /**
   * Sets the map `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf MapCache
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the map cache instance.
   */
  function mapCacheSet(key, value) {
    getMapData(this, key).set(key, value);
    return this;
  }

  // Add methods to `MapCache`.
  MapCache.prototype.clear = mapCacheClear;
  MapCache.prototype['delete'] = mapCacheDelete;
  MapCache.prototype.get = mapCacheGet;
  MapCache.prototype.has = mapCacheHas;
  MapCache.prototype.set = mapCacheSet;

  /**
   * Creates a stack cache object to store key-value pairs.
   *
   * @private
   * @constructor
   * @param {Array} [entries] The key-value pairs to cache.
   */
  function Stack(entries) {
    this.__data__ = new ListCache(entries);
  }

  /**
   * Removes all key-value entries from the stack.
   *
   * @private
   * @name clear
   * @memberOf Stack
   */
  function stackClear() {
    this.__data__ = new ListCache;
  }

  /**
   * Removes `key` and its value from the stack.
   *
   * @private
   * @name delete
   * @memberOf Stack
   * @param {string} key The key of the value to remove.
   * @returns {boolean} Returns `true` if the entry was removed, else `false`.
   */
  function stackDelete(key) {
    return this.__data__['delete'](key);
  }

  /**
   * Gets the stack value for `key`.
   *
   * @private
   * @name get
   * @memberOf Stack
   * @param {string} key The key of the value to get.
   * @returns {*} Returns the entry value.
   */
  function stackGet(key) {
    return this.__data__.get(key);
  }

  /**
   * Checks if a stack value for `key` exists.
   *
   * @private
   * @name has
   * @memberOf Stack
   * @param {string} key The key of the entry to check.
   * @returns {boolean} Returns `true` if an entry for `key` exists, else `false`.
   */
  function stackHas(key) {
    return this.__data__.has(key);
  }

  /**
   * Sets the stack `key` to `value`.
   *
   * @private
   * @name set
   * @memberOf Stack
   * @param {string} key The key of the value to set.
   * @param {*} value The value to set.
   * @returns {Object} Returns the stack cache instance.
   */
  function stackSet(key, value) {
    var cache = this.__data__;
    if (cache instanceof ListCache) {
      var pairs = cache.__data__;
      if (!Map$1 || (pairs.length < LARGE_ARRAY_SIZE - 1)) {
        pairs.push([key, value]);
        return this;
      }
      cache = this.__data__ = new MapCache(pairs);
    }
    cache.set(key, value);
    return this;
  }

  // Add methods to `Stack`.
  Stack.prototype.clear = stackClear;
  Stack.prototype['delete'] = stackDelete;
  Stack.prototype.get = stackGet;
  Stack.prototype.has = stackHas;
  Stack.prototype.set = stackSet;

  /**
   * Creates an array of the enumerable property names of the array-like `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @param {boolean} inherited Specify returning inherited property names.
   * @returns {Array} Returns the array of property names.
   */
  function arrayLikeKeys(value, inherited) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    // Safari 9 makes `arguments.length` enumerable in strict mode.
    var result = (isArray$1(value) || isArguments(value))
      ? baseTimes(value.length, String)
      : [];

    var length = result.length,
        skipIndexes = !!length;

    for (var key in value) {
      if ((inherited || hasOwnProperty.call(value, key)) &&
          !(skipIndexes && (key == 'length' || isIndex(key, length)))) {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Assigns `value` to `key` of `object` if the existing value is not equivalent
   * using [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * for equality comparisons.
   *
   * @private
   * @param {Object} object The object to modify.
   * @param {string} key The key of the property to assign.
   * @param {*} value The value to assign.
   */
  function assignValue(object, key, value) {
    var objValue = object[key];
    if (!(hasOwnProperty.call(object, key) && eq(objValue, value)) ||
        (value === undefined && !(key in object))) {
      object[key] = value;
    }
  }

  /**
   * Gets the index at which the `key` is found in `array` of key-value pairs.
   *
   * @private
   * @param {Array} array The array to inspect.
   * @param {*} key The key to search for.
   * @returns {number} Returns the index of the matched value, else `-1`.
   */
  function assocIndexOf(array, key) {
    var length = array.length;
    while (length--) {
      if (eq(array[length][0], key)) {
        return length;
      }
    }
    return -1;
  }

  /**
   * The base implementation of `_.assign` without support for multiple sources
   * or `customizer` functions.
   *
   * @private
   * @param {Object} object The destination object.
   * @param {Object} source The source object.
   * @returns {Object} Returns `object`.
   */
  function baseAssign(object, source) {
    return object && copyObject(source, keys$1(source), object);
  }

  /**
   * The base implementation of `_.clone` and `_.cloneDeep` which tracks
   * traversed objects.
   *
   * @private
   * @param {*} value The value to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @param {boolean} [isFull] Specify a clone including symbols.
   * @param {Function} [customizer] The function to customize cloning.
   * @param {string} [key] The key of `value`.
   * @param {Object} [object] The parent object of `value`.
   * @param {Object} [stack] Tracks traversed objects and their clone counterparts.
   * @returns {*} Returns the cloned value.
   */
  function baseClone(value, isDeep, isFull, customizer, key, object, stack) {
    var result;
    if (customizer) {
      result = object ? customizer(value, key, object, stack) : customizer(value);
    }
    if (result !== undefined) {
      return result;
    }
    if (!isObject$1(value)) {
      return value;
    }
    var isArr = isArray$1(value);
    if (isArr) {
      result = initCloneArray(value);
      if (!isDeep) {
        return copyArray(value, result);
      }
    } else {
      var tag = getTag(value),
          isFunc = tag == funcTag || tag == genTag;

      if (isBuffer(value)) {
        return cloneBuffer(value, isDeep);
      }
      if (tag == objectTag || tag == argsTag || (isFunc && !object)) {
        if (isHostObject(value)) {
          return object ? value : {};
        }
        result = initCloneObject(isFunc ? {} : value);
        if (!isDeep) {
          return copySymbols(value, baseAssign(result, value));
        }
      } else {
        if (!cloneableTags[tag]) {
          return object ? value : {};
        }
        result = initCloneByTag(value, tag, baseClone, isDeep);
      }
    }
    // Check for circular references and return its corresponding clone.
    stack || (stack = new Stack);
    var stacked = stack.get(value);
    if (stacked) {
      return stacked;
    }
    stack.set(value, result);

    if (!isArr) {
      var props = isFull ? getAllKeys(value) : keys$1(value);
    }
    arrayEach(props || value, function(subValue, key) {
      if (props) {
        key = subValue;
        subValue = value[key];
      }
      // Recursively populate clone (susceptible to call stack limits).
      assignValue(result, key, baseClone(subValue, isDeep, isFull, customizer, key, value, stack));
    });
    return result;
  }

  /**
   * The base implementation of `_.create` without support for assigning
   * properties to the created object.
   *
   * @private
   * @param {Object} prototype The object to inherit from.
   * @returns {Object} Returns the new object.
   */
  function baseCreate(proto) {
    return isObject$1(proto) ? objectCreate(proto) : {};
  }

  /**
   * The base implementation of `getAllKeys` and `getAllKeysIn` which uses
   * `keysFunc` and `symbolsFunc` to get the enumerable property names and
   * symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {Function} keysFunc The function to get the keys of `object`.
   * @param {Function} symbolsFunc The function to get the symbols of `object`.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function baseGetAllKeys(object, keysFunc, symbolsFunc) {
    var result = keysFunc(object);
    return isArray$1(object) ? result : arrayPush(result, symbolsFunc(object));
  }

  /**
   * The base implementation of `getTag`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  function baseGetTag(value) {
    return objectToString.call(value);
  }

  /**
   * The base implementation of `_.isNative` without bad shim checks.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a native function,
   *  else `false`.
   */
  function baseIsNative(value) {
    if (!isObject$1(value) || isMasked(value)) {
      return false;
    }
    var pattern = (isFunction$1(value) || isHostObject(value)) ? reIsNative : reIsHostCtor;
    return pattern.test(toSource(value));
  }

  /**
   * The base implementation of `_.keys` which doesn't treat sparse arrays as dense.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   */
  function baseKeys(object) {
    if (!isPrototype(object)) {
      return nativeKeys(object);
    }
    var result = [];
    for (var key in Object(object)) {
      if (hasOwnProperty.call(object, key) && key != 'constructor') {
        result.push(key);
      }
    }
    return result;
  }

  /**
   * Creates a clone of  `buffer`.
   *
   * @private
   * @param {Buffer} buffer The buffer to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Buffer} Returns the cloned buffer.
   */
  function cloneBuffer(buffer, isDeep) {
    if (isDeep) {
      return buffer.slice();
    }
    var result = new buffer.constructor(buffer.length);
    buffer.copy(result);
    return result;
  }

  /**
   * Creates a clone of `arrayBuffer`.
   *
   * @private
   * @param {ArrayBuffer} arrayBuffer The array buffer to clone.
   * @returns {ArrayBuffer} Returns the cloned array buffer.
   */
  function cloneArrayBuffer(arrayBuffer) {
    var result = new arrayBuffer.constructor(arrayBuffer.byteLength);
    new Uint8Array$1(result).set(new Uint8Array$1(arrayBuffer));
    return result;
  }

  /**
   * Creates a clone of `dataView`.
   *
   * @private
   * @param {Object} dataView The data view to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned data view.
   */
  function cloneDataView(dataView, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(dataView.buffer) : dataView.buffer;
    return new dataView.constructor(buffer, dataView.byteOffset, dataView.byteLength);
  }

  /**
   * Creates a clone of `map`.
   *
   * @private
   * @param {Object} map The map to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned map.
   */
  function cloneMap(map, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(mapToArray(map), true) : mapToArray(map);
    return arrayReduce(array, addMapEntry, new map.constructor);
  }

  /**
   * Creates a clone of `regexp`.
   *
   * @private
   * @param {Object} regexp The regexp to clone.
   * @returns {Object} Returns the cloned regexp.
   */
  function cloneRegExp(regexp) {
    var result = new regexp.constructor(regexp.source, reFlags.exec(regexp));
    result.lastIndex = regexp.lastIndex;
    return result;
  }

  /**
   * Creates a clone of `set`.
   *
   * @private
   * @param {Object} set The set to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned set.
   */
  function cloneSet(set, isDeep, cloneFunc) {
    var array = isDeep ? cloneFunc(setToArray(set), true) : setToArray(set);
    return arrayReduce(array, addSetEntry, new set.constructor);
  }

  /**
   * Creates a clone of the `symbol` object.
   *
   * @private
   * @param {Object} symbol The symbol object to clone.
   * @returns {Object} Returns the cloned symbol object.
   */
  function cloneSymbol(symbol) {
    return symbolValueOf ? Object(symbolValueOf.call(symbol)) : {};
  }

  /**
   * Creates a clone of `typedArray`.
   *
   * @private
   * @param {Object} typedArray The typed array to clone.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the cloned typed array.
   */
  function cloneTypedArray(typedArray, isDeep) {
    var buffer = isDeep ? cloneArrayBuffer(typedArray.buffer) : typedArray.buffer;
    return new typedArray.constructor(buffer, typedArray.byteOffset, typedArray.length);
  }

  /**
   * Copies the values of `source` to `array`.
   *
   * @private
   * @param {Array} source The array to copy values from.
   * @param {Array} [array=[]] The array to copy values to.
   * @returns {Array} Returns `array`.
   */
  function copyArray(source, array) {
    var index = -1,
        length = source.length;

    array || (array = Array(length));
    while (++index < length) {
      array[index] = source[index];
    }
    return array;
  }

  /**
   * Copies properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy properties from.
   * @param {Array} props The property identifiers to copy.
   * @param {Object} [object={}] The object to copy properties to.
   * @param {Function} [customizer] The function to customize copied values.
   * @returns {Object} Returns `object`.
   */
  function copyObject(source, props, object, customizer) {
    object || (object = {});

    var index = -1,
        length = props.length;

    while (++index < length) {
      var key = props[index];

      var newValue = customizer
        ? customizer(object[key], source[key], key, object, source)
        : undefined;

      assignValue(object, key, newValue === undefined ? source[key] : newValue);
    }
    return object;
  }

  /**
   * Copies own symbol properties of `source` to `object`.
   *
   * @private
   * @param {Object} source The object to copy symbols from.
   * @param {Object} [object={}] The object to copy symbols to.
   * @returns {Object} Returns `object`.
   */
  function copySymbols(source, object) {
    return copyObject(source, getSymbols(source), object);
  }

  /**
   * Creates an array of own enumerable property names and symbols of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names and symbols.
   */
  function getAllKeys(object) {
    return baseGetAllKeys(object, keys$1, getSymbols);
  }

  /**
   * Gets the data for `map`.
   *
   * @private
   * @param {Object} map The map to query.
   * @param {string} key The reference key.
   * @returns {*} Returns the map data.
   */
  function getMapData(map, key) {
    var data = map.__data__;
    return isKeyable(key)
      ? data[typeof key == 'string' ? 'string' : 'hash']
      : data.map;
  }

  /**
   * Gets the native function at `key` of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @param {string} key The key of the method to get.
   * @returns {*} Returns the function if it's native, else `undefined`.
   */
  function getNative(object, key) {
    var value = getValue(object, key);
    return baseIsNative(value) ? value : undefined;
  }

  /**
   * Creates an array of the own enumerable symbol properties of `object`.
   *
   * @private
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of symbols.
   */
  var getSymbols = nativeGetSymbols ? overArg(nativeGetSymbols, Object) : stubArray;

  /**
   * Gets the `toStringTag` of `value`.
   *
   * @private
   * @param {*} value The value to query.
   * @returns {string} Returns the `toStringTag`.
   */
  var getTag = baseGetTag;

  // Fallback for data views, maps, sets, and weak maps in IE 11,
  // for data views in Edge < 14, and promises in Node.js.
  if ((DataView$1 && getTag(new DataView$1(new ArrayBuffer(1))) != dataViewTag) ||
      (Map$1 && getTag(new Map$1) != mapTag) ||
      (Promise$1 && getTag(Promise$1.resolve()) != promiseTag) ||
      (Set$1 && getTag(new Set$1) != setTag) ||
      (WeakMap && getTag(new WeakMap) != weakMapTag)) {
    getTag = function(value) {
      var result = objectToString.call(value),
          Ctor = result == objectTag ? value.constructor : undefined,
          ctorString = Ctor ? toSource(Ctor) : undefined;

      if (ctorString) {
        switch (ctorString) {
          case dataViewCtorString: return dataViewTag;
          case mapCtorString: return mapTag;
          case promiseCtorString: return promiseTag;
          case setCtorString: return setTag;
          case weakMapCtorString: return weakMapTag;
        }
      }
      return result;
    };
  }

  /**
   * Initializes an array clone.
   *
   * @private
   * @param {Array} array The array to clone.
   * @returns {Array} Returns the initialized clone.
   */
  function initCloneArray(array) {
    var length = array.length,
        result = array.constructor(length);

    // Add properties assigned by `RegExp#exec`.
    if (length && typeof array[0] == 'string' && hasOwnProperty.call(array, 'index')) {
      result.index = array.index;
      result.input = array.input;
    }
    return result;
  }

  /**
   * Initializes an object clone.
   *
   * @private
   * @param {Object} object The object to clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneObject(object) {
    return (typeof object.constructor == 'function' && !isPrototype(object))
      ? baseCreate(getPrototype(object))
      : {};
  }

  /**
   * Initializes an object clone based on its `toStringTag`.
   *
   * **Note:** This function only supports cloning values with tags of
   * `Boolean`, `Date`, `Error`, `Number`, `RegExp`, or `String`.
   *
   * @private
   * @param {Object} object The object to clone.
   * @param {string} tag The `toStringTag` of the object to clone.
   * @param {Function} cloneFunc The function to clone values.
   * @param {boolean} [isDeep] Specify a deep clone.
   * @returns {Object} Returns the initialized clone.
   */
  function initCloneByTag(object, tag, cloneFunc, isDeep) {
    var Ctor = object.constructor;
    switch (tag) {
      case arrayBufferTag:
        return cloneArrayBuffer(object);

      case boolTag:
      case dateTag:
        return new Ctor(+object);

      case dataViewTag:
        return cloneDataView(object, isDeep);

      case float32Tag: case float64Tag:
      case int8Tag: case int16Tag: case int32Tag:
      case uint8Tag: case uint8ClampedTag: case uint16Tag: case uint32Tag:
        return cloneTypedArray(object, isDeep);

      case mapTag:
        return cloneMap(object, isDeep, cloneFunc);

      case numberTag:
      case stringTag:
        return new Ctor(object);

      case regexpTag:
        return cloneRegExp(object);

      case setTag:
        return cloneSet(object, isDeep, cloneFunc);

      case symbolTag:
        return cloneSymbol(object);
    }
  }

  /**
   * Checks if `value` is a valid array-like index.
   *
   * @private
   * @param {*} value The value to check.
   * @param {number} [length=MAX_SAFE_INTEGER] The upper bounds of a valid index.
   * @returns {boolean} Returns `true` if `value` is a valid index, else `false`.
   */
  function isIndex(value, length) {
    length = length == null ? MAX_SAFE_INTEGER : length;
    return !!length &&
      (typeof value == 'number' || reIsUint.test(value)) &&
      (value > -1 && value % 1 == 0 && value < length);
  }

  /**
   * Checks if `value` is suitable for use as unique object key.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is suitable, else `false`.
   */
  function isKeyable(value) {
    var type = typeof value;
    return (type == 'string' || type == 'number' || type == 'symbol' || type == 'boolean')
      ? (value !== '__proto__')
      : (value === null);
  }

  /**
   * Checks if `func` has its source masked.
   *
   * @private
   * @param {Function} func The function to check.
   * @returns {boolean} Returns `true` if `func` is masked, else `false`.
   */
  function isMasked(func) {
    return !!maskSrcKey && (maskSrcKey in func);
  }

  /**
   * Checks if `value` is likely a prototype object.
   *
   * @private
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a prototype, else `false`.
   */
  function isPrototype(value) {
    var Ctor = value && value.constructor,
        proto = (typeof Ctor == 'function' && Ctor.prototype) || objectProto;

    return value === proto;
  }

  /**
   * Converts `func` to its source code.
   *
   * @private
   * @param {Function} func The function to process.
   * @returns {string} Returns the source code.
   */
  function toSource(func) {
    if (func != null) {
      try {
        return funcToString.call(func);
      } catch (e) {}
      try {
        return (func + '');
      } catch (e) {}
    }
    return '';
  }

  /**
   * This method is like `_.clone` except that it recursively clones `value`.
   *
   * @static
   * @memberOf _
   * @since 1.0.0
   * @category Lang
   * @param {*} value The value to recursively clone.
   * @returns {*} Returns the deep cloned value.
   * @see _.clone
   * @example
   *
   * var objects = [{ 'a': 1 }, { 'b': 2 }];
   *
   * var deep = _.cloneDeep(objects);
   * console.log(deep[0] === objects[0]);
   * // => false
   */
  function cloneDeep$1(value) {
    return baseClone(value, true, true);
  }

  /**
   * Performs a
   * [`SameValueZero`](http://ecma-international.org/ecma-262/7.0/#sec-samevaluezero)
   * comparison between two values to determine if they are equivalent.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to compare.
   * @param {*} other The other value to compare.
   * @returns {boolean} Returns `true` if the values are equivalent, else `false`.
   * @example
   *
   * var object = { 'a': 1 };
   * var other = { 'a': 1 };
   *
   * _.eq(object, object);
   * // => true
   *
   * _.eq(object, other);
   * // => false
   *
   * _.eq('a', 'a');
   * // => true
   *
   * _.eq('a', Object('a'));
   * // => false
   *
   * _.eq(NaN, NaN);
   * // => true
   */
  function eq(value, other) {
    return value === other || (value !== value && other !== other);
  }

  /**
   * Checks if `value` is likely an `arguments` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an `arguments` object,
   *  else `false`.
   * @example
   *
   * _.isArguments(function() { return arguments; }());
   * // => true
   *
   * _.isArguments([1, 2, 3]);
   * // => false
   */
  function isArguments(value) {
    // Safari 8.1 makes `arguments.callee` enumerable in strict mode.
    return isArrayLikeObject(value) && hasOwnProperty.call(value, 'callee') &&
      (!propertyIsEnumerable.call(value, 'callee') || objectToString.call(value) == argsTag);
  }

  /**
   * Checks if `value` is classified as an `Array` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array, else `false`.
   * @example
   *
   * _.isArray([1, 2, 3]);
   * // => true
   *
   * _.isArray(document.body.children);
   * // => false
   *
   * _.isArray('abc');
   * // => false
   *
   * _.isArray(_.noop);
   * // => false
   */
  var isArray$1 = Array.isArray;

  /**
   * Checks if `value` is array-like. A value is considered array-like if it's
   * not a function and has a `value.length` that's an integer greater than or
   * equal to `0` and less than or equal to `Number.MAX_SAFE_INTEGER`.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is array-like, else `false`.
   * @example
   *
   * _.isArrayLike([1, 2, 3]);
   * // => true
   *
   * _.isArrayLike(document.body.children);
   * // => true
   *
   * _.isArrayLike('abc');
   * // => true
   *
   * _.isArrayLike(_.noop);
   * // => false
   */
  function isArrayLike(value) {
    return value != null && isLength(value.length) && !isFunction$1(value);
  }

  /**
   * This method is like `_.isArrayLike` except that it also checks if `value`
   * is an object.
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an array-like object,
   *  else `false`.
   * @example
   *
   * _.isArrayLikeObject([1, 2, 3]);
   * // => true
   *
   * _.isArrayLikeObject(document.body.children);
   * // => true
   *
   * _.isArrayLikeObject('abc');
   * // => false
   *
   * _.isArrayLikeObject(_.noop);
   * // => false
   */
  function isArrayLikeObject(value) {
    return isObjectLike(value) && isArrayLike(value);
  }

  /**
   * Checks if `value` is a buffer.
   *
   * @static
   * @memberOf _
   * @since 4.3.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a buffer, else `false`.
   * @example
   *
   * _.isBuffer(new Buffer(2));
   * // => true
   *
   * _.isBuffer(new Uint8Array(2));
   * // => false
   */
  var isBuffer = nativeIsBuffer || stubFalse;

  /**
   * Checks if `value` is classified as a `Function` object.
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a function, else `false`.
   * @example
   *
   * _.isFunction(_);
   * // => true
   *
   * _.isFunction(/abc/);
   * // => false
   */
  function isFunction$1(value) {
    // The use of `Object#toString` avoids issues with the `typeof` operator
    // in Safari 8-9 which returns 'object' for typed array and other constructors.
    var tag = isObject$1(value) ? objectToString.call(value) : '';
    return tag == funcTag || tag == genTag;
  }

  /**
   * Checks if `value` is a valid array-like length.
   *
   * **Note:** This method is loosely based on
   * [`ToLength`](http://ecma-international.org/ecma-262/7.0/#sec-tolength).
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is a valid length, else `false`.
   * @example
   *
   * _.isLength(3);
   * // => true
   *
   * _.isLength(Number.MIN_VALUE);
   * // => false
   *
   * _.isLength(Infinity);
   * // => false
   *
   * _.isLength('3');
   * // => false
   */
  function isLength(value) {
    return typeof value == 'number' &&
      value > -1 && value % 1 == 0 && value <= MAX_SAFE_INTEGER;
  }

  /**
   * Checks if `value` is the
   * [language type](http://www.ecma-international.org/ecma-262/7.0/#sec-ecmascript-language-types)
   * of `Object`. (e.g. arrays, functions, objects, regexes, `new Number(0)`, and `new String('')`)
   *
   * @static
   * @memberOf _
   * @since 0.1.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is an object, else `false`.
   * @example
   *
   * _.isObject({});
   * // => true
   *
   * _.isObject([1, 2, 3]);
   * // => true
   *
   * _.isObject(_.noop);
   * // => true
   *
   * _.isObject(null);
   * // => false
   */
  function isObject$1(value) {
    var type = typeof value;
    return !!value && (type == 'object' || type == 'function');
  }

  /**
   * Checks if `value` is object-like. A value is object-like if it's not `null`
   * and has a `typeof` result of "object".
   *
   * @static
   * @memberOf _
   * @since 4.0.0
   * @category Lang
   * @param {*} value The value to check.
   * @returns {boolean} Returns `true` if `value` is object-like, else `false`.
   * @example
   *
   * _.isObjectLike({});
   * // => true
   *
   * _.isObjectLike([1, 2, 3]);
   * // => true
   *
   * _.isObjectLike(_.noop);
   * // => false
   *
   * _.isObjectLike(null);
   * // => false
   */
  function isObjectLike(value) {
    return !!value && typeof value == 'object';
  }

  /**
   * Creates an array of the own enumerable property names of `object`.
   *
   * **Note:** Non-object values are coerced to objects. See the
   * [ES spec](http://ecma-international.org/ecma-262/7.0/#sec-object.keys)
   * for more details.
   *
   * @static
   * @since 0.1.0
   * @memberOf _
   * @category Object
   * @param {Object} object The object to query.
   * @returns {Array} Returns the array of property names.
   * @example
   *
   * function Foo() {
   *   this.a = 1;
   *   this.b = 2;
   * }
   *
   * Foo.prototype.c = 3;
   *
   * _.keys(new Foo);
   * // => ['a', 'b'] (iteration order is not guaranteed)
   *
   * _.keys('hi');
   * // => ['0', '1']
   */
  function keys$1(object) {
    return isArrayLike(object) ? arrayLikeKeys(object) : baseKeys(object);
  }

  /**
   * This method returns a new empty array.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {Array} Returns the new empty array.
   * @example
   *
   * var arrays = _.times(2, _.stubArray);
   *
   * console.log(arrays);
   * // => [[], []]
   *
   * console.log(arrays[0] === arrays[1]);
   * // => false
   */
  function stubArray() {
    return [];
  }

  /**
   * This method returns `false`.
   *
   * @static
   * @memberOf _
   * @since 4.13.0
   * @category Util
   * @returns {boolean} Returns `false`.
   * @example
   *
   * _.times(2, _.stubFalse);
   * // => [false, false]
   */
  function stubFalse() {
    return false;
  }

  const logWithPrefix = (title, displayFunc) => (message) => {

    let finalMessage = message;

    if (typeof displayFunc === 'function') {

      finalMessage = displayFunc(message);
    }

    console.log(`${title}: ${finalMessage}`);

    return message
  };


  class CustomError extends Error {
    constructor(name = 'GENERIC', message = name, data = { status: 500 }) {
      super(message);
      super.name = name;

      if (Error.captureStackTrace) {
        Error.captureStackTrace(this, CustomError);
      }

      this.data = data;
    }

    map(func) {
      return this
    }

    chain(func) {
      return this
    }

    static of=CustomError
  }
  // try {
  //   throw new CustomError('aa','bb',{a:1,b:2})
  // }catch(e)
  // {
  //   console.log(`name: ${e.name}, message: ${e.message}, data: ${JSON.stringify(e.data)}, stack: ${e.stack}`)
  // }
  //
  // mapping a function to CustomError should return the CustomError without exeecuting the function
  // import { pipeWithChain, R } from './ramdaExt.js'
  // let divide = (dividend, divisor) => 
  //   divisor !== 0 
  //     ? dividend/divisor
  //     : new CustomError('ZERO_DIVISION_EXC','Division by zero',{dividend,divisor}) 

  // R.map(a => {
  //   console.log(`It shouldn't print this`)
  //   return a +2
  // })(divide(8,0)) //?

  class Enum {

    constructor(values, rules) {
      // activeObjectKey will be an object with keys from values array and only one current key active: {ON:false,OFF:true}
      let activeObjectKey;

      // It will contain the active key for example 'OFF'. Once initialized activeObjectKey[activeKey] should be always equal to true
      let activeKey;

      let stateRules;

      if (Array.isArray(values) === false) throw new CustomError('NOT_AN_ARRAY', 'Only Array composed of non objects are permitted')
      if (values.filter((elem) => elem === 'object').length > 0) throw new CustomError('ARRAY_VALUES_MUST_BE_OF_BASIC_TYPE', 'Only basic types are allowed')

      let valuesNotAllowed = values.filter(elem => elem === 'get' || elem === 'set' || elem === 'getValue');

      if (valuesNotAllowed.length > 0) {
        throw new CustomError('ENUM_INVALID_ENUM_VALUE', `The following ENUM value/s are not allowed: ${valuesNotAllowed} as they are reserved words for enum`)
      }

      let valuesWithoutDuplicates = removeDuplicates(values);
      activeObjectKey = arrayToObject(valuesWithoutDuplicates, function defaultValue() { return false });
      activeKey = values[0];
      activeObjectKey[activeKey] = true;

      if (rules !== undefined) setupRules(rules);

      this.get = get;
      this.set = set;
      this.getValue = getValue;

      return new Proxy(activeObjectKey, this)

      ///

      function setupRules(rules) {
        if (rules === null || typeof rules !== 'object' || Array.isArray(rules) === true) {
          throw new CustomError('ENUM_RULES_BAD_FORMAT', 'rules is not an object: ' + rules)
        }

        for (let elem in rules) {
          if (activeObjectKey[elem] === undefined || Array.isArray(rules[elem]) === false) {
            throw new CustomError('ENUM_RULES_BAD_FORMAT', 'Each attribute of rules must be an element in the ENUM and its value should be an array: ' + activeObjectKey[elem] + rules[elem])
          }

          let valuesWithProblems = rules[elem].filter(itemTo => activeObjectKey[itemTo] === undefined);

          if (valuesWithProblems.length > 0) {
            throw new CustomError('ENUM_RULES_BAD_FORMAT', 'All elements in a rule entry must be one of the list values in the ENUM. The following values dont exist: ' + valuesWithProblems)
          }
        }

        stateRules = cloneDeep$1(rules);
      }

      function get(_target, prop) {
        if (prop === 'getValue') {
          return getValue
        }

        if (activeObjectKey[prop] == null) throw new CustomError('ENUM_INVALID_PROPERTY', `.${prop} is none of the possible values ${this}`)

        return activeObjectKey[prop]
      }

      function set(_undefined, prop, value) {
        if (value !== true) {
          throw new CustomError('ENUM_ACTIVATION_NO_TRUE', `Tryng to set ${prop} with ${value} but activation only admits true`)
        }

        if (activeObjectKey[prop] === undefined) {
          throw new CustomError('ENUM_INVALID_PROPERTY', `.${prop} is none of the possible values ${this}`)
        }

        if (validateChange(activeKey, prop)) {
          activeObjectKey[activeKey] = false;
          activeObjectKey[prop] = true;
          activeKey = prop;
        } else throw new CustomError('ENUM_TRANSITION_NOT_ALLOWED', `.From: ${activeKey} --> To: ${prop}`)

        return true
      }

      function validateChange(activeElement, prop) {
        if (stateRules === undefined) return true

        return stateRules[activeElement] !== undefined && stateRules[activeElement].indexOf(prop) !== -1

      }
      function getValue() {
        return activeKey
      }
    }
  }
  // const ENGINE = new Enum(
  //   ['UNDEFINED', 'START', 'SPEED', 'BREAK', 'STOP','ABANDONED'],
  //   {
  //     'UNDEFINED':['START'],
  //     'START':['SPEED', 'BREAK', 'STOP'],
  //     'SPEED':['BREAK', 'STOP'],
  //   }
  // )
  // ENGINE.START = true
  // ENGINE.START //?
  // ENGINE.SPEED = true
  // ENGINE.SPEED 

  // try {
  //   ENGINE.SPEED = true
  // }catch(e)
  // {
  //   e  //? ENUM_TRANSITION_NOT_ALLOWED It is not defined to go to itself.
  // }

  // try {
  //   const result = new Enum(
  //     ['UNDEFINED', 'START', 'SPEED', 'BREAK', 'STOP','ABANDONED'],
  //     {
  //       'UNDEFINED':['START'],
  //       'START':['SPEED', 'BREAK', 'STOP'],
  //       'SPEEDRT':['BREAK', 'STOP'],
  //     }
  //   )

  // } catch (e) {
  //   e //?  ENUM_RULES_BAD_FORMAT SPEEDRT is not valid
  // }


  class EnumMap {
    constructor(values) {

      return new Proxy(cloneDeep$1(values), this)
    }

    get(target, prop) {
      if (target[prop] == null && this[prop] == null) throw new CustomError('ENUM_OUT_OF_RANGE', `.${prop} is none of the possible values ${this}`)

      if (this[prop] != null) return this[prop]

      return target[prop]
    }

    set(_undefined, prop) {
      throw new CustomError('ENUM_NOT_MODIFIABLE', `Object of .${prop} is not modifiable`)
    }

    invert() {
      let invertedValues = {};

      for (const elem in this) {
        if (this.hasOwnProperty(elem)) {
          if (invertedValues[this[elem]] === undefined) {
            invertedValues[this[elem]] = [];
          }

          pushUniqueKey(elem, invertedValues[this[elem]]);
        }
      }

      if (Object.keys(invertedValues).reduce((acum, current) => acum && invertedValues[current].length === 1, true)) {
        invertedValues = Object.keys(invertedValues).reduce(
          (acum, current) => {
            acum[current] = invertedValues[current][0];
            return acum
          },
          {}
        );
      }

      return new EnumMap(cloneDeep$1(invertedValues))
    }

  }
  // {
  //   const SWITCHER = new EnumMap({ON:0,OFF:1})
  //   SWITCHER.ON //? 0
  //   SWITCHER.OFF //? 1
  //   try { SWITCHER.ONFF
  //   }catch(e){
  //     e // ENUM_OUT_OF_RANGE
  //   }
  //   const INVERT_SWITCHER = SWITCHER.invert()
  //   INVERT_SWITCHER['0'] //?
  //   const value = SWITCHER.ON
  //   value === 0 //? true
  // }


  function transition(states, events, transitions)
  {
    states.forEach(validateStateFormat);
    events.forEach(validateEventFormat);

    let state = states[0];
    let finalTransitions = Object.entries(transitions).reduce(
      (acum, [stateKey, stateValue]) => {
        // validations
        validateState(stateKey);

        let newStateValue = stateValue;
        if(typeof stateValue === 'string') 
        {
          validateState(stateValue);

          newStateValue = events.reduce(
            (acum, current) => {
              acum[current] = stateValue;
              return acum
            },
            {}
          );
        }else
        {
          Object.entries(newStateValue).forEach(([key, value])=> {
            validateEvent(key);
            validateState(value);
          });
        }

        

        acum[stateKey] = {...acum[stateKey], ...newStateValue};
        return acum
      },
      states.reduce(
        (acum, current) => {
          acum[current] = 
            events.reduce(
              (acum2, el2) => {
                acum2[el2] = el2.toUpperCase();
                return acum2
              },
              {}
            );
          return acum
        },
        {}
      )
    );

    function sendEvent(event) {
      validateEvent(event);
      return state = finalTransitions[state][event]
    }

    sendEvent.valueOf = () => state;

    return sendEvent

    function validateStateFormat(state)
    {
      if(state !== state.toUpperCase())
        throw new CustomError('STATE_MUST_BE_UPPERCASE', `The state: ${state} does not have all characters in uppercase`)
    }

    function validateState(state)
    {
      if(states.some(el => el === state) === false)
        throw new CustomError('STATE_NOT_FOUND', `The state: ${state} was not found in the list of states supplied: ${states}`)
    }


    function validateEventFormat(event)
    {
      if(event !== event.toLowerCase())
        throw new CustomError('EVENT_MUST_BE_LOWERCASE', `The event: ${event} does not have all characters in lowercase`)
    }


    function validateEvent(event)
    {
      if(events.some(el => el === event) === false)
        throw new CustomError('EVENT_NOT_FOUND', `The event: ${event} was not found in the list of events supplied: ${events}`)
    }
  }

  // const tranDef = [
  //   ['SYNC', 'PROMISE', 'FUTURE', 'PROMISE_AND_FUTURE'],
  //   ['sync','promise','future'],
  //   // STATE:{event:NEW_STATE}
  //   // if a event is not defined within a STATE then the default value is selected STATE:{missing_event: NEW_STATE(missing_event.toUpperCase())}
  //   {
  //     PROMISE:{
  //       sync:'PROMISE',
  //       future: 'PROMISE_AND_FUTURE'
  //       //by default: promise: 'PROMISE'
  //     },
  //     FUTURE:{
  //       sync:'FUTURE',
  //       promise: 'PROMISE_AND_FUTURE',
  //     },
  //     PROMISE_AND_FUTURE: 'PROMISE_AND_FUTURE' // same as {sync: 'PROMISE_AND_FUTURE', promise: 'PROMISE_AND_FUTURE', future: 'PROMISE_AND_FUTURE'}
  //   }
  // ]

  // const typeOfList = transition(...tranDef)

  // typeOfList('future') //?
  // typeOfList('future') //?
  // typeOfList('promise') //?
  // typeOfList('sync') //?
  // try{
  //   typeOfList('sync2')  //?
  // }catch(e) {console.log(e)}

  // typeOfList('sync') //?

  // typeOfList.valueOf() //?

  function arrayToObject(arr, defaultValueFunction) {
    return arr.reduce((acum, current, index) => {
      acum[current] = defaultValueFunction(current, index);
      return acum
    }, {})
  }

  function arrayOfObjectsToObject(iterable) {
    if (typeof iterable?.[Symbol.iterator] === 'function') {
      let acum = {};
      for (let elem of iterable) {
        for (const key in elem) {
          acum[key] = elem[key];
        }
      }
      return acum
    }

    return arr.reduce((acum, current, index) => {
      for (const key in current) {
        acum[key] = current[key];
      }
      return acum
    }, {})
  }

  function removeDuplicates(arr) {
    return [...new Set(arr)]
  }

  // reviver is called for each node as: reviver(nodeRef, currentPath, parent). For example: currentPath=['root', 'parent', 'son', '0', 'jose']
  // reviver return value will impact traverse: 
  //  undefined: do nothing.
  //  Any value: assign this value (parent[key])
  //  traverse.stop: stop inmediatly traverse
  //  traverse.skip: skip node. It doesnt look at children of node.
  //  prune: if true remove node.


  function traverse$1(objIni, reviver, pureFunction = true) {
    const currentPath = ['root'];

    const objClone = pureFunction ? cloneDeep$1(objIni) : objIni;

    let exitVar = false;
    let objForReviver = {};
    objForReviver['root'] = objClone;

    let isSkipNodeOnce = reviverProcess(reviver, objForReviver, 'root', currentPath);

    if (objClone !== objForReviver['root']) return objForReviver['root']

    if (exitVar === true) return objForReviver['root']

    if (isSkipNodeOnce === false) {
      traverseRec(objForReviver['root']);
    }

    return objForReviver['root']

    function traverseRec(obj) {

      if (obj && obj instanceof Object && exitVar === false) {
        for (const prop in obj) {

          if (obj.hasOwnProperty(prop)) {
            currentPath.push(prop);

            let isSkipNodeOnce = reviverProcess(reviver, obj, prop, currentPath);

            if (exitVar === true) return

            if (isSkipNodeOnce === false) {
              traverseRec(obj[prop]);
            }

            currentPath.pop();
          }
        }
      }
    }

    function reviverProcess(reviver, obj, prop, currentPath) {
      let isSkipNodeOnce = false;

      if (reviver) {
        const resultReviver = reviver(obj[prop], currentPath, obj, prop);
        if (resultReviver !== undefined && resultReviver !== traverse$1.stop && resultReviver !== traverse$1.skip && resultReviver !== traverse$1.delete) {
          obj[prop] = resultReviver;
        }

        if (resultReviver === traverse$1.stop) {
          exitVar = true;
        }

        if (resultReviver === traverse$1.skip) {
          isSkipNodeOnce = true;
        }

        if (resultReviver === traverse$1.delete) {
          obj[prop] = undefined;
          isSkipNodeOnce = true;
        }
      }

      return isSkipNodeOnce
    }

  }

  traverse$1.skip = Symbol();
  traverse$1.stop = Symbol();
  traverse$1.delete = Symbol();


  function copyPropsWithValueUsingRules(objDest, copyRules, shouldUpdateOnlyEmptyFields = false) {

    return function (inputObj) {
      copyRules.map(
        (rule) => {
          let from, to;
          if (typeof rule === 'object') {
            from = rule.from;
            to = rule.to;
          } else {
            from = rule;
            to = rule;
          }

          let valueToCopy = getValueAtPath(inputObj, from);

          if (valueToCopy === undefined || valueToCopy === null) return

          if (shouldUpdateOnlyEmptyFields === true && isEmpty$1(getValueAtPath(objDest, to)))
            setValueAtPath(objDest, to, valueToCopy);

          if (shouldUpdateOnlyEmptyFields === false)
            setValueAtPath(objDest, to, valueToCopy);

        }
      );

      return objDest
    }
  }
  // {
  //   let objTo = {a:{b:2},c:3}
  //   let objFrom = {a:{b:4},c:8,d:{e:{f:12}}}
  //   copyPropsWithValueUsingRules(objTo, [{from:'a.b', to:'c'}, {from:'d.e.f', to:'d'}])(objFrom)
  //   objTo
  // }
  // {
  //   let objTo = {a:{b:2},c:3}
  //   let objFrom = {a:{b:4},c:8,d:{e:{f:12}}}
  //   copyPropsWithValueUsingRules(objTo, 
  //     [
  //       {from:'a.b', to:'c'},
  //       {from:'d.e.f', to:'d.f'},
  //       {from:'d.e.g', to:'d.g'}
  //     ],
  //     true
  //   )(objFrom)
  //   objTo
  // }

  function copyPropsWithValue(objDest, shouldUpdateOnlyEmptyFields = false) {
    return function (input) {
      traverse$1(input, (nodeValue, currentPath) => {

        if (isALeaf(nodeValue) === false) return

        if (nodeValue === undefined || nodeValue === null) return

        const destPath = currentPath.slice(1 - currentPath.length);

        if (shouldUpdateOnlyEmptyFields === true) {
          const valueAtDest = getValueAtPath(objDest, destPath);
          if (isEmpty$1(valueAtDest)) setValueAtPath(objDest, destPath, nodeValue);

          return
        }

        setValueAtPath(objDest, destPath, nodeValue); //?

      });

      return objDest
    }
  }
  // {
  //   let objTo = { a: { b: 2 }, c: 3, h: { i: 3 } }
  //   let objFrom = { a: { b: 4 }, c: undefined, d: { e: { f: 12 } } }
  //   copyPropsWithValue(objTo)(objFrom) //?
  //   objTo
  // }
  // {
  //   let objTo = { a: { b: 2 }, c: 3, h: { i: 3 } }
  //   let objFrom = { a: { b: 4 }, c: '', d: { e: { f: 12 } } }
  //   copyPropsWithValue(objTo, undefined, true)(objFrom) //?
  //   objTo
  // }

  function isALeaf(node) {
    const isABranch =
      (node?.constructor.name === 'Object' && Object.keys(node).length > 0) ||
      (node?.constructor.name == 'Array' && node.length > 0);

    return !isABranch
  }
  // isALeaf(undefined) //?
  // isALeaf({a:'this is a leaf'}.a) //?
  // isALeaf(new Date()) //?
  // isALeaf([]) //?
  // isALeaf({}) //?
  // isALeaf({a:3}) //?
  // isALeaf([undefined]) //?

  function isEmpty$1(value) {
    if (
      value === undefined ||
      value === null ||
      value === '' ||
      value === 0 ||
      value !== value ||
      (Array.isArray(value) && value?.length === 0) ||
      (typeof value === 'object' && Object.keys(value).length === 0)
    ) return true

    return false
  }
  //isEmpty(0) //?

  function firstCapital(str) {

    return typeof str === 'string' ? str[0].toUpperCase() + str.substring(1).toLowerCase() : str
  }


  function queryObjToStr(query) {
    return Object.keys(query).reduce((acum, current) => {
      const newAcum = acum ? acum + '&' : acum;
      return newAcum + current + '=' + query[current]
    }, '')
  }

  function varSubsDoubleBracket(strToResolveVars, state, mode) {
    if (typeof strToResolveVars !== 'string') {
      return strToResolveVars
    }

    /*
      
    {
      "response": {
        "id": 1231,
        "description": "{{description=\"This is a test\"}}",
        "car": "{{plate}}",
        "active": "{{active=true}}",
        "ratenumber": "{{rate=10}}"
      }
    }
    */

    // regex to deal with the case the entire value is a substitution group
    let regexVar = /"{{(.*?)(?:=(.*?))?}}"/g;

    let resultStr = strToResolveVars.replace(
      regexVar,
      (_notused, group1, group2) => {
        if (state && state[group1] !== undefined) {
          if (typeof state[group1] === 'string') return '"' + state[group1] + '"'
          else if (typeof state[group1] === 'object') {
            if (mode === 'url' && Array.isArray(state[group1]))
              return arrayToListQuery(state[group1])
            if (mode === 'url' && !Array.isArray(state[group1]))
              return objToQueryParams(state[group1])
            if (!mode) return JSON.stringify(state[group1])
          } else return state[group1]
        } else {
          if (group2 === undefined) return null
          //else if(group2.substring(0,2) === '\\"' && group2.substring([group2.length -1],2) === '\\"') return ('"' + group2 + '"')
          else return group2.replace(/\\"/g, '"')
        }
      }
    );

    // regex to do partial substitution of a group inside of a string value
    let regexVarPartial = /{{(.*?)(?:=(.*?))?}}/g;
    let resultStrFinal = resultStr.replace(
      regexVarPartial,
      (_notused, group1, group2) => {
        if (state && state[group1] !== undefined) {
          if (typeof state[group1] === 'object') {
            if (mode === 'url' && Array.isArray(state[group1]))
              return arrayToListQuery(state[group1])
            if (mode === 'url' && !Array.isArray(state[group1]))
              return objToQueryParams(state[group1])
            if (!mode) return JSON.stringify(state[group1])
          } else return state[group1]
        } else {
          if (group2 === undefined) return null
          //else if(group2.substring(0,2) === '\\"' && group2.substring([group2.length -1],2) === '\\"') return ('"' + group2 + '"')
          else return group2.replace(/\\"/g, '')
        }
      }
    );

    return resultStrFinal
  }

  function arrayToListQuery(arr) {
    return arr.reduce((prev, curr) => prev + ',' + curr)
  }

  function objToQueryParams(obj) {
    return Object.keys(obj)
      .reduce((acum, curr) => acum + curr + '=' + obj[curr] + '&', '')
      .slice(0, -1)
  }

  function urlCompose(gatewayUrl, serviceName, servicePath) {
    return {
      gatewayUrl,
      serviceName,
      servicePath,
      url: gatewayUrl + serviceName + servicePath
    }
  }

  function urlDecompose(url, listOfServiceNames) {
    return listOfServiceNames
      .filter(elem => url.split(elem).length >= 2)
      .map(elem => {
        const [part1, ...restParts] = url.split(elem);
        return {
          gatewayUrl: part1,
          serviceName: elem,
          servicePath: restParts.join(elem)
        }
      })
  }

  function indexOfNthMatch(string, toMatch, nth) {
    return string.split(toMatch, nth).join(toMatch).length
  }

  function isDate(d) {
    return d instanceof Date && !isNaN(d);
  }

  function isStringADate(stringDate) {
    if (typeof stringDate !== 'string') return false

    const date = new Date(stringDate);

    if (date >= new Date('0000-01-01') && date <= new Date('9999-12-31')) return true

    return false
  }

  function dateFormatter(format) {
    return (date) => formatDate(format, date)
  }

  function formatDate(format, date) {

    let dateToProcess = (date ? new Date(date) : new Date());

    const months = new EnumMap({
      'January': '01',
      'February': '02',
      'March': '03',
      'April': '04',
      'May': '05',
      'June': '06',
      'July': '07',
      'August': '08',
      'September': '09',
      'October': '10',
      'November': '11',
      'December': '12'
    });

    const indexMonths = months.invert();

    const days = new EnumMap({
      'Sunday': '0',
      'Monday': '1',
      'Tuesday': '2',
      'Wednesday': '3',
      'Thursday': '4',
      'Friday': '5',
      'Saturday': '6'
    });

    const indexDays = days.invert();

    const dateIsoString = dateToProcess.toISOString();

    const YYYY = dateIsoString.substr(0, 4);
    const YY = dateIsoString.substr(2, 2);
    const MM = dateIsoString.substr(5, 2);
    const DD = dateIsoString.substr(8, 2);
    const D = parseInt(DD, 10).toString();
    const hh = dateIsoString.substr(11, 2);
    const h = parseInt(hh, 10).toString();
    const mm = dateIsoString.substr(14, 2);
    const ss = dateIsoString.substr(17, 2);
    const mil = dateIsoString.substr(20, 3);
    const mi = dateIsoString.substr(20, 2);

    const month = indexMonths[MM];
    const dayOfWeek = indexDays[dateToProcess.getDay()];

    return format
      .replace(/\$YYYY/g, YYYY)
      .replace(/\$YY/g, YY)
      .replace(/\$MM/g, MM)
      .replace(/\$DD/g, DD)
      .replace(/\$D/g, D)
      .replace(/\$hh/g, hh)
      .replace(/\$h/g, h)
      .replace(/\$mm/g, mm)
      .replace(/\$ss/g, ss)
      .replace(/\$mil/g, mil)
      .replace(/\$mi/g, mi)
      .replace(/\$month/g, month)
      .replace(/\$dayOfWeek/g, dayOfWeek)

  }
  //formatDate('$YYYY-$MM-$DD', new Date('2021-02-28')) //?

  function YYYY_MM_DD_hh_mm_ss_ToUtcDate(dateYYYY_MM_DD_hh_mm_ss) {
    // Input format has 1 char (any could work) between each elements: years, months, days, hours, minutes and seconds
    const dateYYYY = parseInt(dateYYYY_MM_DD_hh_mm_ss.substr(0, 4));
    const dateMM = parseInt(dateYYYY_MM_DD_hh_mm_ss.substr(5, 2)) - 1; // Months start with 0
    const dateDD = parseInt(dateYYYY_MM_DD_hh_mm_ss.substr(8, 2));
    const datehh = parseInt(dateYYYY_MM_DD_hh_mm_ss.substr(11, 2));
    const datemm = parseInt(dateYYYY_MM_DD_hh_mm_ss.substr(14, 2));
    const datess = parseInt(dateYYYY_MM_DD_hh_mm_ss.substr(17, 2));

    return Date.UTC(dateYYYY, dateMM, dateDD, datehh, datemm, datess)
  }

  function dateToObj(date) {
    let dateToProcess = new Date(date) ?? new Date();
    let ISODate = dateToProcess.toISOString();

    return {
      YYYY: parseInt(ISODate.substr(0, 4)),
      MM: parseInt(ISODate.substr(5, 2)),
      DD: parseInt(ISODate.substr(8, 2)),
      hh: parseInt(ISODate.substr(11, 2)),
      mm: parseInt(ISODate.substr(14, 2)),
      ss: parseInt(ISODate.substr(17, 2)),
      mil: parseInt(ISODate.substr(20, 3))
    }
  }
  //dateToObj() //?
  // const toPeriod = new Date()
  // const fromPeriod = `${dateToObj(toPeriod).YYYY - 3}${formatDate('-$MM-$DD', toPeriod)}` 
  // fromPeriod //?

  function diffInDaysYYYY_MM_DD(iniDate, endDate) {
    return Math.ceil(
      (
        new Date(endDate) - new Date(iniDate)
      ) / (1000 * 60 * 60 * 24)
    ) //?
  }

  function subtractDays(daysToSubtract, date) {
    let dateToReturn =
      date
        ? new Date(date)
        : new Date();

    if (isDate(dateToReturn) === false) return date

    dateToReturn.setDate(dateToReturn.getDate() - daysToSubtract);
    return dateToReturn
  }
  //subtractDays(40).toISOString() //?
  //subtractDays(3, new Date('2021-03-25')) //?

  function previousDayOfWeek(dayOfWeek, date) {
    let dateObj = date ?? new Date();

    if (isDate(dateObj) === false) return date

    let diffInDaysOfWeek = dateObj.getDay() - dayOfWeek;

    let toSubtract = diffInDaysOfWeek >= 0
      ? diffInDaysOfWeek
      : 7 + diffInDaysOfWeek;

    return subtractDays(toSubtract, dateObj)
  }
  //previousDayOfWeek(6,new Date('2021-05-07')).toISOString() //?
  //previousDayOfWeek(1,new Date('2021-03-25'))

  function getSameDateOrPreviousFridayForWeekends(date) {
    let dateObj = date ?? new Date();

    if (isDate(dateObj) === false) return date

    const dayOfWeek = dateObj.getUTCDay();

    if (dayOfWeek > 0 && dayOfWeek < 6) return dateObj

    //Sunday
    if (dayOfWeek === 0) return subtractDays(2, dateObj)

    //Saturday (dayOfWeek === 6)
    return subtractDays(1, dateObj)
  }
  // getSameDateOrPreviousFridayForWeekends() //?
  // //2021-05-14T00:00:00.000Z
  // getSameDateOrPreviousFridayForWeekends(new Date('2021-05-15')).toISOString() //?
  // ////2021-05-14T00:00:00.000Z
  // getSameDateOrPreviousFridayForWeekends(new Date('2021-05-16')).toISOString() //?


  const {
    colors,
    colorMessage,
    colorMessageByStatus,
    colorByStatus
  } = (function () {
    //alias
    const colors = {
      red: '\x1b[31m',
      green: '\x1b[32m',
      yellow: '\x1b[33m',
      cyan: '\x1b[36m',
      blue: '\x1b[34m',
      //most importants
      reset: '\x1b[0m',
      reverse: '\x1b[7m',
      fgBlack: '\x1b[30m',
      fgRed: '\x1b[31m',
      fgGreen: '\x1b[32m',
      fgYellow: '\x1b[33m',
      //Others
      fgBlue: '\x1b[34m',
      fgMagenta: '\x1b[35m',
      fgCyan: '\x1b[36m',
      fgWhite: '\x1b[37m',
      bgBlack: '\x1b[40m',
      bgRed: '\x1b[41m',
      bgGreen: '\x1b[42m',
      bgYellow: '\x1b[43m',
      bgBlue: '\x1b[44m',
      bgMagenta: '\x1b[45m',
      bgCyan: '\x1b[46m',
      bgWhite: '\x1b[47m',
      bright: '\x1b[1m',
      dim: '\x1b[2m',
      underscore: '\x1b[4m',
      blink: '\x1b[5m',
      hidden: '\x1b[8m'
    };

    const colorMessage = (message, color) =>
      colors[color] + message + colors.reset;

    const colorMessageByStatus = (message, status) => {
      let colorStatus

        ; (status >= 200) & (status < 300)
          ? (colorStatus = colors.green)
          : (status >= 300) & (status < 400)
            ? (colorStatus = colors.cyan)
            : (status >= 400) & (status < 500)
              ? (colorStatus = colors.yellow)
              : (colorStatus = colors.red);

      return colorStatus + message + colors.reset
    };

    const colorByStatus = status => {
      let colorStatus

        ; (status >= 200) & (status < 300)
          ? (colorStatus = colors.green)
          : (status >= 300) & (status < 400)
            ? (colorStatus = colors.cyan)
            : (status >= 400) & (status < 500)
              ? (colorStatus = colors.yellow)
              : (colorStatus = colors.red);

      return colorStatus
    };

    return { colors, colorMessage, colorMessageByStatus, colorByStatus }
  })();

  function findDeepKey(objIni, keyToFind) {
    const currentPath = [];
    const result = [];

    traverse(objIni);

    function traverse(obj) {
      for (const prop in obj) {
        if (prop === keyToFind) {
          result.push([...currentPath]);
          result[result.length - 1].push(prop);
          result.push(obj[prop]);
        }

        if (obj[prop] !== null && typeof obj[prop] == 'object') {
          currentPath.push(prop);
          traverse(obj[prop]);
          currentPath.pop();
        }
      }
    }
    return result
  }

  function deepFreeze(o) {
    Object.getOwnPropertyNames(o).forEach(prop => {
      if (
        o[prop] !== null &&
        (typeof o[prop] === 'object' || typeof o[prop] === 'function')
      ) {
        deepFreeze(o[prop]);
      }
    });

    Object.freeze(o);

    return o
  }

  function getValueAtPath(obj, valuePath) {
    if (obj === undefined || obj === null || valuePath === undefined || valuePath === null) {
      return
    }

    if (valuePath === '') return obj

    let result = obj;

    const valuePathArray = typeof valuePath === 'string' ? valuePath.split('.') : valuePath;

    for (let o of valuePathArray) {
      if (result === undefined) return result

      if (
        (result instanceof Object)
      ) {
        if (o === '$last' && Array.isArray(result)) result = result[result.length - 1];
        else result = result[o];
      } else {
        result = undefined;
      }
    }

    return result
  }
  // getValueAtPath(undefined, '') //?
  // getValueAtPath(5, '') //?
  // getValueAtPath({arr:[1,2,{b:3}],j:{n:3}}, 'j') //?
  // getValueAtPath({arr:[1,2,{b:3}],j:{n:3}}, 'arr.$last.b') //?
  // getValueAtPath({arr:[1,2,{b:3}],j:{n:3}}, 'j') //?


  function setValueAtPath(obj, valuePath, value) {
    // modified the value of an existing property:   {a:8} ==> 'a' with 12 => {a:12}
    const MODIFIED = 'MODIFIED';

    // added another property to an existing object: {a:8} ==> 'b' with 14 => {a:8,b:14}   --or--   {a:{c:8}} == 'a.b' with 14 => {a:{c:8, b:14}}
    const ADDED = 'ADDED';

    // The path provoked the creation of a new object that was nested.
    // Examples: {a:8} == 'a.b' with 3 => {a:{b:3}}  --or--   {a:{b:3}} == 'c.d' with 3 => {a:{b:3},c:{d:3}}
    // Before the request the penultimate path item is not an object. As in: a of 'a.b' ... or c of 'c.d' for the above examples
    const CREATED = 'CREATED';

    const FAILED = 'FAILED';

    let result = obj;
    let valueReturn = FAILED;
    let valuePathArray;

    if (obj === undefined || obj === null || valuePath === undefined || valuePath === null) {
      throw { name: 'setValueAtPathParamsException', msg: 'obj: ' + obj + ', valuePath: ' + valuePath + ', value: ' + value }
    }

    try {
      valuePathArray = typeof valuePath === 'string' ? valuePath.split('.') : valuePath;
      valuePathArray;
      for (let i = 0, j = valuePathArray.length; i < j; i++) {

        if (i === (valuePathArray.length - 1)) {
          if (result?.[valuePathArray[i]] !== undefined) {
            result?.[valuePathArray[i]]; //?
            valueReturn;
            if (valueReturn !== CREATED) valueReturn = MODIFIED;
          } else {
            if (valueReturn !== CREATED) valueReturn = ADDED;
          }
          result[valuePathArray[i]] = value;
        } else {
          if (typeof result[valuePathArray[i]] !== 'object') {
            if (Number.isNaN(Number(valuePathArray[i + 1]))) result[valuePathArray[i]] = {};
            else result[valuePathArray[i]] = [];

            valueReturn = CREATED;
          }

          result = result[valuePathArray[i]];
        }
      }
      if (valueReturn === FAILED) {
        throw { name: 'setValueAtPathException', msg: 'obj: ' + obj + ', valuePath: ' + valuePath + ', value: ' + value }
      }
    }
    catch (e) {
      console.log(e + ' Warning: There was an exception in setValueAtPath(obj, valuePath, value)... obj: ' + obj + ' valuePath: ' + valuePath + ' value: ' + value);
      valueReturn = FAILED;
      return valueReturn
    }
    return valueReturn
  }
  // {
  //   let obj = {}
  //   setValueAtPath(obj, 'a', '8') //?
  //   obj //?
  //   let obj2 = {a:3}
  //   setValueAtPath(obj2, 'b', '8') //?
  //   setValueAtPath(obj2, 'a.b', '8') //?
  //   setValueAtPath(obj2, 'd.e', 'a') //?
  //   obj2
  //   setValueAtPath(obj2, 'd.f', 'b') //?
  //   setValueAtPath(obj2, 'd.e', 'aa') //?
  //   setValueAtPath(obj2, 'e.g', 'c') //?
  //   obj2 //?
  // }

  const sorterByPaths = (paths, isAsc = true) => {
    let great = 1;
    let less = -1;

    if (isAsc === false) {
      great = -1;
      less = 1;
    }

    let pathArr;
    if (typeof paths === 'string') pathArr = [paths];
    else pathArr = [...paths];

    return (objA, objB) => {

      for (let currentPath of pathArr) {
        if (getValueAtPath(objA, currentPath) > getValueAtPath(objB, currentPath)) return great
        else if (getValueAtPath(objA, currentPath) < getValueAtPath(objB, currentPath)) return less
      }

      return 0
    }

  };
  // console.log(
  //   [{a:{b:3}}, {a:{b:2}}, {a:{b:5}}, {a:{b:4}}].sort(sorterByPaths('a.b')),
  //   [{a:{b:3}}, {a:{b:2}}, {a:{b:5}}, {a:{b:4}}].sort(sorterByPaths('a.b', true)),
  //   [{a:{b:3}}, {a:{b:2}}, {a:{b:5}}, {a:{b:4}}].sort(sorterByPaths('a.b', false)),
  //   [{a:{b:3}}, {a:{b:2}}, {a:{b:5}}, {a:{b:4}}].sort(sorterByPaths(['a.b'], false)),
  //   [{a:{b:3,c:2}}, {a:{b:3,c:1}}, {a:{b:5}}, {a:{b:4}}].sort(sorterByPaths(['a.b','a.c'], true)),
  // )

  function filterFlatMap(mapWithUndefinedFilterFun, data) {
    let result = [];
    let resultSize = 0;
    let mappedItem;

    for (let index = 0, dataLength = data.length; index < dataLength; index++) {
      mappedItem = mapWithUndefinedFilterFun(data[index], index, data);

      if (mappedItem !== undefined) {
        if (Array.isArray(mappedItem) === true) {
          for (let mappedItemIndex = 0, mappedItemLength = mappedItem.length; mappedItemIndex < mappedItemLength; mappedItemIndex++) {
            if (mappedItem[mappedItemIndex] !== undefined) result[resultSize++] = mappedItem[mappedItemIndex];
          }
        } else {
          result[resultSize++] = mappedItem;
        }

      }
    }

    return result
  }
  // filterFlatMap(
  //   (elem, index)=> {
  //     if(index === 0) return [elem, elem + 2, undefined]
  //     if(index === 1) return elem + 2
  //     if(index === 2) return undefined
  //     if(index === 5) return [undefined]
  //     if(index === 6) return []

  //     return elem
  //   }
  //   , [1,4,13,3,8,9,11]) //?

  const arraySorter = (isAsc = true) =>
    (a, b) => {
      if (isAsc === false) {
        if (a < b) return 1
        if (a > b) return -1
        return 0
      }

      if (a < b) return -1
      if (a > b) return 1
      return 0
    };
  // [1, 4, 3, 6].sort(arraySorter()); //?
  // ['as', 'dc', 'ce', ' as'].sort(arraySorter(false)); //?
  // [new Date('2020-01-01'), new Date('2021-01-05')].sort(arraySorter(true)); //?


  function isPromise(obj) {
    return !!obj && (typeof obj === 'object' || typeof obj === 'function') && typeof obj.then === 'function';
  }

  function sleep(ms) {
    return new Promise(resolve => setTimeout(resolve, ms))
  }

  function sleepWithValue(ms, value) {
    return new Promise(resolve =>
      setTimeout(() => resolve(value), ms)
    )
  }

  function sleepWithFunction(ms, func, ...params) {
    return new Promise(resolve =>
      setTimeout(() => resolve(func(...params)), ms)
    )
  }

  async function retryWithSleep(times, updateSleepTimeFun, funToRun, funToRunParams, shouldStopRetrying) {
    let result;
    let currentSleepTime = 0;

    for (let index = 0; index < times; index++) {
      if (index > 0) await sleep(currentSleepTime);

      try {
        result = await funToRun(...funToRunParams);
      } catch (e) {
        if (index === times - 1) throw e
        result = e;
      }

      if (shouldStopRetrying === undefined && ((result instanceof Error) === false)) {
        return result
      }

      try {
        if (shouldStopRetrying?.(result) === true) return result
      } catch (e) {
        console.log('Called to shouldStopFun failed with params: ', { currentSleepTime, index });
        console.log('Throwing exception...');
        throw e
      }

      const extractError = result?.message ?? result?.error ?? result?.code ?? result?.status ?? result?.status ?? result?.name;
      console.log(`Iteration: ${index + 1} sleepTime: ${currentSleepTime} Error: ${extractError}`);

      try {
        currentSleepTime = updateSleepTimeFun(currentSleepTime, index);
      } catch (e) {
        console.log('Calling updateSleepTimeFun failed with params: ', { currentSleepTime, index });
        throw e
      }

    }

    return result

  }
  // retryWithSleep(
  //   10, 
  //   (_, index) => 300 + index*500, 
  //   (input)=> Math.random() < 0.9 ? new Error('Error...'): {value:'OK',status:'Didnt failed'}, 
  //   []
  // )
  //   .then(result => console.log(result))

  // retryWithSleep(
  //   10, 
  //   (_, index) => 300 + index*500, 
  //   (input)=> {input.total = input.total + Math.random(); return input}, 
  //   [{total:0}],
  //   (currentResult) => currentResult.total > 5? true: false
  // )
  //   .then(result => console.log(result))

  const notTo = funct => (...params) => !funct(...params);

  function pushUniqueKey(row, table, indexes = [0]) {

    const keyOfRowToInsert = key(row, indexes);

    if (
      table.find(rowTable => key(rowTable, indexes) === keyOfRowToInsert)
      ===
      undefined
    ) {
      table.push(row);
      return row
    }

    return undefined

    ////
    function key(row, indexes) {
      //if (Array.isArray(row) === false) return row
      if (typeof row !== 'object') return row

      return indexes.reduce((acum, current, index) => acum + `-${index}-` + row[current], '')
    }

  }
  // pushUniqueKey(
  //   [2,3],
  //   [[1,2],[2,3],[1,3]],
  //   [0,1]
  // ) //?
  // pushUniqueKey(
  //   [2,4],
  //   [[1,2],[2,3],[1,3]],
  //   [0,1]
  // ) //?
  // pushUniqueKey(
  //   4,
  //   [1,2],
  // ) //?
  // pushUniqueKey(
  //   2,
  //   [1,2],
  // ) //?
  // pushUniqueKey(
  //   {a:2,b:4},
  //   [{a:1,b:2},{a:2,b:5},{a:3,b:4}],
  //   ['a','b']
  // ) //?
  // pushUniqueKey(
  //   {a:2,b:4},
  //   [{a:1,b:2},{a:2,b:4},{a:3,b:4}],
  //   ['a','b']
  // ) //?


  function pushUniqueKeyOrChange(newRow, table, indexes = [0], mergeFun) {

    if (pushUniqueKey(newRow, table, indexes) === undefined) {

      const newRowKey = key(newRow, indexes);
      return table.map(
        (existingRow) => {
          if (newRowKey === key(existingRow, indexes)) return mergeFun(newRow, existingRow)

          return existingRow
        }
      )
    }

    return table

    ////
    function key(row, indexes) {
      //if (Array.isArray(row) === false) return row
      if (typeof row !== 'object') return row

      return indexes.reduce((acum, current, index) => acum + `-${index}-` + row[current], '')
    }

  }
  // pushUniqueKeyOrChange(
  //   [1,3],
  //   [[1,2],[2,3],[1,3]],
  //   [0],
  //   (newRow, existingRow) => [newRow[0] + existingRow[0], newRow[1] + existingRow[1]]
  // ) //?

  function memoize() {
    const resultsMap = new Map();

    function memoizeMap(func, ...params) {
      let key = JSON.stringify(params);
      let result = resultsMap.get(key);

      if (result === undefined && resultsMap.has(key) === false) {
        result = func(...params);
        resultsMap.set(key, result);
      }

      return result
    }

    function memoizeWithHashFun(func, hashFunc, ...params) {
      let key = JSON.stringify(hashFunc(params));
      let result = resultsMap.get(key);

      if (result === undefined && resultsMap.has(key) === false) {
        result = func(...params);
        resultsMap.set(key, result);
      }

      return result
    }

    return { memoizeMap, memoizeWithHashFun }

  }

  // const plus = (a,b) => a+b
  // const plusMem = memoize()
  // plusMem(plus, 2,3) //?
  // plusMem(plus, 2,3) //?
  // plusMem(plus, 3,3) //?
  //

  function fillWith(mapper, lenOrWhileTruthFun) {
    let result = [];

    let isWhileTruthFun =
      typeof lenOrWhileTruthFun === 'function'
        ? lenOrWhileTruthFun
        : (index) => index < lenOrWhileTruthFun;

    let index = -1;
    let isWhileTruth;
    do {
      index++;
      result[index] = mapper(index, result);
      isWhileTruth = isWhileTruthFun(index, result);
      if (!isWhileTruth) result.pop();
    } while (isWhileTruth)

    return result
  }
  // console.log(
  //   fillWith(
  //     (index) => index*2,
  //     (index, result) => result[index] < 12
  //   ) //?
  // )

  // console.log(
  //   fillWith(
  //     (index) => index*2,
  //     12
  //   ) //?
  // )



  // can be called with list of parameters or with array.
  //console.log(replaceAll('I like red cars and red houses', {from:'red',to:'yellow'},{from:'e',to:'E'}))
  //console.log(replaceAll('I like red cars and red houses', [{from:'red',to:'yellow'},{from:'e',to:'E'}]))
  function replaceAll(str, ...fromTo) {
    if (fromTo[0][0].from !== undefined) fromTo = fromTo[0];

    return fromTo.reduce(
      (acum, current) =>
        acum.split(current.from).join(current.to)
      , str
    )
  }

  function cleanString(str) {
    return str.replace(/([^a-z0-9 .,]+)/gi, '').replace(/  */g, ' ').trim()
  }
  //cleanString('  Only let%ters,%% numbers 1,2,3 d@ot &*&an(((d co[mma. Text is trimmed   ')  ===  
  //  'Only letters, numbers 1,2,3 dot and comma. Text is trimmed' //?

  function repeat$1(numberOfTimes) {
    let toReturn = [];
    function times(funToRepeat) {
      for (let index = 0; index < numberOfTimes; index++) {
        toReturn[index] = funToRepeat(index);
      }

      return toReturn
    }

    async function awaitTimes(funToRepeat) {
      for (let index = 0; index < numberOfTimes; index++) {
        toReturn[index] = await funToRepeat(index);
      }

      return toReturn
    }

    function value(value) {
      return Array(numberOfTimes).fill(value)
    }

    return { times, awaitTimes, value }
  }
  // repeat(8).times((index) => {
  //   console.log(index)
  // })

  // repeat(8).value(0) //?

  function runEvery(period) {

    let count = 0;

    function calls(runFunc) {

      function toExecute(...args) {
        count++;
        if (count === period) {
          count = 0;
          return runFunc(...args)
        }
      }

      toExecute.reset = () => count = 0;

      return toExecute
    }

    return { calls }
  }

  // let myRunEvery = runEvery(3).calls((txt1, txt2, txt3)=>{console.log(txt1, txt2, txt3);return 3})
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery.reset()
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery('jose','is great', '...') //?
  // myRunEvery('jose','is great', '...') //?



  function* loopIndexGenerator(initValue, iterations) {
    let count = 0;

    while (true) {
      yield initValue + count % iterations;
      count++;
    }
  }
  // let cycles = loopIndexGenerator(2, 3)
  // cycles.next() //?
  // cycles.next() //?
  // cycles.next() //?
  // cycles.next() //?
  // cycles.next() //?


  function processExit(error) {
    console.log(`Shutting down with error: ${error}`);
    try {
      process.exit(1);
    }catch(e)
    {
      console.log(e);
    }
  }

  const jsUtils = {
    logWithPrefix,
    firstCapital,
    varSubsDoubleBracket,
    queryObjToStr,
    CustomError,
    urlCompose,
    urlDecompose,
    indexOfNthMatch,
    colors,
    colorMessage,
    colorMessageByStatus,
    colorByStatus,
    findDeepKey,
    deepFreeze,
    getValueAtPath,
    setValueAtPath,
    sorterByPaths,
    filterFlatMap,
    arraySorter,
    isPromise,
    sleep,
    sleepWithValue,
    sleepWithFunction,
    notTo,
    arrayToObject,
    arrayOfObjectsToObject,
    removeDuplicates,
    traverse: traverse$1,
    copyPropsWithValue,
    copyPropsWithValueUsingRules,
    EnumMap,
    Enum,
    transition,
    pushUniqueKey,
    pushUniqueKeyOrChange,
    memoize,
    fillWith,
    isDate,
    isEmpty: isEmpty$1,
    isStringADate,
    formatDate,
    dateFormatter,
    YYYY_MM_DD_hh_mm_ss_ToUtcDate,
    dateToObj,
    diffInDaysYYYY_MM_DD,
    subtractDays,
    previousDayOfWeek,
    getSameDateOrPreviousFridayForWeekends,
    replaceAll,
    cleanString,
    repeat: repeat$1,
    runEvery,
    loopIndexGenerator,
    retryWithSleep,
    processExit
  };

  function reviverPromiseForCloneDeep(value) {
    if (jsUtils.isPromise(value)) return value
  }

  function cloneCopy(to, from, firstCleanTo, shallow) {


    if (firstCleanTo) {
      Object.setPrototypeOf(to, Object.getPrototypeOf(from));

      for (let prop in to) {
        if (to.hasOwnProperty(prop)) {
          delete to[prop];
        }
      }
    }


    if (shallow) {
      for (let prop in from) {
        if (from.hasOwnProperty(prop)) {
          to[prop] = from[prop];
        }
      }
    } else {
      for (let prop in from) {
        if (from.hasOwnProperty(prop)) {
          to[prop] = _.cloneDeepWith(from[prop], reviverPromiseForCloneDeep);
        }
      }
    }

    return to
  }

  function wildcardToRegExp(pathSearch, flagsString, separator = '.') {

    let escSeparator = escapeRegExp(separator);

    let result = pathSearch.split(separator).join(`${escSeparator}`);
    result = result.split('*').join(`[^${escSeparator}]*`);
    result = result.split(`[^${escSeparator}]*[^${escSeparator}]*`).join('.*');
    result = '^' + result + '$';
    let regExToReturn = new RegExp(result, flagsString);

    return regExToReturn
  }

  function escapeRegExp(string) {
    return string.replace(/[.*+\-?^${}()|[\]\\]/g, '\\$&'); // $& means the whole matched string
  }


  function promiseAll(obj) {
    let objRoot = { root: obj };

    let toReturn = promiseAllRec(objRoot);

    if (jsUtils.isPromise(toReturn) === false) {
      toReturn = Promise.resolve(toReturn);
    }

    return toReturn.then(objRoot => objRoot.root)

    function promiseAllRec(objRoot) {
      const arrayOfPromises = [];
      const arrayOfRefToPromises = [];

      jsUtils.traverse(objRoot, (ref, _undefined, parent, son) => {
        if (jsUtils.isPromise(ref)) {
          arrayOfPromises.push(ref);
          arrayOfRefToPromises.push({ parent, son });
        }
      }, false);

      if (arrayOfPromises.length > 0) {
        return Promise.all(arrayOfPromises)
          .then((arrayOfResolutions) => {
            arrayOfResolutions.map((resolution, index) => {
              arrayOfRefToPromises[index].parent[arrayOfRefToPromises[index].son] = resolution;
            });
            return promiseAllRec(objRoot)
          })
      } else return objRoot
    }

  }

  /**
   * A function that always returns `false`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.T
   * @example
   *
   *      R.F(); //=> false
   */
  var F$2 = function () {
    return false;
  };

  /**
   * A function that always returns `true`. Any passed in parameters are ignored.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig * -> Boolean
   * @param {*}
   * @return {Boolean}
   * @see R.F
   * @example
   *
   *      R.T(); //=> true
   */
  var T = function () {
    return true;
  };

  /**
   * A special placeholder value used to specify "gaps" within curried functions,
   * allowing partial application of any combination of arguments, regardless of
   * their positions.
   *
   * If `g` is a curried ternary function and `_` is `R.__`, the following are
   * equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2, _)(1, 3)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @name __
   * @constant
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @example
   *
   *      const greet = R.replace('{name}', R.__, 'Hello, {name}!');
   *      greet('Alice'); //=> 'Hello, Alice!'
   */
  var __ = {
    '@@functional/placeholder': true
  };

  function _isPlaceholder(a) {
    return a != null && typeof a === 'object' && a['@@functional/placeholder'] === true;
  }

  /**
   * Optimized internal one-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry1(fn) {
    return function f1(a) {
      if (arguments.length === 0 || _isPlaceholder(a)) {
        return f1;
      } else {
        return fn.apply(this, arguments);
      }
    };
  }

  /**
   * Optimized internal two-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry2(fn) {
    return function f2(a, b) {
      switch (arguments.length) {
        case 0:
          return f2;

        case 1:
          return _isPlaceholder(a) ? f2 : _curry1(function (_b) {
            return fn(a, _b);
          });

        default:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f2 : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b);
          }) : fn(a, b);
      }
    };
  }

  /**
   * Adds two values.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a
   * @param {Number} b
   * @return {Number}
   * @see R.subtract
   * @example
   *
   *      R.add(2, 3);       //=>  5
   *      R.add(7)(10);      //=> 17
   */

  var add =
  /*#__PURE__*/
  _curry2(function add(a, b) {
    return Number(a) + Number(b);
  });

  /**
   * Private `concat` function to merge two array-like objects.
   *
   * @private
   * @param {Array|Arguments} [set1=[]] An array-like object.
   * @param {Array|Arguments} [set2=[]] An array-like object.
   * @return {Array} A new, merged array.
   * @example
   *
   *      _concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   */
  function _concat(set1, set2) {
    set1 = set1 || [];
    set2 = set2 || [];
    var idx;
    var len1 = set1.length;
    var len2 = set2.length;
    var result = [];
    idx = 0;

    while (idx < len1) {
      result[result.length] = set1[idx];
      idx += 1;
    }

    idx = 0;

    while (idx < len2) {
      result[result.length] = set2[idx];
      idx += 1;
    }

    return result;
  }

  function _arity(n, fn) {
    /* eslint-disable no-unused-vars */
    switch (n) {
      case 0:
        return function () {
          return fn.apply(this, arguments);
        };

      case 1:
        return function (a0) {
          return fn.apply(this, arguments);
        };

      case 2:
        return function (a0, a1) {
          return fn.apply(this, arguments);
        };

      case 3:
        return function (a0, a1, a2) {
          return fn.apply(this, arguments);
        };

      case 4:
        return function (a0, a1, a2, a3) {
          return fn.apply(this, arguments);
        };

      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.apply(this, arguments);
        };

      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.apply(this, arguments);
        };

      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.apply(this, arguments);
        };

      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.apply(this, arguments);
        };

      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.apply(this, arguments);
        };

      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.apply(this, arguments);
        };

      default:
        throw new Error('First argument to _arity must be a non-negative integer no greater than ten');
    }
  }

  /**
   * Internal curryN function.
   *
   * @private
   * @category Function
   * @param {Number} length The arity of the curried function.
   * @param {Array} received An array of arguments received thus far.
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curryN(length, received, fn) {
    return function () {
      var combined = [];
      var argsIdx = 0;
      var left = length;
      var combinedIdx = 0;

      while (combinedIdx < received.length || argsIdx < arguments.length) {
        var result;

        if (combinedIdx < received.length && (!_isPlaceholder(received[combinedIdx]) || argsIdx >= arguments.length)) {
          result = received[combinedIdx];
        } else {
          result = arguments[argsIdx];
          argsIdx += 1;
        }

        combined[combinedIdx] = result;

        if (!_isPlaceholder(result)) {
          left -= 1;
        }

        combinedIdx += 1;
      }

      return left <= 0 ? fn.apply(this, combined) : _arity(left, _curryN(length, combined, fn));
    };
  }

  /**
   * Returns a curried equivalent of the provided function, with the specified
   * arity. The curried function has two unusual capabilities. First, its
   * arguments needn't be provided one at a time. If `g` is `R.curryN(3, f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.5.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curry
   * @example
   *
   *      const sumArgs = (...args) => R.sum(args);
   *
   *      const curriedAddFourNumbers = R.curryN(4, sumArgs);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */

  var curryN =
  /*#__PURE__*/
  _curry2(function curryN(length, fn) {
    if (length === 1) {
      return _curry1(fn);
    }

    return _arity(length, _curryN(length, [], fn));
  });

  /**
   * Creates a new list iteration function from an existing one by adding two new
   * parameters to its callback function: the current index, and the entire list.
   *
   * This would turn, for instance, [`R.map`](#map) function into one that
   * more closely resembles `Array.prototype.map`. Note that this will only work
   * for functions in which the iteration callback function is the first
   * parameter, and where the list is the last parameter. (This latter might be
   * unimportant if the list parameter is not used.)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Function
   * @category List
   * @sig (((a ...) -> b) ... -> [a] -> *) -> (((a ..., Int, [a]) -> b) ... -> [a] -> *)
   * @param {Function} fn A list iteration function that does not pass index or list to its callback
   * @return {Function} An altered list iteration function that passes (item, index, list) to its callback
   * @example
   *
   *      const mapIndexed = R.addIndex(R.map);
   *      mapIndexed((val, idx) => idx + '-' + val, ['f', 'o', 'o', 'b', 'a', 'r']);
   *      //=> ['0-f', '1-o', '2-o', '3-b', '4-a', '5-r']
   */

  var addIndex =
  /*#__PURE__*/
  _curry1(function addIndex(fn) {
    return curryN(fn.length, function () {
      var idx = 0;
      var origFn = arguments[0];
      var list = arguments[arguments.length - 1];
      var args = Array.prototype.slice.call(arguments, 0);

      args[0] = function () {
        var result = origFn.apply(this, _concat(arguments, [idx, list]));
        idx += 1;
        return result;
      };

      return fn.apply(this, args);
    });
  });

  /**
   * Optimized internal three-arity curry function.
   *
   * @private
   * @category Function
   * @param {Function} fn The function to curry.
   * @return {Function} The curried function.
   */

  function _curry3(fn) {
    return function f3(a, b, c) {
      switch (arguments.length) {
        case 0:
          return f3;

        case 1:
          return _isPlaceholder(a) ? f3 : _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          });

        case 2:
          return _isPlaceholder(a) && _isPlaceholder(b) ? f3 : _isPlaceholder(a) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _curry1(function (_c) {
            return fn(a, b, _c);
          });

        default:
          return _isPlaceholder(a) && _isPlaceholder(b) && _isPlaceholder(c) ? f3 : _isPlaceholder(a) && _isPlaceholder(b) ? _curry2(function (_a, _b) {
            return fn(_a, _b, c);
          }) : _isPlaceholder(a) && _isPlaceholder(c) ? _curry2(function (_a, _c) {
            return fn(_a, b, _c);
          }) : _isPlaceholder(b) && _isPlaceholder(c) ? _curry2(function (_b, _c) {
            return fn(a, _b, _c);
          }) : _isPlaceholder(a) ? _curry1(function (_a) {
            return fn(_a, b, c);
          }) : _isPlaceholder(b) ? _curry1(function (_b) {
            return fn(a, _b, c);
          }) : _isPlaceholder(c) ? _curry1(function (_c) {
            return fn(a, b, _c);
          }) : fn(a, b, c);
      }
    };
  }

  /**
   * Applies a function to the value at the given index of an array, returning a
   * new copy of the array with the element at the given index replaced with the
   * result of the function application.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig Number -> (a -> a) -> [a] -> [a]
   * @param {Number} idx The index.
   * @param {Function} fn The function to apply.
   * @param {Array|Arguments} list An array-like object whose value
   *        at the supplied index will be replaced.
   * @return {Array} A copy of the supplied array-like object with
   *         the element at index `idx` replaced with the value
   *         returned by applying `fn` to the existing element.
   * @see R.update
   * @example
   *
   *      R.adjust(1, R.toUpper, ['a', 'b', 'c', 'd']);      //=> ['a', 'B', 'c', 'd']
   *      R.adjust(-1, R.toUpper, ['a', 'b', 'c', 'd']);     //=> ['a', 'b', 'c', 'D']
   * @symb R.adjust(-1, f, [a, b]) = [a, f(b)]
   * @symb R.adjust(0, f, [a, b]) = [f(a), b]
   */

  var adjust =
  /*#__PURE__*/
  _curry3(function adjust(idx, fn, list) {
    var len = list.length;

    if (idx >= len || idx < -len) {
      return list;
    }

    var _idx = (len + idx) % len;

    var _list = _concat(list);

    _list[_idx] = fn(list[_idx]);
    return _list;
  });

  /**
   * Tests whether or not an object is an array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is an array, `false` otherwise.
   * @example
   *
   *      _isArray([]); //=> true
   *      _isArray(null); //=> false
   *      _isArray({}); //=> false
   */
  var _isArray = Array.isArray || function _isArray(val) {
    return val != null && val.length >= 0 && Object.prototype.toString.call(val) === '[object Array]';
  };

  function _isTransformer(obj) {
    return obj != null && typeof obj['@@transducer/step'] === 'function';
  }

  /**
   * Returns a function that dispatches with different strategies based on the
   * object in list position (last argument). If it is an array, executes [fn].
   * Otherwise, if it has a function with one of the given method names, it will
   * execute that function (functor case). Otherwise, if it is a transformer,
   * uses transducer created by [transducerCreator] to return a new transformer
   * (transducer case).
   * Otherwise, it will default to executing [fn].
   *
   * @private
   * @param {Array} methodNames properties to check for a custom implementation
   * @param {Function} transducerCreator transducer factory if object is transformer
   * @param {Function} fn default ramda implementation
   * @return {Function} A function that dispatches on object in list position
   */

  function _dispatchable(methodNames, transducerCreator, fn) {
    return function () {
      if (arguments.length === 0) {
        return fn();
      }

      var obj = arguments[arguments.length - 1];

      if (!_isArray(obj)) {
        var idx = 0;

        while (idx < methodNames.length) {
          if (typeof obj[methodNames[idx]] === 'function') {
            return obj[methodNames[idx]].apply(obj, Array.prototype.slice.call(arguments, 0, -1));
          }

          idx += 1;
        }

        if (_isTransformer(obj)) {
          var transducer = transducerCreator.apply(null, Array.prototype.slice.call(arguments, 0, -1));
          return transducer(obj);
        }
      }

      return fn.apply(this, arguments);
    };
  }

  function _reduced(x) {
    return x && x['@@transducer/reduced'] ? x : {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }

  var _xfBase = {
    init: function () {
      return this.xf['@@transducer/init']();
    },
    result: function (result) {
      return this.xf['@@transducer/result'](result);
    }
  };

  var XAll =
  /*#__PURE__*/
  function () {
    function XAll(f, xf) {
      this.xf = xf;
      this.f = f;
      this.all = true;
    }

    XAll.prototype['@@transducer/init'] = _xfBase.init;

    XAll.prototype['@@transducer/result'] = function (result) {
      if (this.all) {
        result = this.xf['@@transducer/step'](result, true);
      }

      return this.xf['@@transducer/result'](result);
    };

    XAll.prototype['@@transducer/step'] = function (result, input) {
      if (!this.f(input)) {
        this.all = false;
        result = _reduced(this.xf['@@transducer/step'](result, false));
      }

      return result;
    };

    return XAll;
  }();

  var _xall =
  /*#__PURE__*/
  _curry2(function _xall(f, xf) {
    return new XAll(f, xf);
  });

  /**
   * Returns `true` if all elements of the list match the predicate, `false` if
   * there are any that don't.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by every element, `false`
   *         otherwise.
   * @see R.any, R.none, R.transduce
   * @example
   *
   *      const equals3 = R.equals(3);
   *      R.all(equals3)([3, 3, 3, 3]); //=> true
   *      R.all(equals3)([3, 3, 1, 3]); //=> false
   */

  var all =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['all'], _xall, function all(fn, list) {
    var idx = 0;

    while (idx < list.length) {
      if (!fn(list[idx])) {
        return false;
      }

      idx += 1;
    }

    return true;
  }));

  /**
   * Returns the larger of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.maxBy, R.min
   * @example
   *
   *      R.max(789, 123); //=> 789
   *      R.max('a', 'b'); //=> 'b'
   */

  var max =
  /*#__PURE__*/
  _curry2(function max(a, b) {
    return b > a ? b : a;
  });

  function _map(fn, functor) {
    var idx = 0;
    var len = functor.length;
    var result = Array(len);

    while (idx < len) {
      result[idx] = fn(functor[idx]);
      idx += 1;
    }

    return result;
  }

  function _isString(x) {
    return Object.prototype.toString.call(x) === '[object String]';
  }

  /**
   * Tests whether or not an object is similar to an array.
   *
   * @private
   * @category Type
   * @category List
   * @sig * -> Boolean
   * @param {*} x The object to test.
   * @return {Boolean} `true` if `x` has a numeric length property and extreme indices defined; `false` otherwise.
   * @example
   *
   *      _isArrayLike([]); //=> true
   *      _isArrayLike(true); //=> false
   *      _isArrayLike({}); //=> false
   *      _isArrayLike({length: 10}); //=> false
   *      _isArrayLike({0: 'zero', 9: 'nine', length: 10}); //=> true
   *      _isArrayLike({nodeType: 1, length: 1}) // => false
   */

  var _isArrayLike =
  /*#__PURE__*/
  _curry1(function isArrayLike(x) {
    if (_isArray(x)) {
      return true;
    }

    if (!x) {
      return false;
    }

    if (typeof x !== 'object') {
      return false;
    }

    if (_isString(x)) {
      return false;
    }

    if (x.length === 0) {
      return true;
    }

    if (x.length > 0) {
      return x.hasOwnProperty(0) && x.hasOwnProperty(x.length - 1);
    }

    return false;
  });

  var XWrap =
  /*#__PURE__*/
  function () {
    function XWrap(fn) {
      this.f = fn;
    }

    XWrap.prototype['@@transducer/init'] = function () {
      throw new Error('init not implemented on XWrap');
    };

    XWrap.prototype['@@transducer/result'] = function (acc) {
      return acc;
    };

    XWrap.prototype['@@transducer/step'] = function (acc, x) {
      return this.f(acc, x);
    };

    return XWrap;
  }();

  function _xwrap(fn) {
    return new XWrap(fn);
  }

  /**
   * Creates a function that is bound to a context.
   * Note: `R.bind` does not provide the additional argument-binding capabilities of
   * [Function.prototype.bind](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/bind).
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Function
   * @category Object
   * @sig (* -> *) -> {*} -> (* -> *)
   * @param {Function} fn The function to bind to context
   * @param {Object} thisObj The context to bind `fn` to
   * @return {Function} A function that will execute in the context of `thisObj`.
   * @see R.partial
   * @example
   *
   *      const log = R.bind(console.log, console);
   *      R.pipe(R.assoc('a', 2), R.tap(log), R.assoc('a', 3))({a: 1}); //=> {a: 3}
   *      // logs {a: 2}
   * @symb R.bind(f, o)(a, b) = f.call(o, a, b)
   */

  var bind =
  /*#__PURE__*/
  _curry2(function bind(fn, thisObj) {
    return _arity(fn.length, function () {
      return fn.apply(thisObj, arguments);
    });
  });

  function _arrayReduce(xf, acc, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      acc = xf['@@transducer/step'](acc, list[idx]);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      idx += 1;
    }

    return xf['@@transducer/result'](acc);
  }

  function _iterableReduce(xf, acc, iter) {
    var step = iter.next();

    while (!step.done) {
      acc = xf['@@transducer/step'](acc, step.value);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      step = iter.next();
    }

    return xf['@@transducer/result'](acc);
  }

  function _methodReduce(xf, acc, obj, methodName) {
    return xf['@@transducer/result'](obj[methodName](bind(xf['@@transducer/step'], xf), acc));
  }

  var symIterator = typeof Symbol !== 'undefined' ? Symbol.iterator : '@@iterator';
  function _reduce(fn, acc, list) {
    if (typeof fn === 'function') {
      fn = _xwrap(fn);
    }

    if (_isArrayLike(list)) {
      return _arrayReduce(fn, acc, list);
    }

    if (typeof list['fantasy-land/reduce'] === 'function') {
      return _methodReduce(fn, acc, list, 'fantasy-land/reduce');
    }

    if (list[symIterator] != null) {
      return _iterableReduce(fn, acc, list[symIterator]());
    }

    if (typeof list.next === 'function') {
      return _iterableReduce(fn, acc, list);
    }

    if (typeof list.reduce === 'function') {
      return _methodReduce(fn, acc, list, 'reduce');
    }

    throw new TypeError('reduce: list must be array or iterable');
  }

  var XMap =
  /*#__PURE__*/
  function () {
    function XMap(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XMap.prototype['@@transducer/init'] = _xfBase.init;
    XMap.prototype['@@transducer/result'] = _xfBase.result;

    XMap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, this.f(input));
    };

    return XMap;
  }();

  var _xmap =
  /*#__PURE__*/
  _curry2(function _xmap(f, xf) {
    return new XMap(f, xf);
  });

  function _has(prop, obj) {
    return Object.prototype.hasOwnProperty.call(obj, prop);
  }

  var toString$1 = Object.prototype.toString;

  var _isArguments =
  /*#__PURE__*/
  function () {
    return toString$1.call(arguments) === '[object Arguments]' ? function _isArguments(x) {
      return toString$1.call(x) === '[object Arguments]';
    } : function _isArguments(x) {
      return _has('callee', x);
    };
  }();

  var hasEnumBug = !
  /*#__PURE__*/
  {
    toString: null
  }.propertyIsEnumerable('toString');
  var nonEnumerableProps = ['constructor', 'valueOf', 'isPrototypeOf', 'toString', 'propertyIsEnumerable', 'hasOwnProperty', 'toLocaleString']; // Safari bug

  var hasArgsEnumBug =
  /*#__PURE__*/
  function () {

    return arguments.propertyIsEnumerable('length');
  }();

  var contains = function contains(list, item) {
    var idx = 0;

    while (idx < list.length) {
      if (list[idx] === item) {
        return true;
      }

      idx += 1;
    }

    return false;
  };
  /**
   * Returns a list containing the names of all the enumerable own properties of
   * the supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own properties.
   * @see R.keysIn, R.values, R.toPairs
   * @example
   *
   *      R.keys({a: 1, b: 2, c: 3}); //=> ['a', 'b', 'c']
   */


  var keys = typeof Object.keys === 'function' && !hasArgsEnumBug ?
  /*#__PURE__*/
  _curry1(function keys(obj) {
    return Object(obj) !== obj ? [] : Object.keys(obj);
  }) :
  /*#__PURE__*/
  _curry1(function keys(obj) {
    if (Object(obj) !== obj) {
      return [];
    }

    var prop, nIdx;
    var ks = [];

    var checkArgsLength = hasArgsEnumBug && _isArguments(obj);

    for (prop in obj) {
      if (_has(prop, obj) && (!checkArgsLength || prop !== 'length')) {
        ks[ks.length] = prop;
      }
    }

    if (hasEnumBug) {
      nIdx = nonEnumerableProps.length - 1;

      while (nIdx >= 0) {
        prop = nonEnumerableProps[nIdx];

        if (_has(prop, obj) && !contains(ks, prop)) {
          ks[ks.length] = prop;
        }

        nIdx -= 1;
      }
    }

    return ks;
  });

  /**
   * Takes a function and
   * a [functor](https://github.com/fantasyland/fantasy-land#functor),
   * applies the function to each of the functor's values, and returns
   * a functor of the same shape.
   *
   * Ramda provides suitable `map` implementations for `Array` and `Object`,
   * so this function may be applied to `[1, 2, 3]` or `{x: 1, y: 2, z: 3}`.
   *
   * Dispatches to the `map` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * Also treats functions as functors and will compose them together.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => (a -> b) -> f a -> f b
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {Array} list The list to be iterated over.
   * @return {Array} The new list.
   * @see R.transduce, R.addIndex, R.pluck, R.project
   * @example
   *
   *      const double = x => x * 2;
   *
   *      R.map(double, [1, 2, 3]); //=> [2, 4, 6]
   *
   *      R.map(double, {x: 1, y: 2, z: 3}); //=> {x: 2, y: 4, z: 6}
   * @symb R.map(f, [a, b]) = [f(a), f(b)]
   * @symb R.map(f, { x: a, y: b }) = { x: f(a), y: f(b) }
   * @symb R.map(f, functor_o) = functor_o.map(f)
   */

  var map$1 =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/map', 'map'], _xmap, function map(fn, functor) {
    switch (Object.prototype.toString.call(functor)) {
      case '[object Function]':
        return curryN(functor.length, function () {
          return fn.call(this, functor.apply(this, arguments));
        });

      case '[object Object]':
        return _reduce(function (acc, key) {
          acc[key] = fn(functor[key]);
          return acc;
        }, {}, keys(functor));

      default:
        return _map(fn, functor);
    }
  }));

  /**
   * Determine if the passed argument is an integer.
   *
   * @private
   * @param {*} n
   * @category Type
   * @return {Boolean}
   */
  var _isInteger = Number.isInteger || function _isInteger(n) {
    return n << 0 === n;
  };

  /**
   * Returns the nth element of the given list or string. If n is negative the
   * element at index length + n is returned.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> a | Undefined
   * @sig Number -> String -> String
   * @param {Number} offset
   * @param {*} list
   * @return {*}
   * @example
   *
   *      const list = ['foo', 'bar', 'baz', 'quux'];
   *      R.nth(1, list); //=> 'bar'
   *      R.nth(-1, list); //=> 'quux'
   *      R.nth(-99, list); //=> undefined
   *
   *      R.nth(2, 'abc'); //=> 'c'
   *      R.nth(3, 'abc'); //=> ''
   * @symb R.nth(-1, [a, b, c]) = c
   * @symb R.nth(0, [a, b, c]) = a
   * @symb R.nth(1, [a, b, c]) = b
   */

  var nth =
  /*#__PURE__*/
  _curry2(function nth(offset, list) {
    var idx = offset < 0 ? list.length + offset : offset;
    return _isString(list) ? list.charAt(idx) : list[idx];
  });

  /**
   * Returns a function that when supplied an object returns the indicated
   * property of that object, if it exists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx -> {s: a} -> a | Undefined
   * @param {String|Number} p The property name or array index
   * @param {Object} obj The object to query
   * @return {*} The value at `obj.p`.
   * @see R.path, R.props, R.pluck, R.project, R.nth
   * @example
   *
   *      R.prop('x', {x: 100}); //=> 100
   *      R.prop('x', {}); //=> undefined
   *      R.prop(0, [100]); //=> 100
   *      R.compose(R.inc, R.prop('x'))({ x: 3 }) //=> 4
   */

  var prop =
  /*#__PURE__*/
  _curry2(function prop(p, obj) {
    if (obj == null) {
      return;
    }

    return _isInteger(p) ? nth(p, obj) : obj[p];
  });

  /**
   * Returns a new list by plucking the same named property off all objects in
   * the list supplied.
   *
   * `pluck` will work on
   * any [functor](https://github.com/fantasyland/fantasy-land#functor) in
   * addition to arrays, as it is equivalent to `R.map(R.prop(k), f)`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Functor f => k -> f {k: v} -> f v
   * @param {Number|String} key The key name to pluck off of each object.
   * @param {Array} f The array or functor to consider.
   * @return {Array} The list of values for the given key.
   * @see R.project, R.prop, R.props
   * @example
   *
   *      var getAges = R.pluck('age');
   *      getAges([{name: 'fred', age: 29}, {name: 'wilma', age: 27}]); //=> [29, 27]
   *
   *      R.pluck(0, [[1, 2], [3, 4]]);               //=> [1, 3]
   *      R.pluck('val', {a: {val: 3}, b: {val: 5}}); //=> {a: 3, b: 5}
   * @symb R.pluck('x', [{x: 1, y: 2}, {x: 3, y: 4}, {x: 5, y: 6}]) = [1, 3, 5]
   * @symb R.pluck(0, [[1, 2], [3, 4], [5, 6]]) = [1, 3, 5]
   */

  var pluck =
  /*#__PURE__*/
  _curry2(function pluck(p, list) {
    return map$1(prop(p), list);
  });

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to shortcut the iteration.
   *
   * The arguments' order of [`reduceRight`](#reduceRight)'s iterator function
   * is *(value, acc)*.
   *
   * Note: `R.reduce` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduce` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce#Description
   *
   * Dispatches to the `reduce` method of the third argument, if present. When
   * doing so, it is up to the user to handle the [`R.reduced`](#reduced)
   * shortcuting, as this is not implemented by `reduce`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduced, R.addIndex, R.reduceRight
   * @example
   *
   *      R.reduce(R.subtract, 0, [1, 2, 3, 4]) // => ((((0 - 1) - 2) - 3) - 4) = -10
   *      //          -               -10
   *      //         / \              / \
   *      //        -   4           -6   4
   *      //       / \              / \
   *      //      -   3   ==>     -3   3
   *      //     / \              / \
   *      //    -   2           -1   2
   *      //   / \              / \
   *      //  0   1            0   1
   *
   * @symb R.reduce(f, a, [b, c, d]) = f(f(f(a, b), c), d)
   */

  var reduce =
  /*#__PURE__*/
  _curry3(_reduce);

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if every one of the provided predicates is satisfied
   * by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.anyPass
   * @example
   *
   *      const isQueen = R.propEq('rank', 'Q');
   *      const isSpade = R.propEq('suit', '');
   *      const isQueenOfSpades = R.allPass([isQueen, isSpade]);
   *
   *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> false
   *      isQueenOfSpades({rank: 'Q', suit: ''}); //=> true
   */

  var allPass =
  /*#__PURE__*/
  _curry1(function allPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;

      while (idx < len) {
        if (!preds[idx].apply(this, arguments)) {
          return false;
        }

        idx += 1;
      }

      return true;
    });
  });

  /**
   * Returns a function that always returns the given value. Note that for
   * non-primitives the value returned is a reference to the original value.
   *
   * This function is known as `const`, `constant`, or `K` (for K combinator) in
   * other languages and libraries.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> (* -> a)
   * @param {*} val The value to wrap in a function
   * @return {Function} A Function :: * -> val.
   * @example
   *
   *      const t = R.always('Tee');
   *      t(); //=> 'Tee'
   */

  var always =
  /*#__PURE__*/
  _curry1(function always(val) {
    return function () {
      return val;
    };
  });

  /**
   * Returns the first argument if it is falsy, otherwise the second argument.
   * Acts as the boolean `and` statement if both inputs are `Boolean`s.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any}
   * @see R.both, R.or
   * @example
   *
   *      R.and(true, true); //=> true
   *      R.and(true, false); //=> false
   *      R.and(false, true); //=> false
   *      R.and(false, false); //=> false
   */

  var and$1 =
  /*#__PURE__*/
  _curry2(function and(a, b) {
    return a && b;
  });

  var XAny =
  /*#__PURE__*/
  function () {
    function XAny(f, xf) {
      this.xf = xf;
      this.f = f;
      this.any = false;
    }

    XAny.prototype['@@transducer/init'] = _xfBase.init;

    XAny.prototype['@@transducer/result'] = function (result) {
      if (!this.any) {
        result = this.xf['@@transducer/step'](result, false);
      }

      return this.xf['@@transducer/result'](result);
    };

    XAny.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.any = true;
        result = _reduced(this.xf['@@transducer/step'](result, true));
      }

      return result;
    };

    return XAny;
  }();

  var _xany =
  /*#__PURE__*/
  _curry2(function _xany(f, xf) {
    return new XAny(f, xf);
  });

  /**
   * Returns `true` if at least one of the elements of the list match the predicate,
   * `false` otherwise.
   *
   * Dispatches to the `any` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is satisfied by at least one element, `false`
   *         otherwise.
   * @see R.all, R.none, R.transduce
   * @example
   *
   *      const lessThan0 = R.flip(R.lt)(0);
   *      const lessThan2 = R.flip(R.lt)(2);
   *      R.any(lessThan0)([1, 2]); //=> false
   *      R.any(lessThan2)([1, 2]); //=> true
   */

  var any$1 =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['any'], _xany, function any(fn, list) {
    var idx = 0;

    while (idx < list.length) {
      if (fn(list[idx])) {
        return true;
      }

      idx += 1;
    }

    return false;
  }));

  /**
   * Takes a list of predicates and returns a predicate that returns true for a
   * given list of arguments if at least one of the provided predicates is
   * satisfied by those arguments.
   *
   * The function returned is a curried function whose arity matches that of the
   * highest-arity predicate.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Logic
   * @sig [(*... -> Boolean)] -> (*... -> Boolean)
   * @param {Array} predicates An array of predicates to check
   * @return {Function} The combined predicate
   * @see R.allPass
   * @example
   *
   *      const isClub = R.propEq('suit', '');
   *      const isSpade = R.propEq('suit', '');
   *      const isBlackCard = R.anyPass([isClub, isSpade]);
   *
   *      isBlackCard({rank: '10', suit: ''}); //=> true
   *      isBlackCard({rank: 'Q', suit: ''}); //=> true
   *      isBlackCard({rank: 'Q', suit: ''}); //=> false
   */

  var anyPass =
  /*#__PURE__*/
  _curry1(function anyPass(preds) {
    return curryN(reduce(max, 0, pluck('length', preds)), function () {
      var idx = 0;
      var len = preds.length;

      while (idx < len) {
        if (preds[idx].apply(this, arguments)) {
          return true;
        }

        idx += 1;
      }

      return false;
    });
  });

  /**
   * ap applies a list of functions to a list of values.
   *
   * Dispatches to the `ap` method of the second argument, if present. Also
   * treats curried functions as applicatives.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig [a -> b] -> [a] -> [b]
   * @sig Apply f => f (a -> b) -> f a -> f b
   * @sig (r -> a -> b) -> (r -> a) -> (r -> b)
   * @param {*} applyF
   * @param {*} applyX
   * @return {*}
   * @example
   *
   *      R.ap([R.multiply(2), R.add(3)], [1,2,3]); //=> [2, 4, 6, 4, 5, 6]
   *      R.ap([R.concat('tasty '), R.toUpper], ['pizza', 'salad']); //=> ["tasty pizza", "tasty salad", "PIZZA", "SALAD"]
   *
   *      // R.ap can also be used as S combinator
   *      // when only two functions are passed
   *      R.ap(R.concat, R.toUpper)('Ramda') //=> 'RamdaRAMDA'
   * @symb R.ap([f, g], [a, b]) = [f(a), f(b), g(a), g(b)]
   */

  var ap$1 =
  /*#__PURE__*/
  _curry2(function ap(applyF, applyX) {
    return typeof applyX['fantasy-land/ap'] === 'function' ? applyX['fantasy-land/ap'](applyF) : typeof applyF.ap === 'function' ? applyF.ap(applyX) : typeof applyF === 'function' ? function (x) {
      return applyF(x)(applyX(x));
    } : _reduce(function (acc, f) {
      return _concat(acc, map$1(f, applyX));
    }, [], applyF);
  });

  function _aperture(n, list) {
    var idx = 0;
    var limit = list.length - (n - 1);
    var acc = new Array(limit >= 0 ? limit : 0);

    while (idx < limit) {
      acc[idx] = Array.prototype.slice.call(list, idx, idx + n);
      idx += 1;
    }

    return acc;
  }

  var XAperture =
  /*#__PURE__*/
  function () {
    function XAperture(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }

    XAperture.prototype['@@transducer/init'] = _xfBase.init;

    XAperture.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };

    XAperture.prototype['@@transducer/step'] = function (result, input) {
      this.store(input);
      return this.full ? this.xf['@@transducer/step'](result, this.getCopy()) : result;
    };

    XAperture.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;

      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };

    XAperture.prototype.getCopy = function () {
      return _concat(Array.prototype.slice.call(this.acc, this.pos), Array.prototype.slice.call(this.acc, 0, this.pos));
    };

    return XAperture;
  }();

  var _xaperture =
  /*#__PURE__*/
  _curry2(function _xaperture(n, xf) {
    return new XAperture(n, xf);
  });

  /**
   * Returns a new list, composed of n-tuples of consecutive elements. If `n` is
   * greater than the length of the list, an empty list is returned.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @param {Number} n The size of the tuples to create
   * @param {Array} list The list to split into `n`-length tuples
   * @return {Array} The resulting list of `n`-length tuples
   * @see R.transduce
   * @example
   *
   *      R.aperture(2, [1, 2, 3, 4, 5]); //=> [[1, 2], [2, 3], [3, 4], [4, 5]]
   *      R.aperture(3, [1, 2, 3, 4, 5]); //=> [[1, 2, 3], [2, 3, 4], [3, 4, 5]]
   *      R.aperture(7, [1, 2, 3, 4, 5]); //=> []
   */

  var aperture =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xaperture, _aperture));

  /**
   * Returns a new list containing the contents of the given list, followed by
   * the given element.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The element to add to the end of the new list.
   * @param {Array} list The list of elements to add a new item to.
   *        list.
   * @return {Array} A new list containing the elements of the old list followed by `el`.
   * @see R.prepend
   * @example
   *
   *      R.append('tests', ['write', 'more']); //=> ['write', 'more', 'tests']
   *      R.append('tests', []); //=> ['tests']
   *      R.append(['tests'], ['write', 'more']); //=> ['write', 'more', ['tests']]
   */

  var append =
  /*#__PURE__*/
  _curry2(function append(el, list) {
    return _concat(list, [el]);
  });

  /**
   * Applies function `fn` to the argument list `args`. This is useful for
   * creating a fixed-arity function from a variadic function. `fn` should be a
   * bound function if context is significant.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> a) -> [*] -> a
   * @param {Function} fn The function which will be called with `args`
   * @param {Array} args The arguments to call `fn` with
   * @return {*} result The result, equivalent to `fn(...args)`
   * @see R.call, R.unapply
   * @example
   *
   *      const nums = [1, 2, 3, -99, 42, 6, 7];
   *      R.apply(Math.max, nums); //=> 42
   * @symb R.apply(f, [a, b, c]) = f(a, b, c)
   */

  var apply$1 =
  /*#__PURE__*/
  _curry2(function apply(fn, args) {
    return fn.apply(this, args);
  });

  /**
   * Returns a list of all the enumerable own properties of the supplied object.
   * Note that the order of the output array is not guaranteed across different
   * JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own properties.
   * @see R.valuesIn, R.keys, R.toPairs
   * @example
   *
   *      R.values({a: 1, b: 2, c: 3}); //=> [1, 2, 3]
   */

  var values =
  /*#__PURE__*/
  _curry1(function values(obj) {
    var props = keys(obj);
    var len = props.length;
    var vals = [];
    var idx = 0;

    while (idx < len) {
      vals[idx] = obj[props[idx]];
      idx += 1;
    }

    return vals;
  });

  // delegating calls to .map

  function mapValues(fn, obj) {
    return _isArray(obj) ? obj.map(fn) : keys(obj).reduce(function (acc, key) {
      acc[key] = fn(obj[key]);
      return acc;
    }, {});
  }
  /**
   * Given a spec object recursively mapping properties to functions, creates a
   * function producing an object of the same structure, by mapping each property
   * to the result of calling its associated function with the supplied arguments.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig {k: ((a, b, ..., m) -> v)} -> ((a, b, ..., m) -> {k: v})
   * @param {Object} spec an object recursively mapping properties to functions for
   *        producing the values for these properties.
   * @return {Function} A function that returns an object of the same structure
   * as `spec', with each property set to the value returned by calling its
   * associated function with the supplied arguments.
   * @see R.converge, R.juxt
   * @example
   *
   *      const getMetrics = R.applySpec({
   *        sum: R.add,
   *        nested: { mul: R.multiply }
   *      });
   *      getMetrics(2, 4); // => { sum: 6, nested: { mul: 8 } }
   * @symb R.applySpec({ x: f, y: { z: g } })(a, b) = { x: f(a, b), y: { z: g(a, b) } }
   */


  var applySpec =
  /*#__PURE__*/
  _curry1(function applySpec(spec) {
    spec = mapValues(function (v) {
      return typeof v == 'function' ? v : applySpec(v);
    }, spec);
    return curryN(reduce(max, 0, pluck('length', values(spec))), function () {
      var args = arguments;
      return mapValues(function (f) {
        return apply$1(f, args);
      }, spec);
    });
  });

  /**
   * Takes a value and applies a function to it.
   *
   * This function is also known as the `thrush` combinator.
   *
   * @func
   * @memberOf R
   * @since v0.25.0
   * @category Function
   * @sig a -> (a -> b) -> b
   * @param {*} x The value
   * @param {Function} f The function to apply
   * @return {*} The result of applying `f` to `x`
   * @example
   *
   *      const t42 = R.applyTo(42);
   *      t42(R.identity); //=> 42
   *      t42(R.add(1)); //=> 43
   */

  var applyTo =
  /*#__PURE__*/
  _curry2(function applyTo(x, f) {
    return f(x);
  });

  /**
   * Makes an ascending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) < fn(b), `1` if fn(b) < fn(a), otherwise `0`
   * @see R.descend
   * @example
   *
   *      const byAge = R.ascend(R.prop('age'));
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByYoungestFirst = R.sort(byAge, people);
   *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
   */

  var ascend =
  /*#__PURE__*/
  _curry3(function ascend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa < bb ? -1 : aa > bb ? 1 : 0;
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @private
   * @param {String|Number} prop The property name to set
   * @param {*} val The new value
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original except for the changed property.
   */

  function _assoc(prop, val, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[prop] = val;
      return arr;
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    result[prop] = val;
    return result;
  }

  /**
   * Checks if the input value is `null` or `undefined`.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Type
   * @sig * -> Boolean
   * @param {*} x The value to test.
   * @return {Boolean} `true` if `x` is `undefined` or `null`, otherwise `false`.
   * @example
   *
   *      R.isNil(null); //=> true
   *      R.isNil(undefined); //=> true
   *      R.isNil(0); //=> false
   *      R.isNil([]); //=> false
   */

  var isNil$1 =
  /*#__PURE__*/
  _curry1(function isNil(x) {
    return x == null;
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the nodes required
   * to create the given path, and placing the specific value at the tail end of
   * that path. Note that this copies and flattens prototype properties onto the
   * new object as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> a -> {a} -> {a}
   * @param {Array} path the path to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except along the specified path.
   * @see R.dissocPath
   * @example
   *
   *      R.assocPath(['a', 'b', 'c'], 42, {a: {b: {c: 0}}}); //=> {a: {b: {c: 42}}}
   *
   *      // Any missing or non-object keys in path will be overridden
   *      R.assocPath(['a', 'b', 'c'], 42, {a: 5}); //=> {a: {b: {c: 42}}}
   */

  var assocPath =
  /*#__PURE__*/
  _curry3(function assocPath(path, val, obj) {
    if (path.length === 0) {
      return val;
    }

    var idx = path[0];

    if (path.length > 1) {
      var nextObj = !isNil$1(obj) && _has(idx, obj) ? obj[idx] : _isInteger(path[1]) ? [] : {};
      val = assocPath(Array.prototype.slice.call(path, 1), val, nextObj);
    }

    return _assoc(idx, val, obj);
  });

  /**
   * Makes a shallow clone of an object, setting or overriding the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Idx = String | Int
   * @sig Idx -> a -> {k: v} -> {k: v}
   * @param {String|Number} prop The property name to set
   * @param {*} val The new value
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original except for the changed property.
   * @see R.dissoc, R.pick
   * @example
   *
   *      R.assoc('c', 3, {a: 1, b: 2}); //=> {a: 1, b: 2, c: 3}
   */

  var assoc =
  /*#__PURE__*/
  _curry3(function assoc(prop, val, obj) {
    return assocPath([prop], val, obj);
  });

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly `n` parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> (* -> a) -> (* -> a)
   * @param {Number} n The desired arity of the new function.
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity `n`.
   * @see R.binary, R.unary
   * @example
   *
   *      const takesTwoArgs = (a, b) => [a, b];
   *
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      const takesOneArg = R.nAry(1, takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only `n` arguments are passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.nAry(0, f)(a, b) = f()
   * @symb R.nAry(1, f)(a, b) = f(a)
   * @symb R.nAry(2, f)(a, b) = f(a, b)
   */

  var nAry =
  /*#__PURE__*/
  _curry2(function nAry(n, fn) {
    switch (n) {
      case 0:
        return function () {
          return fn.call(this);
        };

      case 1:
        return function (a0) {
          return fn.call(this, a0);
        };

      case 2:
        return function (a0, a1) {
          return fn.call(this, a0, a1);
        };

      case 3:
        return function (a0, a1, a2) {
          return fn.call(this, a0, a1, a2);
        };

      case 4:
        return function (a0, a1, a2, a3) {
          return fn.call(this, a0, a1, a2, a3);
        };

      case 5:
        return function (a0, a1, a2, a3, a4) {
          return fn.call(this, a0, a1, a2, a3, a4);
        };

      case 6:
        return function (a0, a1, a2, a3, a4, a5) {
          return fn.call(this, a0, a1, a2, a3, a4, a5);
        };

      case 7:
        return function (a0, a1, a2, a3, a4, a5, a6) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6);
        };

      case 8:
        return function (a0, a1, a2, a3, a4, a5, a6, a7) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7);
        };

      case 9:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8);
        };

      case 10:
        return function (a0, a1, a2, a3, a4, a5, a6, a7, a8, a9) {
          return fn.call(this, a0, a1, a2, a3, a4, a5, a6, a7, a8, a9);
        };

      default:
        throw new Error('First argument to nAry must be a non-negative integer no greater than ten');
    }
  });

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 2 parameters. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (a -> b -> c -> ... -> z) -> ((a, b) -> z)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 2.
   * @see R.nAry, R.unary
   * @example
   *
   *      const takesThreeArgs = function(a, b, c) {
   *        return [a, b, c];
   *      };
   *      takesThreeArgs.length; //=> 3
   *      takesThreeArgs(1, 2, 3); //=> [1, 2, 3]
   *
   *      const takesTwoArgs = R.binary(takesThreeArgs);
   *      takesTwoArgs.length; //=> 2
   *      // Only 2 arguments are passed to the wrapped function
   *      takesTwoArgs(1, 2, 3); //=> [1, 2, undefined]
   * @symb R.binary(f)(a, b, c) = f(a, b)
   */

  var binary =
  /*#__PURE__*/
  _curry1(function binary(fn) {
    return nAry(2, fn);
  });

  function _isFunction(x) {
    var type = Object.prototype.toString.call(x);
    return type === '[object Function]' || type === '[object AsyncFunction]' || type === '[object GeneratorFunction]' || type === '[object AsyncGeneratorFunction]';
  }

  /**
   * "lifts" a function to be the specified arity, so that it may "map over" that
   * many lists, Functions or other objects that satisfy the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig Number -> (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.lift, R.ap
   * @example
   *
   *      const madd3 = R.liftN(3, (...args) => R.sum(args));
   *      madd3([1,2,3], [1,2,3], [1]); //=> [3, 4, 5, 4, 5, 6, 5, 6, 7]
   */

  var liftN =
  /*#__PURE__*/
  _curry2(function liftN(arity, fn) {
    var lifted = curryN(arity, fn);
    return curryN(arity, function () {
      return _reduce(ap$1, map$1(lifted, arguments[0]), Array.prototype.slice.call(arguments, 1));
    });
  });

  /**
   * "lifts" a function of arity >= 1 so that it may "map over" a list, Function or other
   * object that satisfies the [FantasyLand Apply spec](https://github.com/fantasyland/fantasy-land#apply).
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Function
   * @sig (*... -> *) -> ([*]... -> [*])
   * @param {Function} fn The function to lift into higher context
   * @return {Function} The lifted function.
   * @see R.liftN
   * @example
   *
   *      const madd3 = R.lift((a, b, c) => a + b + c);
   *
   *      madd3([100, 200], [30, 40], [5, 6, 7]); //=> [135, 136, 137, 145, 146, 147, 235, 236, 237, 245, 246, 247]
   *
   *      const madd5 = R.lift((a, b, c, d, e) => a + b + c + d + e);
   *
   *      madd5([10, 20], [1], [2, 3], [4], [100, 200]); //=> [117, 217, 118, 218, 127, 227, 128, 228]
   */

  var lift =
  /*#__PURE__*/
  _curry1(function lift(fn) {
    return liftN(fn.length, fn);
  });

  /**
   * A function which calls the two provided functions and returns the `&&`
   * of the results.
   * It returns the result of the first function if it is false-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * false-y value.
   *
   * In addition to functions, `R.both` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f A predicate
   * @param {Function} g Another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `&&`s their outputs together.
   * @see R.either, R.and
   * @example
   *
   *      const gt10 = R.gt(R.__, 10)
   *      const lt20 = R.lt(R.__, 20)
   *      const f = R.both(gt10, lt20);
   *      f(15); //=> true
   *      f(30); //=> false
   *
   *      R.both(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(false)
   *      R.both([false, false, 'a'], [11]); //=> [false, false, 11]
   */

  var both$1 =
  /*#__PURE__*/
  _curry2(function both(f, g) {
    return _isFunction(f) ? function _both() {
      return f.apply(this, arguments) && g.apply(this, arguments);
    } : lift(and$1)(f, g);
  });

  /**
   * Returns the result of calling its first argument with the remaining
   * arguments. This is occasionally useful as a converging function for
   * [`R.converge`](#converge): the first branch can produce a function while the
   * remaining branches produce values to be passed to that function as its
   * arguments.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig ((*... -> a), *...) -> a
   * @param {Function} fn The function to apply to the remaining arguments.
   * @param {...*} args Any number of positional arguments.
   * @return {*}
   * @see R.apply
   * @example
   *
   *      R.call(R.add, 1, 2); //=> 3
   *
   *      const indentN = R.pipe(
   *        R.repeat(' '),
   *        R.join(''),
   *        R.replace(/^(?!$)/gm)
   *      );
   *
   *      const format = R.converge(
   *        R.call,
   *        [
   *          R.pipe(R.prop('indent'), indentN),
   *          R.prop('value')
   *        ]
   *      );
   *
   *      format({indent: 2, value: 'foo\nbar\nbaz\n'}); //=> '  foo\n  bar\n  baz\n'
   * @symb R.call(f, a, b) = f(a, b)
   */

  var call$1 =
  /*#__PURE__*/
  _curry1(function call(fn) {
    return fn.apply(this, Array.prototype.slice.call(arguments, 1));
  });

  /**
   * `_makeFlat` is a helper function that returns a one-level or fully recursive
   * function based on the flag passed in.
   *
   * @private
   */

  function _makeFlat(recursive) {
    return function flatt(list) {
      var value, jlen, j;
      var result = [];
      var idx = 0;
      var ilen = list.length;

      while (idx < ilen) {
        if (_isArrayLike(list[idx])) {
          value = recursive ? flatt(list[idx]) : list[idx];
          j = 0;
          jlen = value.length;

          while (j < jlen) {
            result[result.length] = value[j];
            j += 1;
          }
        } else {
          result[result.length] = list[idx];
        }

        idx += 1;
      }

      return result;
    };
  }

  function _forceReduced(x) {
    return {
      '@@transducer/value': x,
      '@@transducer/reduced': true
    };
  }

  var preservingReduced = function (xf) {
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function (result) {
        return xf['@@transducer/result'](result);
      },
      '@@transducer/step': function (result, input) {
        var ret = xf['@@transducer/step'](result, input);
        return ret['@@transducer/reduced'] ? _forceReduced(ret) : ret;
      }
    };
  };

  var _flatCat = function _xcat(xf) {
    var rxf = preservingReduced(xf);
    return {
      '@@transducer/init': _xfBase.init,
      '@@transducer/result': function (result) {
        return rxf['@@transducer/result'](result);
      },
      '@@transducer/step': function (result, input) {
        return !_isArrayLike(input) ? _reduce(rxf, result, [input]) : _reduce(rxf, result, input);
      }
    };
  };

  var _xchain =
  /*#__PURE__*/
  _curry2(function _xchain(f, xf) {
    return map$1(f, _flatCat(xf));
  });

  /**
   * `chain` maps a function over a list and concatenates the results. `chain`
   * is also known as `flatMap` in some libraries.
   *
   * Dispatches to the `chain` method of the second argument, if present,
   * according to the [FantasyLand Chain spec](https://github.com/fantasyland/fantasy-land#chain).
   *
   * If second argument is a function, `chain(f, g)(x)` is equivalent to `f(g(x), x)`.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain m => (a -> m b) -> m a -> m b
   * @param {Function} fn The function to map with
   * @param {Array} list The list to map over
   * @return {Array} The result of flat-mapping `list` with `fn`
   * @example
   *
   *      const duplicate = n => [n, n];
   *      R.chain(duplicate, [1, 2, 3]); //=> [1, 1, 2, 2, 3, 3]
   *
   *      R.chain(R.append, R.head)([1, 2, 3]); //=> [1, 2, 3, 1]
   */

  var chain$1 =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/chain', 'chain'], _xchain, function chain(fn, monad) {
    if (typeof monad === 'function') {
      return function (x) {
        return fn(monad(x))(x);
      };
    }

    return _makeFlat(false)(map$1(fn, monad));
  }));

  /**
   * Restricts a number to be within a range.
   *
   * Also works for other ordered types such as Strings and Dates.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Relation
   * @sig Ord a => a -> a -> a -> a
   * @param {Number} minimum The lower limit of the clamp (inclusive)
   * @param {Number} maximum The upper limit of the clamp (inclusive)
   * @param {Number} value Value to be clamped
   * @return {Number} Returns `minimum` when `val < minimum`, `maximum` when `val > maximum`, returns `val` otherwise
   * @example
   *
   *      R.clamp(1, 10, -5) // => 1
   *      R.clamp(1, 10, 15) // => 10
   *      R.clamp(1, 10, 4)  // => 4
   */

  var clamp =
  /*#__PURE__*/
  _curry3(function clamp(min, max, value) {
    if (min > max) {
      throw new Error('min must not be greater than max in clamp(min, max, value)');
    }

    return value < min ? min : value > max ? max : value;
  });

  function _cloneRegExp(pattern) {
    return new RegExp(pattern.source, (pattern.global ? 'g' : '') + (pattern.ignoreCase ? 'i' : '') + (pattern.multiline ? 'm' : '') + (pattern.sticky ? 'y' : '') + (pattern.unicode ? 'u' : ''));
  }

  /**
   * Gives a single-word string description of the (native) type of a value,
   * returning such answers as 'Object', 'Number', 'Array', or 'Null'. Does not
   * attempt to distinguish user Object types any further, reporting them all as
   * 'Object'.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Type
   * @sig (* -> {*}) -> String
   * @param {*} val The value to test
   * @return {String}
   * @example
   *
   *      R.type({}); //=> "Object"
   *      R.type(1); //=> "Number"
   *      R.type(false); //=> "Boolean"
   *      R.type('s'); //=> "String"
   *      R.type(null); //=> "Null"
   *      R.type([]); //=> "Array"
   *      R.type(/[A-z]/); //=> "RegExp"
   *      R.type(() => {}); //=> "Function"
   *      R.type(undefined); //=> "Undefined"
   */

  var type$1 =
  /*#__PURE__*/
  _curry1(function type(val) {
    return val === null ? 'Null' : val === undefined ? 'Undefined' : Object.prototype.toString.call(val).slice(8, -1);
  });

  /**
   * Copies an object.
   *
   * @private
   * @param {*} value The value to be copied
   * @param {Array} refFrom Array containing the source references
   * @param {Array} refTo Array containing the copied source references
   * @param {Boolean} deep Whether or not to perform deep cloning.
   * @return {*} The copied value.
   */

  function _clone(value, refFrom, refTo, deep) {
    var copy = function copy(copiedValue) {
      var len = refFrom.length;
      var idx = 0;

      while (idx < len) {
        if (value === refFrom[idx]) {
          return refTo[idx];
        }

        idx += 1;
      }

      refFrom[idx] = value;
      refTo[idx] = copiedValue;

      for (var key in value) {
        if (value.hasOwnProperty(key)) {
          copiedValue[key] = deep ? _clone(value[key], refFrom, refTo, true) : value[key];
        }
      }

      return copiedValue;
    };

    switch (type$1(value)) {
      case 'Object':
        return copy(Object.create(Object.getPrototypeOf(value)));

      case 'Array':
        return copy([]);

      case 'Date':
        return new Date(value.valueOf());

      case 'RegExp':
        return _cloneRegExp(value);

      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'BigInt64Array':
      case 'BigUint64Array':
        return value.slice();

      default:
        return value;
    }
  }

  /**
   * Creates a deep copy of the source that can be used in place of the source
   * object without retaining any references to it.
   * The source object may contain (nested) `Array`s and `Object`s,
   * `Number`s, `String`s, `Boolean`s and `Date`s.
   * `Function`s are assigned by reference rather than copied.
   *
   * Dispatches to a `clone` method if present.
   *
   * Note that if the source object has multiple nodes that share a reference,
   * the returned object will have the same structure, but the references will
   * be pointed to the location within the cloned value.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig {*} -> {*}
   * @param {*} value The object or array to clone
   * @return {*} A deeply cloned copy of `val`
   * @example
   *
   *      const objects = [{}, {}, {}];
   *      const objectsClone = R.clone(objects);
   *      objects === objectsClone; //=> false
   *      objects[0] === objectsClone[0]; //=> false
   */

  var clone$1 =
  /*#__PURE__*/
  _curry1(function clone(value) {
    return value != null && typeof value.clone === 'function' ? value.clone() : _clone(value, [], [], true);
  });

  /**
   * Splits a list into sub-lists, based on the result of calling a key-returning function on each element,
   * and grouping the results according to values returned.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> [[b]]
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} list The array to group
   * @return {Array}
   *    An array of arrays where each sub-array contains items for which
   *    the String-returning function has returned the same value.
   * @see R.groupBy, R.partition
   * @example
   *      R.collectBy(R.prop('type'), [
   *        {type: 'breakfast', item: ''},
   *        {type: 'lunch', item: ''},
   *        {type: 'dinner', item: ''},
   *        {type: 'breakfast', item: ''},
   *        {type: 'lunch', item: ''}
   *      ]);
   *
   *      // [ [ {type: 'breakfast', item: ''},
   *      //     {type: 'breakfast', item: ''} ],
   *      //   [ {type: 'lunch', item: ''},
   *      //     {type: 'lunch', item: ''} ],
   *      //   [ {type: 'dinner', item: ''} ] ]
   */

  var collectBy =
  /*#__PURE__*/
  _curry2(function collectBy(fn, list) {
    var group = _reduce(function (o, x) {
      var tag = fn(x);

      if (o[tag] === undefined) {
        o[tag] = [];
      }

      o[tag].push(x);
      return o;
    }, {}, list);

    var newList = [];

    for (var tag in group) {
      newList.push(group[tag]);
    }

    return newList;
  });

  /**
   * Makes a comparator function out of a function that reports whether the first
   * element is less than the second.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b) -> Boolean) -> ((a, b) -> Number)
   * @param {Function} pred A predicate function of arity two which will return `true` if the first argument
   * is less than the second, `false` otherwise
   * @return {Function} A Function :: a -> b -> Int that returns `-1` if a < b, `1` if b < a, otherwise `0`
   * @example
   *
   *      const byAge = R.comparator((a, b) => a.age < b.age);
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByIncreasingAge = R.sort(byAge, people);
   *        //=> [{ name: 'Mikhail', age: 62 },{ name: 'Emma', age: 70 }, { name: 'Peter', age: 78 }]
   */

  var comparator =
  /*#__PURE__*/
  _curry1(function comparator(pred) {
    return function (a, b) {
      return pred(a, b) ? -1 : pred(b, a) ? 1 : 0;
    };
  });

  /**
   * A function that returns the `!` of its argument. It will return `true` when
   * passed false-y value, and `false` when passed a truth-y one.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig * -> Boolean
   * @param {*} a any value
   * @return {Boolean} the logical inverse of passed argument.
   * @see R.complement
   * @example
   *
   *      R.not(true); //=> false
   *      R.not(false); //=> true
   *      R.not(0); //=> true
   *      R.not(1); //=> false
   */

  var not =
  /*#__PURE__*/
  _curry1(function not(a) {
    return !a;
  });

  /**
   * Takes a function `f` and returns a function `g` such that if called with the same arguments
   * when `f` returns a "truthy" value, `g` returns `false` and when `f` returns a "falsy" value `g` returns `true`.
   *
   * `R.complement` may be applied to any functor
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> *) -> (*... -> Boolean)
   * @param {Function} f
   * @return {Function}
   * @see R.not
   * @example
   *
   *      const isNotNil = R.complement(R.isNil);
   *      R.isNil(null); //=> true
   *      isNotNil(null); //=> false
   *      R.isNil(7); //=> false
   *      isNotNil(7); //=> true
   */

  var complement =
  /*#__PURE__*/
  lift(not);

  function _pipe(f, g) {
    return function () {
      return g.call(this, f.apply(this, arguments));
    };
  }

  /**
   * This checks whether a function has a [methodname] function. If it isn't an
   * array it will execute that function otherwise it will default to the ramda
   * implementation.
   *
   * @private
   * @param {Function} fn ramda implementation
   * @param {String} methodname property to check for a custom implementation
   * @return {Object} Whatever the return value of the method is.
   */

  function _checkForMethod(methodname, fn) {
    return function () {
      var length = arguments.length;

      if (length === 0) {
        return fn();
      }

      var obj = arguments[length - 1];
      return _isArray(obj) || typeof obj[methodname] !== 'function' ? fn.apply(this, arguments) : obj[methodname].apply(obj, Array.prototype.slice.call(arguments, 0, length - 1));
    };
  }

  /**
   * Returns the elements of the given list or string (or object with a `slice`
   * method) from `fromIndex` (inclusive) to `toIndex` (exclusive).
   *
   * Dispatches to the `slice` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @sig Number -> Number -> String -> String
   * @param {Number} fromIndex The start index (inclusive).
   * @param {Number} toIndex The end index (exclusive).
   * @param {*} list
   * @return {*}
   * @example
   *
   *      R.slice(1, 3, ['a', 'b', 'c', 'd']);        //=> ['b', 'c']
   *      R.slice(1, Infinity, ['a', 'b', 'c', 'd']); //=> ['b', 'c', 'd']
   *      R.slice(0, -1, ['a', 'b', 'c', 'd']);       //=> ['a', 'b', 'c']
   *      R.slice(-3, -1, ['a', 'b', 'c', 'd']);      //=> ['b', 'c']
   *      R.slice(0, 3, 'ramda');                     //=> 'ram'
   */

  var slice =
  /*#__PURE__*/
  _curry3(
  /*#__PURE__*/
  _checkForMethod('slice', function slice(fromIndex, toIndex, list) {
    return Array.prototype.slice.call(list, fromIndex, toIndex);
  }));

  /**
   * Returns all but the first element of the given list or string (or object
   * with a `tail` method).
   *
   * Dispatches to the `slice` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.head, R.init, R.last
   * @example
   *
   *      R.tail([1, 2, 3]);  //=> [2, 3]
   *      R.tail([1, 2]);     //=> [2]
   *      R.tail([1]);        //=> []
   *      R.tail([]);         //=> []
   *
   *      R.tail('abc');  //=> 'bc'
   *      R.tail('ab');   //=> 'b'
   *      R.tail('a');    //=> ''
   *      R.tail('');     //=> ''
   */

  var tail =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _checkForMethod('tail',
  /*#__PURE__*/
  slice(1, Infinity)));

  /**
   * Performs left-to-right function composition. The first argument may have
   * any arity; the remaining arguments must be unary.
   *
   * In some libraries this function is named `sequence`.
   *
   * **Note:** The result of pipe is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)) -> ((a, b, ..., n) -> z)
   * @param {...Function} functions
   * @return {Function}
   * @see R.compose
   * @example
   *
   *      const f = R.pipe(Math.pow, R.negate, R.inc);
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipe(f, g, h)(a, b) = h(g(f(a, b)))
   * @symb R.pipe(f, g, h)(a)(b) = h(g(f(a)))(b)
   */

  function pipe$1() {
    if (arguments.length === 0) {
      throw new Error('pipe requires at least one argument');
    }

    return _arity(arguments[0].length, reduce(_pipe, arguments[0], tail(arguments)));
  }

  /**
   * Returns a new list or string with the elements or characters in reverse
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {Array|String} list
   * @return {Array|String}
   * @example
   *
   *      R.reverse([1, 2, 3]);  //=> [3, 2, 1]
   *      R.reverse([1, 2]);     //=> [2, 1]
   *      R.reverse([1]);        //=> [1]
   *      R.reverse([]);         //=> []
   *
   *      R.reverse('abc');      //=> 'cba'
   *      R.reverse('ab');       //=> 'ba'
   *      R.reverse('a');        //=> 'a'
   *      R.reverse('');         //=> ''
   */

  var reverse$1 =
  /*#__PURE__*/
  _curry1(function reverse(list) {
    return _isString(list) ? list.split('').reverse().join('') : Array.prototype.slice.call(list, 0).reverse();
  });

  /**
   * Performs right-to-left function composition. The last argument may have
   * any arity; the remaining arguments must be unary.
   *
   * **Note:** The result of compose is not automatically curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)) -> ((a, b, ..., n) -> z)
   * @param {...Function} ...functions The functions to compose
   * @return {Function}
   * @see R.pipe
   * @example
   *
   *      const classyGreeting = (firstName, lastName) => "The name's " + lastName + ", " + firstName + " " + lastName
   *      const yellGreeting = R.compose(R.toUpper, classyGreeting);
   *      yellGreeting('James', 'Bond'); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.compose(Math.abs, R.add(1), R.multiply(2))(-4) //=> 7
   *
   * @symb R.compose(f, g, h)(a, b) = f(g(h(a, b)))
   * @symb R.compose(f, g, h)(a)(b) = f(g(h(a)))(b)
   */

  function compose() {
    if (arguments.length === 0) {
      throw new Error('compose requires at least one argument');
    }

    return pipe$1.apply(this, reverse$1(arguments));
  }

  /**
   * Returns the first element of the given list or string. In some libraries
   * this function is named `first`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {Array|String} list
   * @return {*}
   * @see R.tail, R.init, R.last
   * @example
   *
   *      R.head(['fi', 'fo', 'fum']); //=> 'fi'
   *      R.head([]); //=> undefined
   *
   *      R.head('abc'); //=> 'a'
   *      R.head(''); //=> ''
   */

  var head =
  /*#__PURE__*/
  nth(0);

  function _identity(x) {
    return x;
  }

  /**
   * A function that does nothing but return the parameter supplied to it. Good
   * as a default or placeholder function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig a -> a
   * @param {*} x The value to return.
   * @return {*} The input value, `x`.
   * @example
   *
   *      R.identity(1); //=> 1
   *
   *      const obj = {};
   *      R.identity(obj) === obj; //=> true
   * @symb R.identity(a) = a
   */

  var identity =
  /*#__PURE__*/
  _curry1(_identity);

  /**
   * Performs left-to-right function composition using transforming function. The first function may have
   * any arity; the remaining functions must be unary.
   *
   * **Note:** The result of pipeWith is not automatically curried. Transforming function is not used on the
   * first argument.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig ((* -> *), [((a, b, ..., n) -> o), (o -> p), ..., (x -> y), (y -> z)]) -> ((a, b, ..., n) -> z)
   * @param {Function} transformer The transforming function
   * @param {Array} functions The functions to pipe
   * @return {Function}
   * @see R.composeWith, R.pipe
   * @example
   *
   *      const pipeWhileNotNil = R.pipeWith((f, res) => R.isNil(res) ? res : f(res));
   *      const f = pipeWhileNotNil([Math.pow, R.negate, R.inc])
   *
   *      f(3, 4); // -(3^4) + 1
   * @symb R.pipeWith(f)([g, h, i])(...args) = f(i, f(h, g(...args)))
   */

  var pipeWith =
  /*#__PURE__*/
  _curry2(function pipeWith(xf, list) {
    if (list.length <= 0) {
      return identity;
    }

    var headList = head(list);
    var tailList = tail(list);
    return _arity(headList.length, function () {
      return _reduce(function (result, f) {
        return xf.call(this, f, result);
      }, headList.apply(this, arguments), tailList);
    });
  });

  /**
   * Performs right-to-left function composition using transforming function. The last function may have
   * any arity; the remaining functions must be unary.
   *
   * **Note:** The result of composeWith is not automatically curried. Transforming function is not used
   * on the last argument.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig ((* -> *), [(y -> z), (x -> y), ..., (o -> p), ((a, b, ..., n) -> o)]) -> ((a, b, ..., n) -> z)
   * @param {Function} transformer The transforming function
   * @param {Array} functions The functions to compose
   * @return {Function}
   * @see R.compose, R.pipeWith
   * @example
   *
   *      const composeWhileNotNil = R.composeWith((f, res) => R.isNil(res) ? res : f(res));
   *
   *      composeWhileNotNil([R.inc, R.prop('age')])({age: 1}) //=> 2
   *      composeWhileNotNil([R.inc, R.prop('age')])({}) //=> undefined
   *
   * @symb R.composeWith(f)([g, h, i])(...args) = f(g, f(h, i(...args)))
   */

  var composeWith =
  /*#__PURE__*/
  _curry2(function composeWith(xf, list) {
    return pipeWith.apply(this, [xf, reverse$1(list)]);
  });

  function _arrayFromIterator(iter) {
    var list = [];
    var next;

    while (!(next = iter.next()).done) {
      list.push(next.value);
    }

    return list;
  }

  function _includesWith(pred, x, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (pred(x, list[idx])) {
        return true;
      }

      idx += 1;
    }

    return false;
  }

  function _functionName(f) {
    // String(x => x) evaluates to "x => x", so the pattern may not match.
    var match = String(f).match(/^function (\w*)/);
    return match == null ? '' : match[1];
  }

  // Based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is
  function _objectIs(a, b) {
    // SameValue algorithm
    if (a === b) {
      // Steps 1-5, 7-10
      // Steps 6.b-6.e: +0 != -0
      return a !== 0 || 1 / a === 1 / b;
    } else {
      // Step 6.a: NaN == NaN
      return a !== a && b !== b;
    }
  }

  var _objectIs$1 = typeof Object.is === 'function' ? Object.is : _objectIs;

  /**
   * private _uniqContentEquals function.
   * That function is checking equality of 2 iterator contents with 2 assumptions
   * - iterators lengths are the same
   * - iterators values are unique
   *
   * false-positive result will be returned for comparison of, e.g.
   * - [1,2,3] and [1,2,3,4]
   * - [1,1,1] and [1,2,3]
   * */

  function _uniqContentEquals(aIterator, bIterator, stackA, stackB) {
    var a = _arrayFromIterator(aIterator);

    var b = _arrayFromIterator(bIterator);

    function eq(_a, _b) {
      return _equals(_a, _b, stackA.slice(), stackB.slice());
    } // if *a* array contains any element that is not included in *b*


    return !_includesWith(function (b, aItem) {
      return !_includesWith(eq, aItem, b);
    }, b, a);
  }

  function _equals(a, b, stackA, stackB) {
    if (_objectIs$1(a, b)) {
      return true;
    }

    var typeA = type$1(a);

    if (typeA !== type$1(b)) {
      return false;
    }

    if (typeof a['fantasy-land/equals'] === 'function' || typeof b['fantasy-land/equals'] === 'function') {
      return typeof a['fantasy-land/equals'] === 'function' && a['fantasy-land/equals'](b) && typeof b['fantasy-land/equals'] === 'function' && b['fantasy-land/equals'](a);
    }

    if (typeof a.equals === 'function' || typeof b.equals === 'function') {
      return typeof a.equals === 'function' && a.equals(b) && typeof b.equals === 'function' && b.equals(a);
    }

    switch (typeA) {
      case 'Arguments':
      case 'Array':
      case 'Object':
        if (typeof a.constructor === 'function' && _functionName(a.constructor) === 'Promise') {
          return a === b;
        }

        break;

      case 'Boolean':
      case 'Number':
      case 'String':
        if (!(typeof a === typeof b && _objectIs$1(a.valueOf(), b.valueOf()))) {
          return false;
        }

        break;

      case 'Date':
        if (!_objectIs$1(a.valueOf(), b.valueOf())) {
          return false;
        }

        break;

      case 'Error':
        return a.name === b.name && a.message === b.message;

      case 'RegExp':
        if (!(a.source === b.source && a.global === b.global && a.ignoreCase === b.ignoreCase && a.multiline === b.multiline && a.sticky === b.sticky && a.unicode === b.unicode)) {
          return false;
        }

        break;
    }

    var idx = stackA.length - 1;

    while (idx >= 0) {
      if (stackA[idx] === a) {
        return stackB[idx] === b;
      }

      idx -= 1;
    }

    switch (typeA) {
      case 'Map':
        if (a.size !== b.size) {
          return false;
        }

        return _uniqContentEquals(a.entries(), b.entries(), stackA.concat([a]), stackB.concat([b]));

      case 'Set':
        if (a.size !== b.size) {
          return false;
        }

        return _uniqContentEquals(a.values(), b.values(), stackA.concat([a]), stackB.concat([b]));

      case 'Arguments':
      case 'Array':
      case 'Object':
      case 'Boolean':
      case 'Number':
      case 'String':
      case 'Date':
      case 'Error':
      case 'RegExp':
      case 'Int8Array':
      case 'Uint8Array':
      case 'Uint8ClampedArray':
      case 'Int16Array':
      case 'Uint16Array':
      case 'Int32Array':
      case 'Uint32Array':
      case 'Float32Array':
      case 'Float64Array':
      case 'ArrayBuffer':
        break;

      default:
        // Values of other types are only equal if identical.
        return false;
    }

    var keysA = keys(a);

    if (keysA.length !== keys(b).length) {
      return false;
    }

    var extendedStackA = stackA.concat([a]);
    var extendedStackB = stackB.concat([b]);
    idx = keysA.length - 1;

    while (idx >= 0) {
      var key = keysA[idx];

      if (!(_has(key, b) && _equals(b[key], a[key], extendedStackA, extendedStackB))) {
        return false;
      }

      idx -= 1;
    }

    return true;
  }

  /**
   * Returns `true` if its arguments are equivalent, `false` otherwise. Handles
   * cyclical data structures.
   *
   * Dispatches symmetrically to the `equals` methods of both arguments, if
   * present.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> b -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      R.equals(1, 1); //=> true
   *      R.equals(1, '1'); //=> false
   *      R.equals([1, 2, 3], [1, 2, 3]); //=> true
   *
   *      const a = {}; a.v = a;
   *      const b = {}; b.v = b;
   *      R.equals(a, b); //=> true
   */

  var equals =
  /*#__PURE__*/
  _curry2(function equals(a, b) {
    return _equals(a, b, [], []);
  });

  function _indexOf(list, a, idx) {
    var inf, item; // Array.prototype.indexOf doesn't exist below IE9

    if (typeof list.indexOf === 'function') {
      switch (typeof a) {
        case 'number':
          if (a === 0) {
            // manually crawl the list to distinguish between +0 and -0
            inf = 1 / a;

            while (idx < list.length) {
              item = list[idx];

              if (item === 0 && 1 / item === inf) {
                return idx;
              }

              idx += 1;
            }

            return -1;
          } else if (a !== a) {
            // NaN
            while (idx < list.length) {
              item = list[idx];

              if (typeof item === 'number' && item !== item) {
                return idx;
              }

              idx += 1;
            }

            return -1;
          } // non-zero numbers can utilise Set


          return list.indexOf(a, idx);
        // all these types can utilise Set

        case 'string':
        case 'boolean':
        case 'function':
        case 'undefined':
          return list.indexOf(a, idx);

        case 'object':
          if (a === null) {
            // null can utilise Set
            return list.indexOf(a, idx);
          }

      }
    } // anything else not covered above, defer to R.equals


    while (idx < list.length) {
      if (equals(list[idx], a)) {
        return idx;
      }

      idx += 1;
    }

    return -1;
  }

  function _includes(a, list) {
    return _indexOf(list, a, 0) >= 0;
  }

  function _quote(s) {
    var escaped = s.replace(/\\/g, '\\\\').replace(/[\b]/g, '\\b') // \b matches word boundary; [\b] matches backspace
    .replace(/\f/g, '\\f').replace(/\n/g, '\\n').replace(/\r/g, '\\r').replace(/\t/g, '\\t').replace(/\v/g, '\\v').replace(/\0/g, '\\0');
    return '"' + escaped.replace(/"/g, '\\"') + '"';
  }

  /**
   * Polyfill from <https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Date/toISOString>.
   */
  var pad = function pad(n) {
    return (n < 10 ? '0' : '') + n;
  };

  var _toISOString = typeof Date.prototype.toISOString === 'function' ? function _toISOString(d) {
    return d.toISOString();
  } : function _toISOString(d) {
    return d.getUTCFullYear() + '-' + pad(d.getUTCMonth() + 1) + '-' + pad(d.getUTCDate()) + 'T' + pad(d.getUTCHours()) + ':' + pad(d.getUTCMinutes()) + ':' + pad(d.getUTCSeconds()) + '.' + (d.getUTCMilliseconds() / 1000).toFixed(3).slice(2, 5) + 'Z';
  };

  function _complement(f) {
    return function () {
      return !f.apply(this, arguments);
    };
  }

  function _filter(fn, list) {
    var idx = 0;
    var len = list.length;
    var result = [];

    while (idx < len) {
      if (fn(list[idx])) {
        result[result.length] = list[idx];
      }

      idx += 1;
    }

    return result;
  }

  function _isObject(x) {
    return Object.prototype.toString.call(x) === '[object Object]';
  }

  var XFilter =
  /*#__PURE__*/
  function () {
    function XFilter(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XFilter.prototype['@@transducer/init'] = _xfBase.init;
    XFilter.prototype['@@transducer/result'] = _xfBase.result;

    XFilter.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return XFilter;
  }();

  var _xfilter =
  /*#__PURE__*/
  _curry2(function _xfilter(f, xf) {
    return new XFilter(f, xf);
  });

  /**
   * Takes a predicate and a `Filterable`, and returns a new filterable of the
   * same type containing the members of the given filterable which satisfy the
   * given predicate. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * Dispatches to the `filter` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array} Filterable
   * @see R.reject, R.transduce, R.addIndex
   * @example
   *
   *      const isEven = n => n % 2 === 0;
   *
   *      R.filter(isEven, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.filter(isEven, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */

  var filter =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/filter', 'filter'], _xfilter, function (pred, filterable) {
    return _isObject(filterable) ? _reduce(function (acc, key) {
      if (pred(filterable[key])) {
        acc[key] = filterable[key];
      }

      return acc;
    }, {}, keys(filterable)) : // else
    _filter(pred, filterable);
  }));

  /**
   * The complement of [`filter`](#filter).
   *
   * Acts as a transducer if a transformer is given in list position. Filterable
   * objects include plain objects or any object that has a filter method such
   * as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> f a
   * @param {Function} pred
   * @param {Array} filterable
   * @return {Array}
   * @see R.filter, R.transduce, R.addIndex
   * @example
   *
   *      const isOdd = (n) => n % 2 !== 0;
   *
   *      R.reject(isOdd, [1, 2, 3, 4]); //=> [2, 4]
   *
   *      R.reject(isOdd, {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, d: 4}
   */

  var reject$1 =
  /*#__PURE__*/
  _curry2(function reject(pred, filterable) {
    return filter(_complement(pred), filterable);
  });

  function _toString(x, seen) {
    var recur = function recur(y) {
      var xs = seen.concat([x]);
      return _includes(y, xs) ? '<Circular>' : _toString(y, xs);
    }; //  mapPairs :: (Object, [String]) -> [String]


    var mapPairs = function (obj, keys) {
      return _map(function (k) {
        return _quote(k) + ': ' + recur(obj[k]);
      }, keys.slice().sort());
    };

    switch (Object.prototype.toString.call(x)) {
      case '[object Arguments]':
        return '(function() { return arguments; }(' + _map(recur, x).join(', ') + '))';

      case '[object Array]':
        return '[' + _map(recur, x).concat(mapPairs(x, reject$1(function (k) {
          return /^\d+$/.test(k);
        }, keys(x)))).join(', ') + ']';

      case '[object Boolean]':
        return typeof x === 'object' ? 'new Boolean(' + recur(x.valueOf()) + ')' : x.toString();

      case '[object Date]':
        return 'new Date(' + (isNaN(x.valueOf()) ? recur(NaN) : _quote(_toISOString(x))) + ')';

      case '[object Null]':
        return 'null';

      case '[object Number]':
        return typeof x === 'object' ? 'new Number(' + recur(x.valueOf()) + ')' : 1 / x === -Infinity ? '-0' : x.toString(10);

      case '[object String]':
        return typeof x === 'object' ? 'new String(' + recur(x.valueOf()) + ')' : _quote(x);

      case '[object Undefined]':
        return 'undefined';

      default:
        if (typeof x.toString === 'function') {
          var repr = x.toString();

          if (repr !== '[object Object]') {
            return repr;
          }
        }

        return '{' + mapPairs(x, keys(x)).join(', ') + '}';
    }
  }

  /**
   * Returns the string representation of the given value. `eval`'ing the output
   * should result in a value equivalent to the input value. Many of the built-in
   * `toString` methods do not satisfy this requirement.
   *
   * If the given value is an `[object Object]` with a `toString` method other
   * than `Object.prototype.toString`, this method is invoked with no arguments
   * to produce the return value. This means user-defined constructor functions
   * can provide a suitable `toString` method. For example:
   *
   *     function Point(x, y) {
   *       this.x = x;
   *       this.y = y;
   *     }
   *
   *     Point.prototype.toString = function() {
   *       return 'new Point(' + this.x + ', ' + this.y + ')';
   *     };
   *
   *     R.toString(new Point(1, 2)); //=> 'new Point(1, 2)'
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category String
   * @sig * -> String
   * @param {*} val
   * @return {String}
   * @example
   *
   *      R.toString(42); //=> '42'
   *      R.toString('abc'); //=> '"abc"'
   *      R.toString([1, 2, 3]); //=> '[1, 2, 3]'
   *      R.toString({foo: 1, bar: 2, baz: 3}); //=> '{"bar": 2, "baz": 3, "foo": 1}'
   *      R.toString(new Date('2001-02-03T04:05:06Z')); //=> 'new Date("2001-02-03T04:05:06.000Z")'
   */

  var toString =
  /*#__PURE__*/
  _curry1(function toString(val) {
    return _toString(val, []);
  });

  /**
   * Returns the result of concatenating the given lists or strings.
   *
   * Note: `R.concat` expects both arguments to be of the same type,
   * unlike the native `Array.prototype.concat` method. It will throw
   * an error if you `concat` an Array with a non-Array value.
   *
   * Dispatches to the `concat` method of the first argument, if present.
   * Can also concatenate two members of a [fantasy-land
   * compatible semigroup](https://github.com/fantasyland/fantasy-land#semigroup).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @sig String -> String -> String
   * @param {Array|String} firstList The first list
   * @param {Array|String} secondList The second list
   * @return {Array|String} A list consisting of the elements of `firstList` followed by the elements of
   * `secondList`.
   *
   * @example
   *
   *      R.concat('ABC', 'DEF'); // 'ABCDEF'
   *      R.concat([4, 5, 6], [1, 2, 3]); //=> [4, 5, 6, 1, 2, 3]
   *      R.concat([], []); //=> []
   */

  var concat =
  /*#__PURE__*/
  _curry2(function concat(a, b) {
    if (_isArray(a)) {
      if (_isArray(b)) {
        return a.concat(b);
      }

      throw new TypeError(toString(b) + ' is not an array');
    }

    if (_isString(a)) {
      if (_isString(b)) {
        return a + b;
      }

      throw new TypeError(toString(b) + ' is not a string');
    }

    if (a != null && _isFunction(a['fantasy-land/concat'])) {
      return a['fantasy-land/concat'](b);
    }

    if (a != null && _isFunction(a.concat)) {
      return a.concat(b);
    }

    throw new TypeError(toString(a) + ' does not have a method named "concat" or "fantasy-land/concat"');
  });

  /**
   * Returns a function, `fn`, which encapsulates `if/else, if/else, ...` logic.
   * `R.cond` takes a list of [predicate, transformer] pairs. All of the arguments
   * to `fn` are applied to each of the predicates in turn until one returns a
   * "truthy" value, at which point `fn` returns the result of applying its
   * arguments to the corresponding transformer. If none of the predicates
   * matches, `fn` returns undefined.
   *
   * **Please note**: This is not a direct substitute for a `switch` statement.
   * Remember that both elements of every pair passed to `cond` are *functions*,
   * and `cond` returns a function.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Logic
   * @sig [[(*... -> Boolean),(*... -> *)]] -> (*... -> *)
   * @param {Array} pairs A list of [predicate, transformer]
   * @return {Function}
   * @see R.ifElse, R.unless, R.when
   * @example
   *
   *      const fn = R.cond([
   *        [R.equals(0),   R.always('water freezes at 0C')],
   *        [R.equals(100), R.always('water boils at 100C')],
   *        [R.T,           temp => 'nothing special happens at ' + temp + 'C']
   *      ]);
   *      fn(0); //=> 'water freezes at 0C'
   *      fn(50); //=> 'nothing special happens at 50C'
   *      fn(100); //=> 'water boils at 100C'
   */

  var cond =
  /*#__PURE__*/
  _curry1(function cond(pairs) {
    var arity = reduce(max, 0, map$1(function (pair) {
      return pair[0].length;
    }, pairs));
    return _arity(arity, function () {
      var idx = 0;

      while (idx < pairs.length) {
        if (pairs[idx][0].apply(this, arguments)) {
          return pairs[idx][1].apply(this, arguments);
        }

        idx += 1;
      }
    });
  });

  /**
   * Returns a curried equivalent of the provided function. The curried function
   * has two unusual capabilities. First, its arguments needn't be provided one
   * at a time. If `f` is a ternary function and `g` is `R.curry(f)`, the
   * following are equivalent:
   *
   *   - `g(1)(2)(3)`
   *   - `g(1)(2, 3)`
   *   - `g(1, 2)(3)`
   *   - `g(1, 2, 3)`
   *
   * Secondly, the special placeholder value [`R.__`](#__) may be used to specify
   * "gaps", allowing partial application of any combination of arguments,
   * regardless of their positions. If `g` is as above and `_` is [`R.__`](#__),
   * the following are equivalent:
   *
   *   - `g(1, 2, 3)`
   *   - `g(_, 2, 3)(1)`
   *   - `g(_, _, 3)(1)(2)`
   *   - `g(_, _, 3)(1, 2)`
   *   - `g(_, 2)(1)(3)`
   *   - `g(_, 2)(1, 3)`
   *   - `g(_, 2)(_, 3)(1)`
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> a) -> (* -> a)
   * @param {Function} fn The function to curry.
   * @return {Function} A new, curried function.
   * @see R.curryN, R.partial
   * @example
   *
   *      const addFourNumbers = (a, b, c, d) => a + b + c + d;
   *
   *      const curriedAddFourNumbers = R.curry(addFourNumbers);
   *      const f = curriedAddFourNumbers(1, 2);
   *      const g = f(3);
   *      g(4); //=> 10
   */

  var curry =
  /*#__PURE__*/
  _curry1(function curry(fn) {
    return curryN(fn.length, fn);
  });

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type. The arity of the function
   * returned is specified to allow using variadic constructor functions.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Function
   * @sig Number -> (* -> {*}) -> (* -> {*})
   * @param {Number} n The arity of the constructor function.
   * @param {Function} Fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @example
   *
   *      // Variadic Constructor function
   *      function Salad() {
   *        this.ingredients = arguments;
   *      }
   *
   *      Salad.prototype.recipe = function() {
   *        const instructions = R.map(ingredient => 'Add a dollop of ' + ingredient, this.ingredients);
   *        return R.join('\n', instructions);
   *      };
   *
   *      const ThreeLayerSalad = R.constructN(3, Salad);
   *
   *      // Notice we no longer need the 'new' keyword, and the constructor is curried for 3 arguments.
   *      const salad = ThreeLayerSalad('Mayonnaise')('Potato Chips')('Ketchup');
   *
   *      console.log(salad.recipe());
   *      // Add a dollop of Mayonnaise
   *      // Add a dollop of Potato Chips
   *      // Add a dollop of Ketchup
   */

  var constructN =
  /*#__PURE__*/
  _curry2(function constructN(n, Fn) {
    if (n > 10) {
      throw new Error('Constructor with greater than ten arguments');
    }

    if (n === 0) {
      return function () {
        return new Fn();
      };
    }

    return curry(nAry(n, function ($0, $1, $2, $3, $4, $5, $6, $7, $8, $9) {
      switch (arguments.length) {
        case 1:
          return new Fn($0);

        case 2:
          return new Fn($0, $1);

        case 3:
          return new Fn($0, $1, $2);

        case 4:
          return new Fn($0, $1, $2, $3);

        case 5:
          return new Fn($0, $1, $2, $3, $4);

        case 6:
          return new Fn($0, $1, $2, $3, $4, $5);

        case 7:
          return new Fn($0, $1, $2, $3, $4, $5, $6);

        case 8:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7);

        case 9:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8);

        case 10:
          return new Fn($0, $1, $2, $3, $4, $5, $6, $7, $8, $9);
      }
    }));
  });

  /**
   * Wraps a constructor function inside a curried function that can be called
   * with the same arguments and returns the same type.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (* -> {*}) -> (* -> {*})
   * @param {Function} fn The constructor function to wrap.
   * @return {Function} A wrapped, curried constructor function.
   * @see R.invoker
   * @example
   *
   *      // Constructor function
   *      function Animal(kind) {
   *        this.kind = kind;
   *      };
   *      Animal.prototype.sighting = function() {
   *        return "It's a " + this.kind + "!";
   *      }
   *
   *      const AnimalConstructor = R.construct(Animal)
   *
   *      // Notice we no longer need the 'new' keyword:
   *      AnimalConstructor('Pig'); //=> {"kind": "Pig", "sighting": function (){...}};
   *
   *      const animalTypes = ["Lion", "Tiger", "Bear"];
   *      const animalSighting = R.invoker(0, 'sighting');
   *      const sightNewAnimal = R.compose(animalSighting, AnimalConstructor);
   *      R.map(sightNewAnimal, animalTypes); //=> ["It's a Lion!", "It's a Tiger!", "It's a Bear!"]
   */

  var construct =
  /*#__PURE__*/
  _curry1(function construct(Fn) {
    return constructN(Fn.length, Fn);
  });

  /**
   * Accepts a converging function and a list of branching functions and returns
   * a new function. The arity of the new function is the same as the arity of
   * the longest branching function. When invoked, this new function is applied
   * to some arguments, and each branching function is applied to those same
   * arguments. The results of each branching function are passed as arguments
   * to the converging function to produce the return value.
   *
   * @func
   * @memberOf R
   * @since v0.4.2
   * @category Function
   * @sig ((x1, x2, ...) -> z) -> [((a, b, ...) -> x1), ((a, b, ...) -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} after A function. `after` will be invoked with the return values of
   *        `fn1` and `fn2` as its arguments.
   * @param {Array} functions A list of functions.
   * @return {Function} A new function.
   * @see R.useWith
   * @example
   *
   *      const average = R.converge(R.divide, [R.sum, R.length])
   *      average([1, 2, 3, 4, 5, 6, 7]) //=> 4
   *
   *      const strangeConcat = R.converge(R.concat, [R.toUpper, R.toLower])
   *      strangeConcat("Yodel") //=> "YODELyodel"
   *
   * @symb R.converge(f, [g, h])(a, b) = f(g(a, b), h(a, b))
   */

  var converge =
  /*#__PURE__*/
  _curry2(function converge(after, fns) {
    return curryN(reduce(max, 0, pluck('length', fns)), function () {
      var args = arguments;
      var context = this;
      return after.apply(context, _map(function (fn) {
        return fn.apply(context, args);
      }, fns));
    });
  });

  /**
   * Returns the number of items in a given `list` matching the predicate `f`
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} predicate to match items against
   * @return {Array} list of items to count in
   * @example
   *
   *      const even = x => x % 2 == 0;
   *
   *      R.count(even, [1, 2, 3, 4, 5]); // => 2
   *      R.map(R.count(even), [[1, 1, 1], [2, 3, 4, 5], [6]]); // => [0, 2, 1]
   */

  var count =
  /*#__PURE__*/
  curry(function (pred, list) {
    return _reduce(function (a, e) {
      return pred(e) ? a + 1 : a;
    }, 0, list);
  });

  var XReduceBy =
  /*#__PURE__*/
  function () {
    function XReduceBy(valueFn, valueAcc, keyFn, xf) {
      this.valueFn = valueFn;
      this.valueAcc = valueAcc;
      this.keyFn = keyFn;
      this.xf = xf;
      this.inputs = {};
    }

    XReduceBy.prototype['@@transducer/init'] = _xfBase.init;

    XReduceBy.prototype['@@transducer/result'] = function (result) {
      var key;

      for (key in this.inputs) {
        if (_has(key, this.inputs)) {
          result = this.xf['@@transducer/step'](result, this.inputs[key]);

          if (result['@@transducer/reduced']) {
            result = result['@@transducer/value'];
            break;
          }
        }
      }

      this.inputs = null;
      return this.xf['@@transducer/result'](result);
    };

    XReduceBy.prototype['@@transducer/step'] = function (result, input) {
      var key = this.keyFn(input);
      this.inputs[key] = this.inputs[key] || [key, this.valueAcc];
      this.inputs[key][1] = this.valueFn(this.inputs[key][1], input);
      return result;
    };

    return XReduceBy;
  }();

  var _xreduceBy =
  /*#__PURE__*/
  _curryN(4, [], function _xreduceBy(valueFn, valueAcc, keyFn, xf) {
    return new XReduceBy(valueFn, valueAcc, keyFn, xf);
  });

  /**
   * Groups the elements of the list according to the result of calling
   * the String-returning function `keyFn` on each element and reduces the elements
   * of each group to a single value via the reducer function `valueFn`.
   *
   * The value function receives two values: *(acc, value)*. It may use
   * [`R.reduced`](#reduced) to short circuit the iteration.
   *
   * This function is basically a more general [`groupBy`](#groupBy) function.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category List
   * @sig ((a, b) -> a) -> a -> (b -> String) -> [b] -> {String: a}
   * @param {Function} valueFn The function that reduces the elements of each group to a single
   *        value. Receives two values, accumulator for a particular group and the current element.
   * @param {*} acc The (initial) accumulator value for each group.
   * @param {Function} keyFn The function that maps the list's element into a key.
   * @param {Array} list The array to group.
   * @return {Object} An object with the output of `keyFn` for keys, mapped to the output of
   *         `valueFn` for elements which produced that key when passed to `keyFn`.
   * @see R.groupBy, R.reduce, R.reduced
   * @example
   *
   *      const groupNames = (acc, {name}) => acc.concat(name)
   *      const toGrade = ({score}) =>
   *        score < 65 ? 'F' :
   *        score < 70 ? 'D' :
   *        score < 80 ? 'C' :
   *        score < 90 ? 'B' : 'A'
   *
   *      var students = [
   *        {name: 'Abby', score: 83},
   *        {name: 'Bart', score: 62},
   *        {name: 'Curt', score: 88},
   *        {name: 'Dora', score: 92},
   *      ]
   *
   *      reduceBy(groupNames, [], toGrade, students)
   *      //=> {"A": ["Dora"], "B": ["Abby", "Curt"], "F": ["Bart"]}
   */

  var reduceBy =
  /*#__PURE__*/
  _curryN(4, [],
  /*#__PURE__*/
  _dispatchable([], _xreduceBy, function reduceBy(valueFn, valueAcc, keyFn, list) {
    return _reduce(function (acc, elt) {
      var key = keyFn(elt);
      var value = valueFn(_has(key, acc) ? acc[key] : _clone(valueAcc, [], [], false), elt);

      if (value && value['@@transducer/reduced']) {
        return _reduced(acc);
      }

      acc[key] = value;
      return acc;
    }, {}, list);
  }));

  /**
   * Counts the elements of a list according to how many match each value of a
   * key generated by the supplied function. Returns an object mapping the keys
   * produced by `fn` to the number of occurrences in the list. Note that all
   * keys are coerced to strings because of how JavaScript objects work.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig (a -> String) -> [a] -> {*}
   * @param {Function} fn The function used to map values to keys.
   * @param {Array} list The list to count elements from.
   * @return {Object} An object mapping keys to number of occurrences in the list.
   * @example
   *
   *      const numbers = [1.0, 1.1, 1.2, 2.0, 3.0, 2.2];
   *      R.countBy(Math.floor)(numbers);    //=> {'1': 3, '2': 2, '3': 1}
   *
   *      const letters = ['a', 'b', 'A', 'a', 'B', 'c'];
   *      R.countBy(R.toLower)(letters);   //=> {'a': 3, 'b': 2, 'c': 1}
   */

  var countBy =
  /*#__PURE__*/
  reduceBy(function (acc, elem) {
    return acc + 1;
  }, 0);

  /**
   * Decrements its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n - 1
   * @see R.inc
   * @example
   *
   *      R.dec(42); //=> 41
   */

  var dec =
  /*#__PURE__*/
  add(-1);

  /**
   * Returns the second argument if it is not `null`, `undefined` or `NaN`;
   * otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {a} default The default value.
   * @param {b} val `val` will be returned instead of `default` unless `val` is `null`, `undefined` or `NaN`.
   * @return {*} The second value if it is not `null`, `undefined` or `NaN`, otherwise the default value
   * @example
   *
   *      const defaultTo42 = R.defaultTo(42);
   *
   *      defaultTo42(null);  //=> 42
   *      defaultTo42(undefined);  //=> 42
   *      defaultTo42(false);  //=> false
   *      defaultTo42('Ramda');  //=> 'Ramda'
   *      // parseInt('string') results in NaN
   *      defaultTo42(parseInt('string')); //=> 42
   */

  var defaultTo =
  /*#__PURE__*/
  _curry2(function defaultTo(d, v) {
    return v == null || v !== v ? d : v;
  });

  /**
   * Makes a descending comparator function out of a function that returns a value
   * that can be compared with `<` and `>`.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Function
   * @sig Ord b => (a -> b) -> a -> a -> Number
   * @param {Function} fn A function of arity one that returns a value that can be compared
   * @param {*} a The first item to be compared.
   * @param {*} b The second item to be compared.
   * @return {Number} `-1` if fn(a) > fn(b), `1` if fn(b) > fn(a), otherwise `0`
   * @see R.ascend
   * @example
   *
   *      const byAge = R.descend(R.prop('age'));
   *      const people = [
   *        { name: 'Emma', age: 70 },
   *        { name: 'Peter', age: 78 },
   *        { name: 'Mikhail', age: 62 },
   *      ];
   *      const peopleByOldestFirst = R.sort(byAge, people);
   *        //=> [{ name: 'Peter', age: 78 }, { name: 'Emma', age: 70 }, { name: 'Mikhail', age: 62 }]
   */

  var descend =
  /*#__PURE__*/
  _curry3(function descend(fn, a, b) {
    var aa = fn(a);
    var bb = fn(b);
    return aa > bb ? -1 : aa < bb ? 1 : 0;
  });

  var _Set =
  /*#__PURE__*/
  function () {
    function _Set() {
      /* globals Set */
      this._nativeSet = typeof Set === 'function' ? new Set() : null;
      this._items = {};
    }

    // until we figure out why jsdoc chokes on this
    // @param item The item to add to the Set
    // @returns {boolean} true if the item did not exist prior, otherwise false
    //
    _Set.prototype.add = function (item) {
      return !hasOrAdd(item, true, this);
    }; //
    // @param item The item to check for existence in the Set
    // @returns {boolean} true if the item exists in the Set, otherwise false
    //


    _Set.prototype.has = function (item) {
      return hasOrAdd(item, false, this);
    }; //
    // Combines the logic for checking whether an item is a member of the set and
    // for adding a new item to the set.
    //
    // @param item       The item to check or add to the Set instance.
    // @param shouldAdd  If true, the item will be added to the set if it doesn't
    //                   already exist.
    // @param set        The set instance to check or add to.
    // @return {boolean} true if the item already existed, otherwise false.
    //


    return _Set;
  }();

  function hasOrAdd(item, shouldAdd, set) {
    var type = typeof item;
    var prevSize, newSize;

    switch (type) {
      case 'string':
      case 'number':
        // distinguish between +0 and -0
        if (item === 0 && 1 / item === -Infinity) {
          if (set._items['-0']) {
            return true;
          } else {
            if (shouldAdd) {
              set._items['-0'] = true;
            }

            return false;
          }
        } // these types can all utilise the native Set


        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;

            set._nativeSet.add(item);

            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = {};
              set._items[type][item] = true;
            }

            return false;
          } else if (item in set._items[type]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][item] = true;
            }

            return false;
          }
        }

      case 'boolean':
        // set._items['boolean'] holds a two element array
        // representing [ falseExists, trueExists ]
        if (type in set._items) {
          var bIdx = item ? 1 : 0;

          if (set._items[type][bIdx]) {
            return true;
          } else {
            if (shouldAdd) {
              set._items[type][bIdx] = true;
            }

            return false;
          }
        } else {
          if (shouldAdd) {
            set._items[type] = item ? [false, true] : [true, false];
          }

          return false;
        }

      case 'function':
        // compare functions for reference equality
        if (set._nativeSet !== null) {
          if (shouldAdd) {
            prevSize = set._nativeSet.size;

            set._nativeSet.add(item);

            newSize = set._nativeSet.size;
            return newSize === prevSize;
          } else {
            return set._nativeSet.has(item);
          }
        } else {
          if (!(type in set._items)) {
            if (shouldAdd) {
              set._items[type] = [item];
            }

            return false;
          }

          if (!_includes(item, set._items[type])) {
            if (shouldAdd) {
              set._items[type].push(item);
            }

            return false;
          }

          return true;
        }

      case 'undefined':
        if (set._items[type]) {
          return true;
        } else {
          if (shouldAdd) {
            set._items[type] = true;
          }

          return false;
        }

      case 'object':
        if (item === null) {
          if (!set._items['null']) {
            if (shouldAdd) {
              set._items['null'] = true;
            }

            return false;
          }

          return true;
        }

      /* falls through */

      default:
        // reduce the search size of heterogeneous sets by creating buckets
        // for each type.
        type = Object.prototype.toString.call(item);

        if (!(type in set._items)) {
          if (shouldAdd) {
            set._items[type] = [item];
          }

          return false;
        } // scan through all previously applied items


        if (!_includes(item, set._items[type])) {
          if (shouldAdd) {
            set._items[type].push(item);
          }

          return false;
        }

        return true;
    }
  } // A simple Set type that honours R.equals semantics

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Objects and Arrays are compared in terms of
   * value equality, not reference equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.differenceWith, R.symmetricDifference, R.symmetricDifferenceWith, R.without
   * @example
   *
   *      R.difference([1,2,3,4], [7,6,5,4,3]); //=> [1,2]
   *      R.difference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5]
   *      R.difference([{a: 1}, {b: 2}], [{a: 1}, {c: 3}]) //=> [{b: 2}]
   */

  var difference =
  /*#__PURE__*/
  _curry2(function difference(first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;
    var secondLen = second.length;
    var toFilterOut = new _Set();

    for (var i = 0; i < secondLen; i += 1) {
      toFilterOut.add(second[i]);
    }

    while (idx < firstLen) {
      if (toFilterOut.add(first[idx])) {
        out[out.length] = first[idx];
      }

      idx += 1;
    }

    return out;
  });

  /**
   * Finds the set (i.e. no duplicates) of all elements in the first list not
   * contained in the second list. Duplication is determined according to the
   * value returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` that are not in `list2`.
   * @see R.difference, R.symmetricDifference, R.symmetricDifferenceWith
   * @example
   *
   *      const cmp = (x, y) => x.a === y.a;
   *      const l1 = [{a: 1}, {a: 2}, {a: 3}];
   *      const l2 = [{a: 3}, {a: 4}];
   *      R.differenceWith(cmp, l1, l2); //=> [{a: 1}, {a: 2}]
   */

  var differenceWith =
  /*#__PURE__*/
  _curry3(function differenceWith(pred, first, second) {
    var out = [];
    var idx = 0;
    var firstLen = first.length;

    while (idx < firstLen) {
      if (!_includesWith(pred, first[idx], second) && !_includesWith(pred, first[idx], out)) {
        out.push(first[idx]);
      }

      idx += 1;
    }

    return out;
  });

  /**
   * Removes the sub-list of `list` starting at index `start` and containing
   * `count` elements. _Note that this is not destructive_: it returns a copy of
   * the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} start The position to start removing elements
   * @param {Number} count The number of elements to remove
   * @param {Array} list The list to remove from
   * @return {Array} A new Array with `count` elements from `start` removed.
   * @see R.without
   * @example
   *
   *      R.remove(2, 3, [1,2,3,4,5,6,7,8]); //=> [1,2,6,7,8]
   */

  var remove =
  /*#__PURE__*/
  _curry3(function remove(start, count, list) {
    var result = Array.prototype.slice.call(list, 0);
    result.splice(start, count);
    return result;
  });

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @private
   * @param {String|Number} prop The name of the property to dissociate
   * @param {Object|Array} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   */

  function _dissoc(prop, obj) {
    if (obj == null) {
      return obj;
    }

    if (_isInteger(prop) && _isArray(obj)) {
      return remove(prop, 1, obj);
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    delete result[prop];
    return result;
  }

  /**
   * Makes a shallow clone of an object. Note that this copies and flattens
   * prototype properties onto the new object as well. All non-primitive
   * properties are copied by reference.
   *
   * @private
   * @param {String|Integer} prop The prop operating
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original.
   */

  function _shallowCloneObject(prop, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      return [].concat(obj);
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    return result;
  }
  /**
   * Makes a shallow clone of an object, omitting the property at the given path.
   * Note that this copies and flattens prototype properties onto the new object
   * as well. All non-primitive properties are copied by reference.
   *
   * @func
   * @memberOf R
   * @since v0.11.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {k: v} -> {k: v}
   * @param {Array} path The path to the value to omit
   * @param {Object} obj The object to clone
   * @return {Object} A new object without the property at path
   * @see R.assocPath
   * @example
   *
   *      R.dissocPath(['a', 'b', 'c'], {a: {b: {c: 42}}}); //=> {a: {b: {}}}
   */


  var dissocPath =
  /*#__PURE__*/
  _curry2(function dissocPath(path, obj) {
    if (obj == null) {
      return obj;
    }

    switch (path.length) {
      case 0:
        return obj;

      case 1:
        return _dissoc(path[0], obj);

      default:
        var head = path[0];
        var tail = Array.prototype.slice.call(path, 1);

        if (obj[head] == null) {
          return _shallowCloneObject(head, obj);
        } else {
          return assoc(head, dissocPath(tail, obj[head]), obj);
        }

    }
  });

  /**
   * Returns a new object that does not contain a `prop` property.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Object
   * @sig String -> {k: v} -> {k: v}
   * @param {String} prop The name of the property to dissociate
   * @param {Object} obj The object to clone
   * @return {Object} A new object equivalent to the original but without the specified property
   * @see R.assoc, R.omit
   * @example
   *
   *      R.dissoc('b', {a: 1, b: 2, c: 3}); //=> {a: 1, c: 3}
   */

  var dissoc =
  /*#__PURE__*/
  _curry2(function dissoc(prop, obj) {
    return dissocPath([prop], obj);
  });

  /**
   * Divides two numbers. Equivalent to `a / b`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a / b`.
   * @see R.multiply
   * @example
   *
   *      R.divide(71, 100); //=> 0.71
   *
   *      const half = R.divide(R.__, 2);
   *      half(42); //=> 21
   *
   *      const reciprocal = R.divide(1);
   *      reciprocal(4);   //=> 0.25
   */

  var divide =
  /*#__PURE__*/
  _curry2(function divide(a, b) {
    return a / b;
  });

  var XDrop =
  /*#__PURE__*/
  function () {
    function XDrop(n, xf) {
      this.xf = xf;
      this.n = n;
    }

    XDrop.prototype['@@transducer/init'] = _xfBase.init;
    XDrop.prototype['@@transducer/result'] = _xfBase.result;

    XDrop.prototype['@@transducer/step'] = function (result, input) {
      if (this.n > 0) {
        this.n -= 1;
        return result;
      }

      return this.xf['@@transducer/step'](result, input);
    };

    return XDrop;
  }();

  var _xdrop =
  /*#__PURE__*/
  _curry2(function _xdrop(n, xf) {
    return new XDrop(n, xf);
  });

  /**
   * Returns all but the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `drop` method).
   *
   * Dispatches to the `drop` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*} A copy of list without the first `n` elements
   * @see R.take, R.transduce, R.dropLast, R.dropWhile
   * @example
   *
   *      R.drop(1, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.drop(2, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.drop(3, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(4, ['foo', 'bar', 'baz']); //=> []
   *      R.drop(3, 'ramda');               //=> 'da'
   */

  var drop =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['drop'], _xdrop, function drop(n, xs) {
    return slice(Math.max(0, n), Infinity, xs);
  }));

  var XTake =
  /*#__PURE__*/
  function () {
    function XTake(n, xf) {
      this.xf = xf;
      this.n = n;
      this.i = 0;
    }

    XTake.prototype['@@transducer/init'] = _xfBase.init;
    XTake.prototype['@@transducer/result'] = _xfBase.result;

    XTake.prototype['@@transducer/step'] = function (result, input) {
      this.i += 1;
      var ret = this.n === 0 ? result : this.xf['@@transducer/step'](result, input);
      return this.n >= 0 && this.i >= this.n ? _reduced(ret) : ret;
    };

    return XTake;
  }();

  var _xtake =
  /*#__PURE__*/
  _curry2(function _xtake(n, xf) {
    return new XTake(n, xf);
  });

  /**
   * Returns the first `n` elements of the given list, string, or
   * transducer/transformer (or object with a `take` method).
   *
   * Dispatches to the `take` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n
   * @param {*} list
   * @return {*}
   * @see R.drop
   * @example
   *
   *      R.take(1, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.take(2, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.take(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.take(3, 'ramda');               //=> 'ram'
   *
   *      const personnel = [
   *        'Dave Brubeck',
   *        'Paul Desmond',
   *        'Eugene Wright',
   *        'Joe Morello',
   *        'Gerry Mulligan',
   *        'Bob Bates',
   *        'Joe Dodge',
   *        'Ron Crotty'
   *      ];
   *
   *      const takeFive = R.take(5);
   *      takeFive(personnel);
   *      //=> ['Dave Brubeck', 'Paul Desmond', 'Eugene Wright', 'Joe Morello', 'Gerry Mulligan']
   * @symb R.take(-1, [a, b]) = [a, b]
   * @symb R.take(0, [a, b]) = []
   * @symb R.take(1, [a, b]) = [a]
   * @symb R.take(2, [a, b]) = [a, b]
   */

  var take =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['take'], _xtake, function take(n, xs) {
    return slice(0, n < 0 ? Infinity : n, xs);
  }));

  function dropLast$1(n, xs) {
    return take(n < xs.length ? xs.length - n : 0, xs);
  }

  var XDropLast =
  /*#__PURE__*/
  function () {
    function XDropLast(n, xf) {
      this.xf = xf;
      this.pos = 0;
      this.full = false;
      this.acc = new Array(n);
    }

    XDropLast.prototype['@@transducer/init'] = _xfBase.init;

    XDropLast.prototype['@@transducer/result'] = function (result) {
      this.acc = null;
      return this.xf['@@transducer/result'](result);
    };

    XDropLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.full) {
        result = this.xf['@@transducer/step'](result, this.acc[this.pos]);
      }

      this.store(input);
      return result;
    };

    XDropLast.prototype.store = function (input) {
      this.acc[this.pos] = input;
      this.pos += 1;

      if (this.pos === this.acc.length) {
        this.pos = 0;
        this.full = true;
      }
    };

    return XDropLast;
  }();

  var _xdropLast =
  /*#__PURE__*/
  _curry2(function _xdropLast(n, xf) {
    return new XDropLast(n, xf);
  });

  /**
   * Returns a list containing all but the last `n` elements of the given `list`.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements of `list` to skip.
   * @param {Array} list The list of elements to consider.
   * @return {Array} A copy of the list with only the first `list.length - n` elements
   * @see R.takeLast, R.drop, R.dropWhile, R.dropLastWhile
   * @example
   *
   *      R.dropLast(1, ['foo', 'bar', 'baz']); //=> ['foo', 'bar']
   *      R.dropLast(2, ['foo', 'bar', 'baz']); //=> ['foo']
   *      R.dropLast(3, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(4, ['foo', 'bar', 'baz']); //=> []
   *      R.dropLast(3, 'ramda');               //=> 'ra'
   */

  var dropLast =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xdropLast, dropLast$1));

  function dropLastWhile$1(pred, xs) {
    var idx = xs.length - 1;

    while (idx >= 0 && pred(xs[idx])) {
      idx -= 1;
    }

    return slice(0, idx + 1, xs);
  }

  var XDropLastWhile =
  /*#__PURE__*/
  function () {
    function XDropLastWhile(fn, xf) {
      this.f = fn;
      this.retained = [];
      this.xf = xf;
    }

    XDropLastWhile.prototype['@@transducer/init'] = _xfBase.init;

    XDropLastWhile.prototype['@@transducer/result'] = function (result) {
      this.retained = null;
      return this.xf['@@transducer/result'](result);
    };

    XDropLastWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.retain(result, input) : this.flush(result, input);
    };

    XDropLastWhile.prototype.flush = function (result, input) {
      result = _reduce(this.xf['@@transducer/step'], result, this.retained);
      this.retained = [];
      return this.xf['@@transducer/step'](result, input);
    };

    XDropLastWhile.prototype.retain = function (result, input) {
      this.retained.push(input);
      return result;
    };

    return XDropLastWhile;
  }();

  var _xdropLastWhile =
  /*#__PURE__*/
  _curry2(function _xdropLastWhile(fn, xf) {
    return new XDropLastWhile(fn, xf);
  });

  /**
   * Returns a new list excluding all the tailing elements of a given list which
   * satisfy the supplied predicate function. It passes each value from the right
   * to the supplied predicate function, skipping elements until the predicate
   * function returns a `falsy` value. The predicate function is applied to one argument:
   * *(value)*.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} predicate The function to be called on each element
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array without any trailing elements that return `falsy` values from the `predicate`.
   * @see R.takeLastWhile, R.addIndex, R.drop, R.dropWhile
   * @example
   *
   *      const lteThree = x => x <= 3;
   *
   *      R.dropLastWhile(lteThree, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3, 4]
   *
   *      R.dropLastWhile(x => x !== 'd' , 'Ramda'); //=> 'Ramd'
   */

  var dropLastWhile =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xdropLastWhile, dropLastWhile$1));

  var XDropRepeatsWith =
  /*#__PURE__*/
  function () {
    function XDropRepeatsWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.lastValue = undefined;
      this.seenFirstValue = false;
    }

    XDropRepeatsWith.prototype['@@transducer/init'] = _xfBase.init;
    XDropRepeatsWith.prototype['@@transducer/result'] = _xfBase.result;

    XDropRepeatsWith.prototype['@@transducer/step'] = function (result, input) {
      var sameAsLast = false;

      if (!this.seenFirstValue) {
        this.seenFirstValue = true;
      } else if (this.pred(this.lastValue, input)) {
        sameAsLast = true;
      }

      this.lastValue = input;
      return sameAsLast ? result : this.xf['@@transducer/step'](result, input);
    };

    return XDropRepeatsWith;
  }();

  var _xdropRepeatsWith =
  /*#__PURE__*/
  _curry2(function _xdropRepeatsWith(pred, xf) {
    return new XDropRepeatsWith(pred, xf);
  });

  /**
   * Returns the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig [a] -> a | Undefined
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.init, R.head, R.tail
   * @example
   *
   *      R.last(['fi', 'fo', 'fum']); //=> 'fum'
   *      R.last([]); //=> undefined
   *
   *      R.last('abc'); //=> 'c'
   *      R.last(''); //=> ''
   */

  var last =
  /*#__PURE__*/
  nth(-1);

  /**
   * Returns a new list without any consecutively repeating elements. Equality is
   * determined by applying the supplied predicate to each pair of consecutive elements. The
   * first element in a series of equal elements will be preserved.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *      const l = [1, -1, 1, 3, 4, -4, -4, -5, 5, 3, 3];
   *      R.dropRepeatsWith(R.eqBy(Math.abs), l); //=> [1, 3, 4, -5, 3]
   */

  var dropRepeatsWith =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xdropRepeatsWith, function dropRepeatsWith(pred, list) {
    var result = [];
    var idx = 1;
    var len = list.length;

    if (len !== 0) {
      result[0] = list[0];

      while (idx < len) {
        if (!pred(last(result), list[idx])) {
          result[result.length] = list[idx];
        }

        idx += 1;
      }
    }

    return result;
  }));

  /**
   * Returns a new list without any consecutively repeating elements.
   * [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} `list` without repeating elements.
   * @see R.transduce
   * @example
   *
   *     R.dropRepeats([1, 1, 1, 2, 3, 4, 4, 2, 2]); //=> [1, 2, 3, 4, 2]
   */

  var dropRepeats =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _dispatchable([],
  /*#__PURE__*/
  _xdropRepeatsWith(equals),
  /*#__PURE__*/
  dropRepeatsWith(equals)));

  var XDropWhile =
  /*#__PURE__*/
  function () {
    function XDropWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XDropWhile.prototype['@@transducer/init'] = _xfBase.init;
    XDropWhile.prototype['@@transducer/result'] = _xfBase.result;

    XDropWhile.prototype['@@transducer/step'] = function (result, input) {
      if (this.f) {
        if (this.f(input)) {
          return result;
        }

        this.f = null;
      }

      return this.xf['@@transducer/step'](result, input);
    };

    return XDropWhile;
  }();

  var _xdropWhile =
  /*#__PURE__*/
  _curry2(function _xdropWhile(f, xf) {
    return new XDropWhile(f, xf);
  });

  /**
   * Returns a new list excluding the leading elements of a given list which
   * satisfy the supplied predicate function. It passes each value to the supplied
   * predicate function, skipping elements while the predicate function returns
   * `true`. The predicate function is applied to one argument: *(value)*.
   *
   * Dispatches to the `dropWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.takeWhile, R.transduce, R.addIndex
   * @example
   *
   *      const lteTwo = x => x <= 2;
   *
   *      R.dropWhile(lteTwo, [1, 2, 3, 4, 3, 2, 1]); //=> [3, 4, 3, 2, 1]
   *
   *      R.dropWhile(x => x !== 'd' , 'Ramda'); //=> 'da'
   */

  var dropWhile =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['dropWhile'], _xdropWhile, function dropWhile(pred, xs) {
    var idx = 0;
    var len = xs.length;

    while (idx < len && pred(xs[idx])) {
      idx += 1;
    }

    return slice(idx, Infinity, xs);
  }));

  /**
   * Returns the first argument if it is truthy, otherwise the second argument.
   * Acts as the boolean `or` statement if both inputs are `Boolean`s.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> b -> a | b
   * @param {Any} a
   * @param {Any} b
   * @return {Any}
   * @see R.either, R.and
   * @example
   *
   *      R.or(true, true); //=> true
   *      R.or(true, false); //=> true
   *      R.or(false, true); //=> true
   *      R.or(false, false); //=> false
   */

  var or =
  /*#__PURE__*/
  _curry2(function or(a, b) {
    return a || b;
  });

  /**
   * A function wrapping calls to the two functions in an `||` operation,
   * returning the result of the first function if it is truth-y and the result
   * of the second function otherwise. Note that this is short-circuited,
   * meaning that the second function will not be invoked if the first returns a
   * truth-y value.
   *
   * In addition to functions, `R.either` also accepts any fantasy-land compatible
   * applicative functor.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> Boolean) -> (*... -> Boolean)
   * @param {Function} f a predicate
   * @param {Function} g another predicate
   * @return {Function} a function that applies its arguments to `f` and `g` and `||`s their outputs together.
   * @see R.both, R.or
   * @example
   *
   *      const gt10 = x => x > 10;
   *      const even = x => x % 2 === 0;
   *      const f = R.either(gt10, even);
   *      f(101); //=> true
   *      f(8); //=> true
   *
   *      R.either(Maybe.Just(false), Maybe.Just(55)); // => Maybe.Just(55)
   *      R.either([false, false, 'a'], [11]) // => [11, 11, "a"]
   */

  var either =
  /*#__PURE__*/
  _curry2(function either(f, g) {
    return _isFunction(f) ? function _either() {
      return f.apply(this, arguments) || g.apply(this, arguments);
    } : lift(or)(f, g);
  });

  /**
   * Tests whether or not an object is a typed array.
   *
   * @private
   * @param {*} val The object to test.
   * @return {Boolean} `true` if `val` is a typed array, `false` otherwise.
   * @example
   *
   *      _isTypedArray(new Uint8Array([])); //=> true
   *      _isTypedArray(new Float32Array([])); //=> true
   *      _isTypedArray([]); //=> false
   *      _isTypedArray(null); //=> false
   *      _isTypedArray({}); //=> false
   */
  function _isTypedArray(val) {
    var type = Object.prototype.toString.call(val);
    return type === '[object Uint8ClampedArray]' || type === '[object Int8Array]' || type === '[object Uint8Array]' || type === '[object Int16Array]' || type === '[object Uint16Array]' || type === '[object Int32Array]' || type === '[object Uint32Array]' || type === '[object Float32Array]' || type === '[object Float64Array]' || type === '[object BigInt64Array]' || type === '[object BigUint64Array]';
  }

  /**
   * Returns the empty value of its argument's type. Ramda defines the empty
   * value of Array (`[]`), Object (`{}`), String (`''`),
   * TypedArray (`Uint8Array []`, `Float32Array []`, etc), and Arguments. Other
   * types are supported if they define `<Type>.empty`,
   * `<Type>.prototype.empty` or implement the
   * [FantasyLand Monoid spec](https://github.com/fantasyland/fantasy-land#monoid).
   *
   * Dispatches to the `empty` method of the first argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> a
   * @param {*} x
   * @return {*}
   * @example
   *
   *      R.empty(Just(42));               //=> Nothing()
   *      R.empty([1, 2, 3]);              //=> []
   *      R.empty('unicorns');             //=> ''
   *      R.empty({x: 1, y: 2});           //=> {}
   *      R.empty(Uint8Array.from('123')); //=> Uint8Array []
   */

  var empty =
  /*#__PURE__*/
  _curry1(function empty(x) {
    return x != null && typeof x['fantasy-land/empty'] === 'function' ? x['fantasy-land/empty']() : x != null && x.constructor != null && typeof x.constructor['fantasy-land/empty'] === 'function' ? x.constructor['fantasy-land/empty']() : x != null && typeof x.empty === 'function' ? x.empty() : x != null && x.constructor != null && typeof x.constructor.empty === 'function' ? x.constructor.empty() : _isArray(x) ? [] : _isString(x) ? '' : _isObject(x) ? {} : _isArguments(x) ? function () {
      return arguments;
    }() : _isTypedArray(x) ? x.constructor.from('') : void 0 // else
    ;
  });

  /**
   * Returns a new list containing the last `n` elements of the given list.
   * If `n > list.length`, returns a list of `list.length` elements.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [a]
   * @sig Number -> String -> String
   * @param {Number} n The number of elements to return.
   * @param {Array} xs The collection to consider.
   * @return {Array}
   * @see R.dropLast
   * @example
   *
   *      R.takeLast(1, ['foo', 'bar', 'baz']); //=> ['baz']
   *      R.takeLast(2, ['foo', 'bar', 'baz']); //=> ['bar', 'baz']
   *      R.takeLast(3, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(4, ['foo', 'bar', 'baz']); //=> ['foo', 'bar', 'baz']
   *      R.takeLast(3, 'ramda');               //=> 'mda'
   */

  var takeLast =
  /*#__PURE__*/
  _curry2(function takeLast(n, xs) {
    return drop(n >= 0 ? xs.length - n : 0, xs);
  });

  /**
   * Checks if a list ends with the provided sublist.
   *
   * Similarly, checks if a string ends with the provided substring.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> [a] -> Boolean
   * @sig String -> String -> Boolean
   * @param {*} suffix
   * @param {*} list
   * @return {Boolean}
   * @see R.startsWith
   * @example
   *
   *      R.endsWith('c', 'abc')                //=> true
   *      R.endsWith('b', 'abc')                //=> false
   *      R.endsWith(['c'], ['a', 'b', 'c'])    //=> true
   *      R.endsWith(['b'], ['a', 'b', 'c'])    //=> false
   */

  var endsWith =
  /*#__PURE__*/
  _curry2(function (suffix, list) {
    return equals(takeLast(suffix.length, list), suffix);
  });

  /**
   * Takes a function and two values in its domain and returns `true` if the
   * values map to the same value in the codomain; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Relation
   * @sig (a -> b) -> a -> a -> Boolean
   * @param {Function} f
   * @param {*} x
   * @param {*} y
   * @return {Boolean}
   * @example
   *
   *      R.eqBy(Math.abs, 5, -5); //=> true
   */

  var eqBy =
  /*#__PURE__*/
  _curry3(function eqBy(f, x, y) {
    return equals(f(x), f(y));
  });

  /**
   * Reports whether two objects have the same value, in [`R.equals`](#equals)
   * terms, for the specified property. Useful as a curried predicate.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig k -> {k: v} -> {k: v} -> Boolean
   * @param {String} prop The name of the property to compare
   * @param {Object} obj1
   * @param {Object} obj2
   * @return {Boolean}
   *
   * @example
   *
   *      const o1 = { a: 1, b: 2, c: 3, d: 4 };
   *      const o2 = { a: 10, b: 20, c: 3, d: 40 };
   *      R.eqProps('a', o1, o2); //=> false
   *      R.eqProps('c', o1, o2); //=> true
   */

  var eqProps =
  /*#__PURE__*/
  _curry3(function eqProps(prop, obj1, obj2) {
    return equals(obj1[prop], obj2[prop]);
  });

  /**
   * Creates a new object by recursively evolving a shallow copy of `object`,
   * according to the `transformation` functions. All non-primitive properties
   * are copied by reference.
   *
   * A `transformation` function will not be invoked if its corresponding key
   * does not exist in the evolved object.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {k: (v -> v)} -> {k: v} -> {k: v}
   * @param {Object} transformations The object specifying transformation functions to apply
   *        to the object.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      const tomato = {firstName: '  Tomato ', data: {elapsed: 100, remaining: 1400}, id:123};
   *      const transformations = {
   *        firstName: R.trim,
   *        lastName: R.trim, // Will not get invoked.
   *        data: {elapsed: R.add(1), remaining: R.add(-1)}
   *      };
   *      R.evolve(transformations, tomato); //=> {firstName: 'Tomato', data: {elapsed: 101, remaining: 1399}, id:123}
   */

  var evolve =
  /*#__PURE__*/
  _curry2(function evolve(transformations, object) {
    if (!_isObject(object) && !_isArray(object)) {
      return object;
    }

    var result = object instanceof Array ? [] : {};
    var transformation, key, type;

    for (key in object) {
      transformation = transformations[key];
      type = typeof transformation;
      result[key] = type === 'function' ? transformation(object[key]) : transformation && type === 'object' ? evolve(transformation, object[key]) : object[key];
    }

    return result;
  });

  var XFind =
  /*#__PURE__*/
  function () {
    function XFind(f, xf) {
      this.xf = xf;
      this.f = f;
      this.found = false;
    }

    XFind.prototype['@@transducer/init'] = _xfBase.init;

    XFind.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, void 0);
      }

      return this.xf['@@transducer/result'](result);
    };

    XFind.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, input));
      }

      return result;
    };

    return XFind;
  }();

  var _xfind =
  /*#__PURE__*/
  _curry2(function _xfind(f, xf) {
    return new XFind(f, xf);
  });

  /**
   * Returns the first element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Dispatches to the `find` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   *        desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      const xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.find(R.propEq('a', 2))(xs); //=> {a: 2}
   *      R.find(R.propEq('a', 4))(xs); //=> undefined
   */

  var find =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['find'], _xfind, function find(fn, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (fn(list[idx])) {
        return list[idx];
      }

      idx += 1;
    }
  }));

  var XFindIndex =
  /*#__PURE__*/
  function () {
    function XFindIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.found = false;
    }

    XFindIndex.prototype['@@transducer/init'] = _xfBase.init;

    XFindIndex.prototype['@@transducer/result'] = function (result) {
      if (!this.found) {
        result = this.xf['@@transducer/step'](result, -1);
      }

      return this.xf['@@transducer/result'](result);
    };

    XFindIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;

      if (this.f(input)) {
        this.found = true;
        result = _reduced(this.xf['@@transducer/step'](result, this.idx));
      }

      return result;
    };

    return XFindIndex;
  }();

  var _xfindIndex =
  /*#__PURE__*/
  _curry2(function _xfindIndex(f, xf) {
    return new XFindIndex(f, xf);
  });

  /**
   * Returns the index of the first element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce, R.indexOf
   * @example
   *
   *      const xs = [{a: 1}, {a: 2}, {a: 3}];
   *      R.findIndex(R.propEq('a', 2))(xs); //=> 1
   *      R.findIndex(R.propEq('a', 4))(xs); //=> -1
   */

  var findIndex =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xfindIndex, function findIndex(fn, list) {
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      if (fn(list[idx])) {
        return idx;
      }

      idx += 1;
    }

    return -1;
  }));

  var XFindLast =
  /*#__PURE__*/
  function () {
    function XFindLast(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XFindLast.prototype['@@transducer/init'] = _xfBase.init;

    XFindLast.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.last));
    };

    XFindLast.prototype['@@transducer/step'] = function (result, input) {
      if (this.f(input)) {
        this.last = input;
      }

      return result;
    };

    return XFindLast;
  }();

  var _xfindLast =
  /*#__PURE__*/
  _curry2(function _xfindLast(f, xf) {
    return new XFindLast(f, xf);
  });

  /**
   * Returns the last element of the list which matches the predicate, or
   * `undefined` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> a | undefined
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Object} The element found, or `undefined`.
   * @see R.transduce
   * @example
   *
   *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLast(R.propEq('a', 1))(xs); //=> {a: 1, b: 1}
   *      R.findLast(R.propEq('a', 4))(xs); //=> undefined
   */

  var findLast =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xfindLast, function findLast(fn, list) {
    var idx = list.length - 1;

    while (idx >= 0) {
      if (fn(list[idx])) {
        return list[idx];
      }

      idx -= 1;
    }
  }));

  var XFindLastIndex =
  /*#__PURE__*/
  function () {
    function XFindLastIndex(f, xf) {
      this.xf = xf;
      this.f = f;
      this.idx = -1;
      this.lastIdx = -1;
    }

    XFindLastIndex.prototype['@@transducer/init'] = _xfBase.init;

    XFindLastIndex.prototype['@@transducer/result'] = function (result) {
      return this.xf['@@transducer/result'](this.xf['@@transducer/step'](result, this.lastIdx));
    };

    XFindLastIndex.prototype['@@transducer/step'] = function (result, input) {
      this.idx += 1;

      if (this.f(input)) {
        this.lastIdx = this.idx;
      }

      return result;
    };

    return XFindLastIndex;
  }();

  var _xfindLastIndex =
  /*#__PURE__*/
  _curry2(function _xfindLastIndex(f, xf) {
    return new XFindLastIndex(f, xf);
  });

  /**
   * Returns the index of the last element of the list which matches the
   * predicate, or `-1` if no element matches.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> Number
   * @param {Function} fn The predicate function used to determine if the element is the
   * desired one.
   * @param {Array} list The array to consider.
   * @return {Number} The index of the element found, or `-1`.
   * @see R.transduce, R.lastIndexOf
   * @example
   *
   *      const xs = [{a: 1, b: 0}, {a:1, b: 1}];
   *      R.findLastIndex(R.propEq('a', 1))(xs); //=> 1
   *      R.findLastIndex(R.propEq('a', 4))(xs); //=> -1
   */

  var findLastIndex =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xfindLastIndex, function findLastIndex(fn, list) {
    var idx = list.length - 1;

    while (idx >= 0) {
      if (fn(list[idx])) {
        return idx;
      }

      idx -= 1;
    }

    return -1;
  }));

  /**
   * Returns a new list by pulling every item out of it (and all its sub-arrays)
   * and putting them in a new array, depth-first.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b]
   * @param {Array} list The array to consider.
   * @return {Array} The flattened list.
   * @see R.unnest
   * @example
   *
   *      R.flatten([1, 2, [3, 4], 5, [6, [7, 8, [9, [10, 11], 12]]]]);
   *      //=> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]
   */

  var flatten =
  /*#__PURE__*/
  _curry1(
  /*#__PURE__*/
  _makeFlat(true));

  /**
   * Returns a new function much like the supplied one, except that the first two
   * arguments' order is reversed.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((a, b, c, ...) -> z) -> (b -> a -> c -> ... -> z)
   * @param {Function} fn The function to invoke with its first two parameters reversed.
   * @return {*} The result of invoking `fn` with its first two parameters' order reversed.
   * @example
   *
   *      const mergeThree = (a, b, c) => [].concat(a, b, c);
   *
   *      mergeThree(1, 2, 3); //=> [1, 2, 3]
   *
   *      R.flip(mergeThree)(1, 2, 3); //=> [2, 1, 3]
   * @symb R.flip(f)(a, b, c) = f(b, a, c)
   */

  var flip =
  /*#__PURE__*/
  _curry1(function flip(fn) {
    return curryN(fn.length, function (a, b) {
      var args = Array.prototype.slice.call(arguments, 0);
      args[0] = b;
      args[1] = a;
      return fn.apply(this, args);
    });
  });

  /**
   * Iterate over an input `list`, calling a provided function `fn` for each
   * element in the list.
   *
   * `fn` receives one argument: *(value)*.
   *
   * Note: `R.forEach` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.forEach` method. For more
   * details on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/forEach#Description
   *
   * Also note that, unlike `Array.prototype.forEach`, Ramda's `forEach` returns
   * the original array. In some libraries this function is named `each`.
   *
   * Dispatches to the `forEach` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig (a -> *) -> [a] -> [a]
   * @param {Function} fn The function to invoke. Receives one argument, `value`.
   * @param {Array} list The list to iterate over.
   * @return {Array} The original list.
   * @see R.addIndex
   * @example
   *
   *      const printXPlusFive = x => console.log(x + 5);
   *      R.forEach(printXPlusFive, [1, 2, 3]); //=> [1, 2, 3]
   *      // logs 6
   *      // logs 7
   *      // logs 8
   * @symb R.forEach(f, [a, b, c]) = [a, b, c]
   */

  var forEach =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _checkForMethod('forEach', function forEach(fn, list) {
    var len = list.length;
    var idx = 0;

    while (idx < len) {
      fn(list[idx]);
      idx += 1;
    }

    return list;
  }));

  /**
   * Iterate over an input `object`, calling a provided function `fn` for each
   * key and value in the object.
   *
   * `fn` receives three argument: *(value, key, obj)*.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Object
   * @sig ((a, String, StrMap a) -> Any) -> StrMap a -> StrMap a
   * @param {Function} fn The function to invoke. Receives three argument, `value`, `key`, `obj`.
   * @param {Object} obj The object to iterate over.
   * @return {Object} The original object.
   * @example
   *
   *      const printKeyConcatValue = (value, key) => console.log(key + ':' + value);
   *      R.forEachObjIndexed(printKeyConcatValue, {x: 1, y: 2}); //=> {x: 1, y: 2}
   *      // logs x:1
   *      // logs y:2
   * @symb R.forEachObjIndexed(f, {x: a, y: b}) = {x: a, y: b}
   */

  var forEachObjIndexed =
  /*#__PURE__*/
  _curry2(function forEachObjIndexed(fn, obj) {
    var keyList = keys(obj);
    var idx = 0;

    while (idx < keyList.length) {
      var key = keyList[idx];
      fn(obj[key], key, obj);
      idx += 1;
    }

    return obj;
  });

  /**
   * Creates a new object from a list key-value pairs. If a key appears in
   * multiple pairs, the rightmost pair is included in the object.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [[k,v]] -> {k: v}
   * @param {Array} pairs An array of two-element arrays that will be the keys and values of the output object.
   * @return {Object} The object made by pairing up `keys` and `values`.
   * @see R.toPairs, R.pair
   * @example
   *
   *      R.fromPairs([['a', 1], ['b', 2], ['c', 3]]); //=> {a: 1, b: 2, c: 3}
   */

  var fromPairs =
  /*#__PURE__*/
  _curry1(function fromPairs(pairs) {
    var result = {};
    var idx = 0;

    while (idx < pairs.length) {
      result[pairs[idx][0]] = pairs[idx][1];
      idx += 1;
    }

    return result;
  });

  /**
   * Splits a list into sub-lists stored in an object, based on the result of
   * calling a key-returning function on each element, and grouping the
   * results according to values returned.
   *
   * Dispatches to the `groupBy` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> {a: [b]}
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} list The array to group
   * @return {Object} An object with the output of `fn` for keys, mapped to arrays of elements
   *         that produced that key when passed to `fn`.
   * @see R.reduceBy, R.transduce, R.indexBy
   * @example
   *
   *      const byGrade = R.groupBy(function(student) {
   *        const score = student.score;
   *        return score < 65 ? 'F' :
   *               score < 70 ? 'D' :
   *               score < 80 ? 'C' :
   *               score < 90 ? 'B' : 'A';
   *      });
   *      const students = [{name: 'Abby', score: 84},
   *                      {name: 'Eddy', score: 58},
   *                      // ...
   *                      {name: 'Jack', score: 69}];
   *      byGrade(students);
   *      // {
   *      //   'A': [{name: 'Dianne', score: 99}],
   *      //   'B': [{name: 'Abby', score: 84}]
   *      //   // ...,
   *      //   'F': [{name: 'Eddy', score: 58}]
   *      // }
   */

  var groupBy =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _checkForMethod('groupBy',
  /*#__PURE__*/
  reduceBy(function (acc, item) {
    acc.push(item);
    return acc;
  }, [])));

  /**
   * Takes a list and returns a list of lists where each sublist's elements are
   * all satisfied pairwise comparison according to the provided function.
   * Only adjacent elements are passed to the comparison function.
   *
   * @func
   * @memberOf R
   * @since v0.21.0
   * @category List
   * @sig ((a, a)  Boolean)  [a]  [[a]]
   * @param {Function} fn Function for determining whether two given (adjacent)
   *        elements should be in the same group
   * @param {Array} list The array to group. Also accepts a string, which will be
   *        treated as a list of characters.
   * @return {List} A list that contains sublists of elements,
   *         whose concatenations are equal to the original list.
   * @example
   *
   * R.groupWith(R.equals, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a + 1 === b, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0, 1], [1, 2, 3], [5], [8], [13], [21]]
   *
   * R.groupWith((a, b) => a % 2 === b % 2, [0, 1, 1, 2, 3, 5, 8, 13, 21])
   * //=> [[0], [1, 1], [2], [3, 5], [8], [13, 21]]
   *
   * const isVowel = R.test(/^[aeiou]$/i);
   * R.groupWith(R.eqBy(isVowel), 'aestiou')
   * //=> ['ae', 'st', 'iou']
   */

  var groupWith =
  /*#__PURE__*/
  _curry2(function (fn, list) {
    var res = [];
    var idx = 0;
    var len = list.length;

    while (idx < len) {
      var nextidx = idx + 1;

      while (nextidx < len && fn(list[nextidx - 1], list[nextidx])) {
        nextidx += 1;
      }

      res.push(list.slice(idx, nextidx));
      idx = nextidx;
    }

    return res;
  });

  /**
   * Returns `true` if the first argument is greater than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.lt
   * @example
   *
   *      R.gt(2, 1); //=> true
   *      R.gt(2, 2); //=> false
   *      R.gt(2, 3); //=> false
   *      R.gt('a', 'z'); //=> false
   *      R.gt('z', 'a'); //=> true
   */

  var gt =
  /*#__PURE__*/
  _curry2(function gt(a, b) {
    return a > b;
  });

  /**
   * Returns `true` if the first argument is greater than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.lte
   * @example
   *
   *      R.gte(2, 1); //=> true
   *      R.gte(2, 2); //=> true
   *      R.gte(2, 3); //=> false
   *      R.gte('a', 'z'); //=> false
   *      R.gte('z', 'a'); //=> true
   */

  var gte =
  /*#__PURE__*/
  _curry2(function gte(a, b) {
    return a >= b;
  });

  /**
   * Returns whether or not a path exists in an object. Only the object's
   * own properties are checked.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {a} -> Boolean
   * @param {Array} path The path to use.
   * @param {Object} obj The object to check the path in.
   * @return {Boolean} Whether the path exists.
   * @see R.has
   * @example
   *
   *      R.hasPath(['a', 'b'], {a: {b: 2}});         // => true
   *      R.hasPath(['a', 'b'], {a: {b: undefined}}); // => true
   *      R.hasPath(['a', 'b'], {a: {c: 2}});         // => false
   *      R.hasPath(['a', 'b'], {});                  // => false
   */

  var hasPath =
  /*#__PURE__*/
  _curry2(function hasPath(_path, obj) {
    if (_path.length === 0 || isNil$1(obj)) {
      return false;
    }

    var val = obj;
    var idx = 0;

    while (idx < _path.length) {
      if (!isNil$1(val) && _has(_path[idx], val)) {
        val = val[_path[idx]];
        idx += 1;
      } else {
        return false;
      }
    }

    return true;
  });

  /**
   * Returns whether or not an object has an own property with the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      const hasName = R.has('name');
   *      hasName({name: 'alice'});   //=> true
   *      hasName({name: 'bob'});     //=> true
   *      hasName({});                //=> false
   *
   *      const point = {x: 0, y: 0};
   *      const pointHas = R.has(R.__, point);
   *      pointHas('x');  //=> true
   *      pointHas('y');  //=> true
   *      pointHas('z');  //=> false
   */

  var has =
  /*#__PURE__*/
  _curry2(function has(prop, obj) {
    return hasPath([prop], obj);
  });

  /**
   * Returns whether or not an object or its prototype chain has a property with
   * the specified name
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Object
   * @sig s -> {s: x} -> Boolean
   * @param {String} prop The name of the property to check for.
   * @param {Object} obj The object to query.
   * @return {Boolean} Whether the property exists.
   * @example
   *
   *      function Rectangle(width, height) {
   *        this.width = width;
   *        this.height = height;
   *      }
   *      Rectangle.prototype.area = function() {
   *        return this.width * this.height;
   *      };
   *
   *      const square = new Rectangle(2, 2);
   *      R.hasIn('width', square);  //=> true
   *      R.hasIn('area', square);  //=> true
   */

  var hasIn =
  /*#__PURE__*/
  _curry2(function hasIn(prop, obj) {
    if (isNil$1(obj)) {
      return false;
    }

    return prop in obj;
  });

  /**
   * Returns true if its arguments are identical, false otherwise. Values are
   * identical if they reference the same memory. `NaN` is identical to `NaN`;
   * `0` and `-0` are not identical.
   *
   * Note this is merely a curried version of ES6 `Object.is`.
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category Relation
   * @sig a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @example
   *
   *      const o = {};
   *      R.identical(o, o); //=> true
   *      R.identical(1, 1); //=> true
   *      R.identical(1, '1'); //=> false
   *      R.identical([], []); //=> false
   *      R.identical(0, -0); //=> false
   *      R.identical(NaN, NaN); //=> true
   */

  var identical =
  /*#__PURE__*/
  _curry2(_objectIs$1);

  /**
   * Creates a function that will process either the `onTrue` or the `onFalse`
   * function depending upon the result of the `condition` predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Logic
   * @sig (*... -> Boolean) -> (*... -> *) -> (*... -> *) -> (*... -> *)
   * @param {Function} condition A predicate function
   * @param {Function} onTrue A function to invoke when the `condition` evaluates to a truthy value.
   * @param {Function} onFalse A function to invoke when the `condition` evaluates to a falsy value.
   * @return {Function} A new function that will process either the `onTrue` or the `onFalse`
   *                    function depending upon the result of the `condition` predicate.
   * @see R.unless, R.when, R.cond
   * @example
   *
   *      const incCount = R.ifElse(
   *        R.has('count'),
   *        R.over(R.lensProp('count'), R.inc),
   *        R.assoc('count', 1)
   *      );
   *      incCount({ count: 1 }); //=> { count: 2 }
   *      incCount({});           //=> { count: 1 }
   */

  var ifElse =
  /*#__PURE__*/
  _curry3(function ifElse(condition, onTrue, onFalse) {
    return curryN(Math.max(condition.length, onTrue.length, onFalse.length), function _ifElse() {
      return condition.apply(this, arguments) ? onTrue.apply(this, arguments) : onFalse.apply(this, arguments);
    });
  });

  /**
   * Increments its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number} n + 1
   * @see R.dec
   * @example
   *
   *      R.inc(42); //=> 43
   */

  var inc =
  /*#__PURE__*/
  add(1);

  /**
   * Returns `true` if the specified value is equal, in [`R.equals`](#equals)
   * terms, to at least one element of the given list; `false` otherwise.
   * Also works with strings.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category List
   * @sig a -> [a] -> Boolean
   * @param {Object} a The item to compare against.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if an equivalent item is in the list, `false` otherwise.
   * @see R.any
   * @example
   *
   *      R.includes(3, [1, 2, 3]); //=> true
   *      R.includes(4, [1, 2, 3]); //=> false
   *      R.includes({ name: 'Fred' }, [{ name: 'Fred' }]); //=> true
   *      R.includes([42], [[42]]); //=> true
   *      R.includes('ba', 'banana'); //=>true
   */

  var includes =
  /*#__PURE__*/
  _curry2(_includes);

  /**
   * Given a function that generates a key, turns a list of objects into an
   * object indexing the objects by the given key. Note that if multiple
   * objects generate the same value for the indexing key only the last value
   * will be included in the generated object.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @typedefn Idx = String | Int | Symbol
   * @sig Idx a => (b -> a) -> [b] -> {a: b}
   * @param {Function} fn Function :: a -> Idx
   * @param {Array} array The array of objects to index
   * @return {Object} An object indexing each array element by the given property.
   * @see R.groupBy
   * @example
   *
   *      const list = [{id: 'xyz', title: 'A'}, {id: 'abc', title: 'B'}];
   *      R.indexBy(R.prop('id'), list);
   *      //=> {abc: {id: 'abc', title: 'B'}, xyz: {id: 'xyz', title: 'A'}}
   */

  var indexBy =
  /*#__PURE__*/
  reduceBy(function (acc, elem) {
    return elem;
  }, null);

  /**
   * Returns the position of the first occurrence of an item in an array, or -1
   * if the item is not included in the array. [`R.equals`](#equals) is used to
   * determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.lastIndexOf, R.findIndex
   * @example
   *
   *      R.indexOf(3, [1,2,3,4]); //=> 2
   *      R.indexOf(10, [1,2,3,4]); //=> -1
   */

  var indexOf =
  /*#__PURE__*/
  _curry2(function indexOf(target, xs) {
    return typeof xs.indexOf === 'function' && !_isArray(xs) ? xs.indexOf(target) : _indexOf(xs, target, 0);
  });

  /**
   * Returns all but the last element of the given list or string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig [a] -> [a]
   * @sig String -> String
   * @param {*} list
   * @return {*}
   * @see R.last, R.head, R.tail
   * @example
   *
   *      R.init([1, 2, 3]);  //=> [1, 2]
   *      R.init([1, 2]);     //=> [1]
   *      R.init([1]);        //=> []
   *      R.init([]);         //=> []
   *
   *      R.init('abc');  //=> 'ab'
   *      R.init('ab');   //=> 'a'
   *      R.init('a');    //=> ''
   *      R.init('');     //=> ''
   */

  var init =
  /*#__PURE__*/
  slice(0, -1);

  /**
   * Takes a predicate `pred`, a list `xs`, and a list `ys`, and returns a list
   * `xs'` comprising each of the elements of `xs` which is equal to one or more
   * elements of `ys` according to `pred`.
   *
   * `pred` must be a binary function expecting an element from each list.
   *
   * `xs`, `ys`, and `xs'` are treated as sets, semantically, so ordering should
   * not be significant, but since `xs'` is ordered the implementation guarantees
   * that its values are in the same order as they appear in `xs`. Duplicates are
   * not removed, so `xs'` may contain duplicates if `xs` contains duplicates.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Relation
   * @sig ((a, b) -> Boolean) -> [a] -> [b] -> [a]
   * @param {Function} pred
   * @param {Array} xs
   * @param {Array} ys
   * @return {Array}
   * @see R.intersection
   * @example
   *
   *      R.innerJoin(
   *        (record, id) => record.id === id,
   *        [{id: 824, name: 'Richie Furay'},
   *         {id: 956, name: 'Dewey Martin'},
   *         {id: 313, name: 'Bruce Palmer'},
   *         {id: 456, name: 'Stephen Stills'},
   *         {id: 177, name: 'Neil Young'}],
   *        [177, 456, 999]
   *      );
   *      //=> [{id: 456, name: 'Stephen Stills'}, {id: 177, name: 'Neil Young'}]
   */

  var innerJoin =
  /*#__PURE__*/
  _curry3(function innerJoin(pred, xs, ys) {
    return _filter(function (x) {
      return _includesWith(pred, x, ys);
    }, xs);
  });

  /**
   * Inserts the supplied element into the list, at the specified `index`. _Note that

   * this is not destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.2.2
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} index The position to insert the element
   * @param {*} elt The element to insert into the Array
   * @param {Array} list The list to insert into
   * @return {Array} A new Array with `elt` inserted at `index`.
   * @example
   *
   *      R.insert(2, 'x', [1,2,3,4]); //=> [1,2,'x',3,4]
   */

  var insert =
  /*#__PURE__*/
  _curry3(function insert(idx, elt, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    var result = Array.prototype.slice.call(list, 0);
    result.splice(idx, 0, elt);
    return result;
  });

  /**
   * Inserts the sub-list into the list, at the specified `index`. _Note that this is not
   * destructive_: it returns a copy of the list with the changes.
   * <small>No lists have been harmed in the application of this function.</small>
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category List
   * @sig Number -> [a] -> [a] -> [a]
   * @param {Number} index The position to insert the sub-list
   * @param {Array} elts The sub-list to insert into the Array
   * @param {Array} list The list to insert the sub-list into
   * @return {Array} A new Array with `elts` inserted starting at `index`.
   * @example
   *
   *      R.insertAll(2, ['x','y','z'], [1,2,3,4]); //=> [1,2,'x','y','z',3,4]
   */

  var insertAll =
  /*#__PURE__*/
  _curry3(function insertAll(idx, elts, list) {
    idx = idx < list.length && idx >= 0 ? idx : list.length;
    return [].concat(Array.prototype.slice.call(list, 0, idx), elts, Array.prototype.slice.call(list, idx));
  });

  var XUniqBy =
  /*#__PURE__*/
  function () {
    function XUniqBy(f, xf) {
      this.xf = xf;
      this.f = f;
      this.set = new _Set();
    }

    XUniqBy.prototype['@@transducer/init'] = _xfBase.init;
    XUniqBy.prototype['@@transducer/result'] = _xfBase.result;

    XUniqBy.prototype['@@transducer/step'] = function (result, input) {
      return this.set.add(this.f(input)) ? this.xf['@@transducer/step'](result, input) : result;
    };

    return XUniqBy;
  }();

  var _xuniqBy =
  /*#__PURE__*/
  _curry2(function _xuniqBy(f, xf) {
    return new XUniqBy(f, xf);
  });

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied function to
   * each list element. Prefers the first item if the supplied function produces
   * the same value on two items. [`R.equals`](#equals) is used for comparison.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> b) -> [a] -> [a]
   * @param {Function} fn A function used to produce a value to use during comparisons.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniqBy(Math.abs, [-1, -5, 2, 10, 1, 2]); //=> [-1, -5, 2, 10]
   */

  var uniqBy =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xuniqBy, function (fn, list) {
    var set = new _Set();
    var result = [];
    var idx = 0;
    var appliedItem, item;

    while (idx < list.length) {
      item = list[idx];
      appliedItem = fn(item);

      if (set.add(appliedItem)) {
        result.push(item);
      }

      idx += 1;
    }

    return result;
  }));

  /**
   * Returns a new list containing only one copy of each element in the original
   * list. [`R.equals`](#equals) is used to determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [a]
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      R.uniq([1, 1, 2, 1]); //=> [1, 2]
   *      R.uniq([1, '1']);     //=> [1, '1']
   *      R.uniq([[42], [42]]); //=> [[42]]
   */

  var uniq =
  /*#__PURE__*/
  uniqBy(identity);

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of those
   * elements common to both lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The list of elements found in both `list1` and `list2`.
   * @see R.innerJoin
   * @example
   *
   *      R.intersection([1,2,3,4], [7,6,5,4,3]); //=> [4, 3]
   */

  var intersection =
  /*#__PURE__*/
  _curry2(function intersection(list1, list2) {
    var lookupList, filteredList;

    if (list1.length > list2.length) {
      lookupList = list1;
      filteredList = list2;
    } else {
      lookupList = list2;
      filteredList = list1;
    }

    return uniq(_filter(flip(_includes)(lookupList), filteredList));
  });

  /**
   * Creates a new list with the separator interposed between elements.
   *
   * Dispatches to the `intersperse` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} separator The element to add to the list.
   * @param {Array} list The list to be interposed.
   * @return {Array} The new list.
   * @example
   *
   *      R.intersperse('a', ['b', 'n', 'n', 's']); //=> ['b', 'a', 'n', 'a', 'n', 'a', 's']
   */

  var intersperse =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _checkForMethod('intersperse', function intersperse(separator, list) {
    var out = [];
    var idx = 0;
    var length = list.length;

    while (idx < length) {
      if (idx === length - 1) {
        out.push(list[idx]);
      } else {
        out.push(list[idx], separator);
      }

      idx += 1;
    }

    return out;
  }));

  function _objectAssign(target) {
    if (target == null) {
      throw new TypeError('Cannot convert undefined or null to object');
    }

    var output = Object(target);
    var idx = 1;
    var length = arguments.length;

    while (idx < length) {
      var source = arguments[idx];

      if (source != null) {
        for (var nextKey in source) {
          if (_has(nextKey, source)) {
            output[nextKey] = source[nextKey];
          }
        }
      }

      idx += 1;
    }

    return output;
  }

  var _objectAssign$1 = typeof Object.assign === 'function' ? Object.assign : _objectAssign;

  /**
   * Creates an object containing a single key:value pair.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @sig String -> a -> {String:a}
   * @param {String} key
   * @param {*} val
   * @return {Object}
   * @see R.pair
   * @example
   *
   *      const matchPhrases = R.compose(
   *        R.objOf('must'),
   *        R.map(R.objOf('match_phrase'))
   *      );
   *      matchPhrases(['foo', 'bar', 'baz']); //=> {must: [{match_phrase: 'foo'}, {match_phrase: 'bar'}, {match_phrase: 'baz'}]}
   */

  var objOf =
  /*#__PURE__*/
  _curry2(function objOf(key, val) {
    var obj = {};
    obj[key] = val;
    return obj;
  });

  var _stepCatArray = {
    '@@transducer/init': Array,
    '@@transducer/step': function (xs, x) {
      xs.push(x);
      return xs;
    },
    '@@transducer/result': _identity
  };
  var _stepCatString = {
    '@@transducer/init': String,
    '@@transducer/step': function (a, b) {
      return a + b;
    },
    '@@transducer/result': _identity
  };
  var _stepCatObject = {
    '@@transducer/init': Object,
    '@@transducer/step': function (result, input) {
      return _objectAssign$1(result, _isArrayLike(input) ? objOf(input[0], input[1]) : input);
    },
    '@@transducer/result': _identity
  };
  function _stepCat(obj) {
    if (_isTransformer(obj)) {
      return obj;
    }

    if (_isArrayLike(obj)) {
      return _stepCatArray;
    }

    if (typeof obj === 'string') {
      return _stepCatString;
    }

    if (typeof obj === 'object') {
      return _stepCatObject;
    }

    throw new Error('Cannot create transformer for ' + obj);
  }

  /**
   * Transforms the items of the list with the transducer and appends the
   * transformed items to the accumulator using an appropriate iterator function
   * based on the accumulator type.
   *
   * The accumulator can be an array, string, object or a transformer. Iterated
   * items will be appended to arrays and concatenated to strings. Objects will
   * be merged directly or 2-item arrays will be merged as key, value pairs.
   *
   * The accumulator can also be a transformer object that provides a 2-arity
   * reducing iterator function, step, 0-arity initial value function, init, and
   * 1-arity result extraction function result. The step function is used as the
   * iterator function in reduce. The result function is used to convert the
   * final accumulator into the return type and in most cases is R.identity. The
   * init function is used to provide the initial accumulator.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the
   * transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig a -> (b -> b) -> [c] -> a
   * @param {*} acc The initial accumulator value.
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.transduce
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
   *
   *      R.into([], transducer, numbers); //=> [2, 3]
   *
   *      const intoArray = R.into([]);
   *      intoArray(transducer, numbers); //=> [2, 3]
   */

  var into =
  /*#__PURE__*/
  _curry3(function into(acc, xf, list) {
    return _isTransformer(acc) ? _reduce(xf(acc), acc['@@transducer/init'](), list) : _reduce(xf(_stepCat(acc)), _clone(acc, [], [], false), list);
  });

  /**
   * Same as [`R.invertObj`](#invertObj), however this accounts for objects with
   * duplicate values by putting the values into an array.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: [ s, ... ]}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object with keys in an array.
   * @see R.invertObj
   * @example
   *
   *      const raceResultsByFirstName = {
   *        first: 'alice',
   *        second: 'jake',
   *        third: 'alice',
   *      };
   *      R.invert(raceResultsByFirstName);
   *      //=> { 'alice': ['first', 'third'], 'jake':['second'] }
   */

  var invert =
  /*#__PURE__*/
  _curry1(function invert(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      var val = obj[key];
      var list = _has(val, out) ? out[val] : out[val] = [];
      list[list.length] = key;
      idx += 1;
    }

    return out;
  });

  /**
   * Returns a new object with the keys of the given object as values, and the
   * values of the given object, which are coerced to strings, as keys. Note
   * that the last key found is preferred when handling the same value.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig {s: x} -> {x: s}
   * @param {Object} obj The object or array to invert
   * @return {Object} out A new object
   * @see R.invert
   * @example
   *
   *      const raceResults = {
   *        first: 'alice',
   *        second: 'jake'
   *      };
   *      R.invertObj(raceResults);
   *      //=> { 'alice': 'first', 'jake':'second' }
   *
   *      // Alternatively:
   *      const raceResults = ['alice', 'jake'];
   *      R.invertObj(raceResults);
   *      //=> { 'alice': '0', 'jake':'1' }
   */

  var invertObj =
  /*#__PURE__*/
  _curry1(function invertObj(obj) {
    var props = keys(obj);
    var len = props.length;
    var idx = 0;
    var out = {};

    while (idx < len) {
      var key = props[idx];
      out[obj[key]] = key;
      idx += 1;
    }

    return out;
  });

  /**
   * Turns a named method with a specified arity into a function that can be
   * called directly supplied with arguments and a target object.
   *
   * The returned function is curried and accepts `arity + 1` parameters where
   * the final parameter is the target object.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig Number -> String -> (a -> b -> ... -> n -> Object -> *)
   * @param {Number} arity Number of arguments the returned function should take
   *        before the target object.
   * @param {String} method Name of any of the target object's methods to call.
   * @return {Function} A new curried function.
   * @see R.construct
   * @example
   *
   *      const sliceFrom = R.invoker(1, 'slice');
   *      sliceFrom(6, 'abcdefghijklm'); //=> 'ghijklm'
   *      const sliceFrom6 = R.invoker(2, 'slice')(6);
   *      sliceFrom6(8, 'abcdefghijklm'); //=> 'gh'
   *
   *      const dog = {
   *        speak: async () => 'Woof!'
   *      };
   *      const speak = R.invoker(0, 'speak');
   *      speak(dog).then(console.log) //~> 'Woof!'
   *
   * @symb R.invoker(0, 'method')(o) = o['method']()
   * @symb R.invoker(1, 'method')(a, o) = o['method'](a)
   * @symb R.invoker(2, 'method')(a, b, o) = o['method'](a, b)
   */

  var invoker =
  /*#__PURE__*/
  _curry2(function invoker(arity, method) {
    return curryN(arity + 1, function () {
      var target = arguments[arity];

      if (target != null && _isFunction(target[method])) {
        return target[method].apply(target, Array.prototype.slice.call(arguments, 0, arity));
      }

      throw new TypeError(toString(target) + ' does not have a method named "' + method + '"');
    });
  });

  /**
   * See if an object (i.e. `val`) is an instance of the supplied constructor. This
   * function will check up the inheritance chain, if any.
   * If `val` was created using `Object.create`, `R.is(Object, val) === true`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Type
   * @sig (* -> {*}) -> a -> Boolean
   * @param {Object} ctor A constructor
   * @param {*} val The value to test
   * @return {Boolean}
   * @example
   *
   *      R.is(Object, {}); //=> true
   *      R.is(Number, 1); //=> true
   *      R.is(Object, 1); //=> false
   *      R.is(String, 's'); //=> true
   *      R.is(String, new String('')); //=> true
   *      R.is(Object, new String('')); //=> true
   *      R.is(Object, 's'); //=> false
   *      R.is(Number, {}); //=> false
   */

  var is =
  /*#__PURE__*/
  _curry2(function is(Ctor, val) {
    return val instanceof Ctor || val != null && (val.constructor === Ctor || Ctor.name === 'Object' && typeof val === 'object');
  });

  /**
   * Returns `true` if the given value is its type's empty value; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Logic
   * @sig a -> Boolean
   * @param {*} x
   * @return {Boolean}
   * @see R.empty
   * @example
   *
   *      R.isEmpty([1, 2, 3]);           //=> false
   *      R.isEmpty([]);                  //=> true
   *      R.isEmpty('');                  //=> true
   *      R.isEmpty(null);                //=> false
   *      R.isEmpty({});                  //=> true
   *      R.isEmpty({length: 0});         //=> false
   *      R.isEmpty(Uint8Array.from('')); //=> true
   */

  var isEmpty =
  /*#__PURE__*/
  _curry1(function isEmpty(x) {
    return x != null && equals(x, empty(x));
  });

  /**
   * Returns a string made by inserting the `separator` between each element and
   * concatenating all the elements into a single string.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig String -> [a] -> String
   * @param {Number|String} separator The string used to separate the elements.
   * @param {Array} xs The elements to join into a string.
   * @return {String} str The string made by concatenating `xs` with `separator`.
   * @see R.split
   * @example
   *
   *      const spacer = R.join(' ');
   *      spacer(['a', 2, 3.4]);   //=> 'a 2 3.4'
   *      R.join('|', [1, 2, 3]);    //=> '1|2|3'
   */

  var join =
  /*#__PURE__*/
  invoker(1, 'join');

  /**
   * juxt applies a list of functions to a list of values.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Function
   * @sig [(a, b, ..., m) -> n] -> ((a, b, ..., m) -> [n])
   * @param {Array} fns An array of functions
   * @return {Function} A function that returns a list of values after applying each of the original `fns` to its parameters.
   * @see R.applySpec
   * @example
   *
   *      const getRange = R.juxt([Math.min, Math.max]);
   *      getRange(3, 4, 9, -3); //=> [-3, 9]
   * @symb R.juxt([f, g, h])(a, b) = [f(a, b), g(a, b), h(a, b)]
   */

  var juxt =
  /*#__PURE__*/
  _curry1(function juxt(fns) {
    return converge(function () {
      return Array.prototype.slice.call(arguments, 0);
    }, fns);
  });

  /**
   * Returns a list containing the names of all the properties of the supplied
   * object, including prototype properties.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [k]
   * @param {Object} obj The object to extract properties from
   * @return {Array} An array of the object's own and prototype properties.
   * @see R.keys, R.valuesIn
   * @example
   *
   *      const F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      const f = new F();
   *      R.keysIn(f); //=> ['x', 'y']
   */

  var keysIn =
  /*#__PURE__*/
  _curry1(function keysIn(obj) {
    var prop;
    var ks = [];

    for (prop in obj) {
      ks[ks.length] = prop;
    }

    return ks;
  });

  /**
   * Returns the position of the last occurrence of an item in an array, or -1 if
   * the item is not included in the array. [`R.equals`](#equals) is used to
   * determine equality.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> Number
   * @param {*} target The item to find.
   * @param {Array} xs The array to search in.
   * @return {Number} the index of the target, or -1 if the target is not found.
   * @see R.indexOf, R.findLastIndex
   * @example
   *
   *      R.lastIndexOf(3, [-1,3,3,0,1,2,3,4]); //=> 6
   *      R.lastIndexOf(10, [1,2,3,4]); //=> -1
   */

  var lastIndexOf =
  /*#__PURE__*/
  _curry2(function lastIndexOf(target, xs) {
    if (typeof xs.lastIndexOf === 'function' && !_isArray(xs)) {
      return xs.lastIndexOf(target);
    } else {
      var idx = xs.length - 1;

      while (idx >= 0) {
        if (equals(xs[idx], target)) {
          return idx;
        }

        idx -= 1;
      }

      return -1;
    }
  });

  function _isNumber(x) {
    return Object.prototype.toString.call(x) === '[object Number]';
  }

  /**
   * Returns the number of elements in the array by returning `list.length`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [a] -> Number
   * @param {Array} list The array to inspect.
   * @return {Number} The length of the array.
   * @example
   *
   *      R.length([]); //=> 0
   *      R.length([1, 2, 3]); //=> 3
   */

  var length =
  /*#__PURE__*/
  _curry1(function length(list) {
    return list != null && _isNumber(list.length) ? list.length : NaN;
  });

  /**
   * Returns a lens for the given getter and setter functions. The getter "gets"
   * the value of the focus; the setter "sets" the value of the focus. The setter
   * should not mutate the data structure.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig (s -> a) -> ((a, s) -> s) -> Lens s a
   * @param {Function} getter
   * @param {Function} setter
   * @return {Lens}
   * @see R.view, R.set, R.over, R.lensIndex, R.lensProp
   * @example
   *
   *      const xLens = R.lens(R.prop('x'), R.assoc('x'));
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */

  var lens =
  /*#__PURE__*/
  _curry2(function lens(getter, setter) {
    return function (toFunctorFn) {
      return function (target) {
        return map$1(function (focus) {
          return setter(focus, target);
        }, toFunctorFn(getter(target)));
      };
    };
  });

  /**
   * Returns a new copy of the array with the element at the provided index
   * replaced with the given value.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category List
   * @sig Number -> a -> [a] -> [a]
   * @param {Number} idx The index to update.
   * @param {*} x The value to exist at the given index of the returned array.
   * @param {Array|Arguments} list The source array-like object to be updated.
   * @return {Array} A copy of `list` with the value at index `idx` replaced with `x`.
   * @see R.adjust
   * @example
   *
   *      R.update(1, '_', ['a', 'b', 'c']);      //=> ['a', '_', 'c']
   *      R.update(-1, '_', ['a', 'b', 'c']);     //=> ['a', 'b', '_']
   * @symb R.update(-1, a, [b, c]) = [b, a]
   * @symb R.update(0, a, [b, c]) = [a, c]
   * @symb R.update(1, a, [b, c]) = [b, a]
   */

  var update =
  /*#__PURE__*/
  _curry3(function update(idx, x, list) {
    return adjust(idx, always(x), list);
  });

  /**
   * Returns a lens whose focus is the specified index.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Number -> Lens s a
   * @param {Number} n
   * @return {Lens}
   * @see R.view, R.set, R.over, R.nth
   * @example
   *
   *      const headLens = R.lensIndex(0);
   *
   *      R.view(headLens, ['a', 'b', 'c']);            //=> 'a'
   *      R.set(headLens, 'x', ['a', 'b', 'c']);        //=> ['x', 'b', 'c']
   *      R.over(headLens, R.toUpper, ['a', 'b', 'c']); //=> ['A', 'b', 'c']
   */

  var lensIndex =
  /*#__PURE__*/
  _curry1(function lensIndex(n) {
    return lens(nth(n), update(n));
  });

  /**
   * Retrieves the values at given paths of an object.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category Object
   * @typedefn Idx = [String | Int | Symbol]
   * @sig [Idx] -> {a} -> [a | Undefined]
   * @param {Array} pathsArray The array of paths to be fetched.
   * @param {Object} obj The object to retrieve the nested properties from.
   * @return {Array} A list consisting of values at paths specified by "pathsArray".
   * @see R.path
   * @example
   *
   *      R.paths([['a', 'b'], ['p', 0, 'q']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, 3]
   *      R.paths([['a', 'b'], ['p', 'r']], {a: {b: 2}, p: [{q: 3}]}); //=> [2, undefined]
   */

  var paths =
  /*#__PURE__*/
  _curry2(function paths(pathsArray, obj) {
    return pathsArray.map(function (paths) {
      var val = obj;
      var idx = 0;
      var p;

      while (idx < paths.length) {
        if (val == null) {
          return;
        }

        p = paths[idx];
        val = _isInteger(p) ? nth(p, val) : val[p];
        idx += 1;
      }

      return val;
    });
  });

  /**
   * Retrieve the value at a given path.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> {a} -> a | Undefined
   * @param {Array} path The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path`.
   * @see R.prop, R.nth
   * @example
   *
   *      R.path(['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.path(['a', 'b'], {c: {b: 2}}); //=> undefined
   *      R.path(['a', 'b', 0], {a: {b: [1, 2, 3]}}); //=> 1
   *      R.path(['a', 'b', -2], {a: {b: [1, 2, 3]}}); //=> 2
   */

  var path =
  /*#__PURE__*/
  _curry2(function path(pathAr, obj) {
    return paths([pathAr], obj)[0];
  });

  /**
   * Returns a lens whose focus is the specified path.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig [Idx] -> Lens s a
   * @param {Array} path The path to use.
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      const xHeadYLens = R.lensPath(['x', 0, 'y']);
   *
   *      R.view(xHeadYLens, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> 2
   *      R.set(xHeadYLens, 1, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: 1, z: 3}, {y: 4, z: 5}]}
   *      R.over(xHeadYLens, R.negate, {x: [{y: 2, z: 3}, {y: 4, z: 5}]});
   *      //=> {x: [{y: -2, z: 3}, {y: 4, z: 5}]}
   */

  var lensPath =
  /*#__PURE__*/
  _curry1(function lensPath(p) {
    return lens(path(p), assocPath(p));
  });

  /**
   * Returns a lens whose focus is the specified property.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig String -> Lens s a
   * @param {String} k
   * @return {Lens}
   * @see R.view, R.set, R.over
   * @example
   *
   *      const xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});            //=> 1
   *      R.set(xLens, 4, {x: 1, y: 2});          //=> {x: 4, y: 2}
   *      R.over(xLens, R.negate, {x: 1, y: 2});  //=> {x: -1, y: 2}
   */

  var lensProp =
  /*#__PURE__*/
  _curry1(function lensProp(k) {
    return lens(prop(k), assoc(k));
  });

  /**
   * Returns `true` if the first argument is less than the second; `false`
   * otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {*} a
   * @param {*} b
   * @return {Boolean}
   * @see R.gt
   * @example
   *
   *      R.lt(2, 1); //=> false
   *      R.lt(2, 2); //=> false
   *      R.lt(2, 3); //=> true
   *      R.lt('a', 'z'); //=> true
   *      R.lt('z', 'a'); //=> false
   */

  var lt =
  /*#__PURE__*/
  _curry2(function lt(a, b) {
    return a < b;
  });

  /**
   * Returns `true` if the first argument is less than or equal to the second;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> Boolean
   * @param {Number} a
   * @param {Number} b
   * @return {Boolean}
   * @see R.gte
   * @example
   *
   *      R.lte(2, 1); //=> false
   *      R.lte(2, 2); //=> true
   *      R.lte(2, 3); //=> true
   *      R.lte('a', 'z'); //=> true
   *      R.lte('z', 'a'); //=> false
   */

  var lte =
  /*#__PURE__*/
  _curry2(function lte(a, b) {
    return a <= b;
  });

  /**
   * The `mapAccum` function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from left to right, and returning a final value of this
   * accumulator together with the new list.
   *
   * The iterator function receives two arguments, *acc* and *value*, and should
   * return a tuple *[acc, value]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.scan, R.addIndex, R.mapAccumRight
   * @example
   *
   *      const digits = ['1', '2', '3', '4'];
   *      const appender = (a, b) => [a + b, a + b];
   *
   *      R.mapAccum(appender, 0, digits); //=> ['01234', ['01', '012', '0123', '01234']]
   * @symb R.mapAccum(f, a, [b, c, d]) = [
   *   f(f(f(a, b)[0], c)[0], d)[0],
   *   [
   *     f(a, b)[1],
   *     f(f(a, b)[0], c)[1],
   *     f(f(f(a, b)[0], c)[0], d)[1]
   *   ]
   * ]
   */

  var mapAccum =
  /*#__PURE__*/
  _curry3(function mapAccum(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var tuple = [acc];

    while (idx < len) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx += 1;
    }

    return [tuple[0], result];
  });

  /**
   * The `mapAccumRight` function behaves like a combination of map and reduce; it
   * applies a function to each element of a list, passing an accumulating
   * parameter from right to left, and returning a final value of this
   * accumulator together with the new list.
   *
   * Similar to [`mapAccum`](#mapAccum), except moves through the input list from
   * the right to the left.
   *
   * The iterator function receives two arguments, *acc* and *value*, and should
   * return a tuple *[acc, value]*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((acc, x) -> (acc, y)) -> acc -> [x] -> (acc, [y])
   * @param {Function} fn The function to be called on every element of the input `list`.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.addIndex, R.mapAccum
   * @example
   *
   *      const digits = ['1', '2', '3', '4'];
   *      const appender = (a, b) => [b + a, b + a];
   *
   *      R.mapAccumRight(appender, 5, digits); //=> ['12345', ['12345', '2345', '345', '45']]
   * @symb R.mapAccumRight(f, a, [b, c, d]) = [
   *   f(f(f(a, d)[0], c)[0], b)[0],
   *   [
   *     f(a, d)[1],
   *     f(f(a, d)[0], c)[1],
   *     f(f(f(a, d)[0], c)[0], b)[1]
   *   ]
   * ]
   */

  var mapAccumRight =
  /*#__PURE__*/
  _curry3(function mapAccumRight(fn, acc, list) {
    var idx = list.length - 1;
    var result = [];
    var tuple = [acc];

    while (idx >= 0) {
      tuple = fn(tuple[0], list[idx]);
      result[idx] = tuple[1];
      idx -= 1;
    }

    return [tuple[0], result];
  });

  /**
   * An Object-specific version of [`map`](#map). The function is applied to three
   * arguments: *(value, key, obj)*. If only the value is significant, use
   * [`map`](#map) instead.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Object
   * @sig ((*, String, Object) -> *) -> Object -> Object
   * @param {Function} fn
   * @param {Object} obj
   * @return {Object}
   * @see R.map
   * @example
   *
   *      const xyz = { x: 1, y: 2, z: 3 };
   *      const prependKeyAndDouble = (num, key, obj) => key + (num * 2);
   *
   *      R.mapObjIndexed(prependKeyAndDouble, xyz); //=> { x: 'x2', y: 'y4', z: 'z6' }
   */

  var mapObjIndexed =
  /*#__PURE__*/
  _curry2(function mapObjIndexed(fn, obj) {
    return _reduce(function (acc, key) {
      acc[key] = fn(obj[key], key, obj);
      return acc;
    }, {}, keys(obj));
  });

  /**
   * Tests a regular expression against a String. Note that this function will
   * return an empty array when there are no matches. This differs from
   * [`String.prototype.match`](https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String/match)
   * which returns `null` when there are no matches.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig RegExp -> String -> [String | Undefined]
   * @param {RegExp} rx A regular expression.
   * @param {String} str The string to match against
   * @return {Array} The list of matches or empty array.
   * @see R.test
   * @example
   *
   *      R.match(/([a-z]a)/g, 'bananas'); //=> ['ba', 'na', 'na']
   *      R.match(/a/, 'b'); //=> []
   *      R.match(/a/, null); //=> TypeError: null does not have a method named "match"
   */

  var match =
  /*#__PURE__*/
  _curry2(function match(rx, str) {
    return str.match(rx) || [];
  });

  /**
   * `mathMod` behaves like the modulo operator should mathematically, unlike the
   * `%` operator (and by extension, [`R.modulo`](#modulo)). So while
   * `-17 % 5` is `-2`, `mathMod(-17, 5)` is `3`. `mathMod` requires Integer
   * arguments, and returns NaN when the modulus is zero or negative.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} m The dividend.
   * @param {Number} p the modulus.
   * @return {Number} The result of `b mod a`.
   * @see R.modulo
   * @example
   *
   *      R.mathMod(-17, 5);  //=> 3
   *      R.mathMod(17, 5);   //=> 2
   *      R.mathMod(17, -5);  //=> NaN
   *      R.mathMod(17, 0);   //=> NaN
   *      R.mathMod(17.2, 5); //=> NaN
   *      R.mathMod(17, 5.3); //=> NaN
   *
   *      const clock = R.mathMod(R.__, 12);
   *      clock(15); //=> 3
   *      clock(24); //=> 0
   *
   *      const seventeenMod = R.mathMod(17);
   *      seventeenMod(3);  //=> 2
   *      seventeenMod(4);  //=> 1
   *      seventeenMod(10); //=> 7
   */

  var mathMod =
  /*#__PURE__*/
  _curry2(function mathMod(m, p) {
    if (!_isInteger(m)) {
      return NaN;
    }

    if (!_isInteger(p) || p < 1) {
      return NaN;
    }

    return (m % p + p) % p;
  });

  /**
   * Takes a function and two values, and returns whichever value produces the
   * larger result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.max, R.minBy
   * @example
   *
   *      //  square :: Number -> Number
   *      const square = n => n * n;
   *
   *      R.maxBy(square, -3, 2); //=> -3
   *
   *      R.reduce(R.maxBy(square), 0, [3, -5, 4, 1, -2]); //=> -5
   *      R.reduce(R.maxBy(square), 0, []); //=> 0
   */

  var maxBy =
  /*#__PURE__*/
  _curry3(function maxBy(f, a, b) {
    return f(b) > f(a) ? b : a;
  });

  /**
   * Adds together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The sum of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.sum([2,4,6,8,100,1]); //=> 121
   */

  var sum =
  /*#__PURE__*/
  reduce(add, 0);

  /**
   * Returns the mean of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @see R.median
   * @example
   *
   *      R.mean([2, 7, 9]); //=> 6
   *      R.mean([]); //=> NaN
   */

  var mean =
  /*#__PURE__*/
  _curry1(function mean(list) {
    return sum(list) / list.length;
  });

  /**
   * Returns the median of the given list of numbers.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list
   * @return {Number}
   * @see R.mean
   * @example
   *
   *      R.median([2, 9, 7]); //=> 7
   *      R.median([7, 2, 10, 9]); //=> 8
   *      R.median([]); //=> NaN
   */

  var median =
  /*#__PURE__*/
  _curry1(function median(list) {
    var len = list.length;

    if (len === 0) {
      return NaN;
    }

    var width = 2 - len % 2;
    var idx = (len - width) / 2;
    return mean(Array.prototype.slice.call(list, 0).sort(function (a, b) {
      return a < b ? -1 : a > b ? 1 : 0;
    }).slice(idx, idx + width));
  });

  /**
   * Creates a new function that, when invoked, caches the result of calling `fn`
   * for a given argument set and returns the result. Subsequent calls to the
   * memoized `fn` with the same argument set will not result in an additional
   * call to `fn`; instead, the cached result for that set of arguments will be
   * returned.
   *
   * Care must be taken when implementing key generation to avoid key collision,
   * or if tracking references, memory leaks and mutating arguments.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Function
   * @sig (*... -> String) -> (*... -> a) -> (*... -> a)
   * @param {Function} fn The function to generate the cache key.
   * @param {Function} fn The function to memoize.
   * @return {Function} Memoized version of `fn`.
   * @example
   *
   *      let count = 0;
   *      const factorial = R.memoizeWith(Number, n => {
   *        count += 1;
   *        return R.product(R.range(1, n + 1));
   *      });
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      factorial(5); //=> 120
   *      count; //=> 1
   */

  var memoizeWith =
  /*#__PURE__*/
  _curry2(function memoizeWith(mFn, fn) {
    var cache = {};
    return _arity(fn.length, function () {
      var key = mFn.apply(this, arguments);

      if (!_has(key, cache)) {
        cache[key] = fn.apply(this, arguments);
      }

      return cache[key];
    });
  });

  /**
   * Creates one new object with the own properties from a list of objects.
   * If a key exists in more than one object, the value from the last
   * object it exists in will be used.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig [{k: v}] -> {k: v}
   * @param {Array} list An array of objects
   * @return {Object} A merged object.
   * @see R.reduce
   * @example
   *
   *      R.mergeAll([{foo:1},{bar:2},{baz:3}]); //=> {foo:1,bar:2,baz:3}
   *      R.mergeAll([{foo:1},{foo:2},{bar:2}]); //=> {foo:2,bar:2}
   * @symb R.mergeAll([{ x: 1 }, { y: 2 }, { z: 3 }]) = { x: 1, y: 2, z: 3 }
   */

  var mergeAll =
  /*#__PURE__*/
  _curry1(function mergeAll(list) {
    return _objectAssign$1.apply(null, [{}].concat(list));
  });

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the key
   * and the values associated with the key in each object, with the result being
   * used as the value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWithKey, R.merge, R.mergeWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeWithKey(concatValues,
   *                     { a: true, thing: 'foo', values: [10, 20] },
   *                     { b: true, thing: 'bar', values: [15, 35] });
   *      //=> { a: true, b: true, thing: 'bar', values: [10, 20, 15, 35] }
   * @symb R.mergeWithKey(f, { x: 1, y: 2 }, { y: 5, z: 3 }) = { x: 1, y: f('y', 2, 5), z: 3 }
   */

  var mergeWithKey =
  /*#__PURE__*/
  _curry3(function mergeWithKey(fn, l, r) {
    var result = {};
    var k;

    for (k in l) {
      if (_has(k, l)) {
        result[k] = _has(k, r) ? fn(k, l[k], r[k]) : l[k];
      }
    }

    for (k in r) {
      if (_has(k, r) && !_has(k, result)) {
        result[k] = r[k];
      }
    }

    return result;
  });

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to the key and associated values
   *   using the resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((String, a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWithKey, R.mergeDeepWith
   * @example
   *
   *      let concatValues = (k, l, r) => k == 'values' ? R.concat(l, r) : r
   *      R.mergeDeepWithKey(concatValues,
   *                         { a: true, c: { thing: 'foo', values: [10, 20] }},
   *                         { b: true, c: { thing: 'bar', values: [15, 35] }});
   *      //=> { a: true, b: true, c: { thing: 'bar', values: [10, 20, 15, 35] }}
   */

  var mergeDeepWithKey =
  /*#__PURE__*/
  _curry3(function mergeDeepWithKey(fn, lObj, rObj) {
    return mergeWithKey(function (k, lVal, rVal) {
      if (_isObject(lVal) && _isObject(rVal)) {
        return mergeDeepWithKey(fn, lVal, rVal);
      } else {
        return fn(k, lVal, rVal);
      }
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the first object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepRight, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepLeft({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                      { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 10, contact: { email: 'moo@example.com' }}
   */

  var mergeDeepLeft =
  /*#__PURE__*/
  _curry2(function mergeDeepLeft(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return lVal;
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects:
   * - and both values are objects, the two values will be recursively merged
   * - otherwise the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig {a} -> {a} -> {a}
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.merge, R.mergeDeepLeft, R.mergeDeepWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepRight({ name: 'fred', age: 10, contact: { email: 'moo@example.com' }},
   *                       { age: 40, contact: { email: 'baa@example.com' }});
   *      //=> { name: 'fred', age: 40, contact: { email: 'baa@example.com' }}
   */

  var mergeDeepRight =
  /*#__PURE__*/
  _curry2(function mergeDeepRight(lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return rVal;
    }, lObj, rObj);
  });

  /**
   * Creates a new object with the own properties of the two provided objects.
   * If a key exists in both objects:
   * - and both associated values are also objects then the values will be
   *   recursively merged.
   * - otherwise the provided function is applied to associated values using the
   *   resulting value as the new value associated with the key.
   * If a key only exists in one object, the value will be associated with the key
   * of the resulting object.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Object
   * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} lObj
   * @param {Object} rObj
   * @return {Object}
   * @see R.mergeWith, R.mergeDeepWithKey
   * @example
   *
   *      R.mergeDeepWith(R.concat,
   *                      { a: true, c: { values: [10, 20] }},
   *                      { b: true, c: { values: [15, 35] }});
   *      //=> { a: true, b: true, c: { values: [10, 20, 15, 35] }}
   */

  var mergeDeepWith =
  /*#__PURE__*/
  _curry3(function mergeDeepWith(fn, lObj, rObj) {
    return mergeDeepWithKey(function (k, lVal, rVal) {
      return fn(lVal, rVal);
    }, lObj, rObj);
  });

  /**
   * Create a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects,
   * the value from the first object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @sig {k: v} -> {k: v} -> {k: v}
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeRight, R.mergeDeepLeft, R.mergeWith, R.mergeWithKey
   * @example
   *
   *      R.mergeLeft({ 'age': 40 }, { 'name': 'fred', 'age': 10 });
   *      //=> { 'name': 'fred', 'age': 40 }
   *
   *      const resetToDefault = R.mergeLeft({x: 0});
   *      resetToDefault({x: 5, y: 2}); //=> {x: 0, y: 2}
   * @symb R.mergeLeft(a, b) = {...b, ...a}
   */

  var mergeLeft =
  /*#__PURE__*/
  _curry2(function mergeLeft(l, r) {
    return _objectAssign$1({}, r, l);
  });

  /**
   * Create a new object with the own properties of the first object merged with
   * the own properties of the second object. If a key exists in both objects,
   * the value from the second object will be used.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Object
   * @sig {k: v} -> {k: v} -> {k: v}
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeLeft, R.mergeDeepRight, R.mergeWith, R.mergeWithKey
   * @example
   *
   *      R.mergeRight({ 'name': 'fred', 'age': 10 }, { 'age': 40 });
   *      //=> { 'name': 'fred', 'age': 40 }
   *
   *      const withDefaults = R.mergeRight({x: 0, y: 0});
   *      withDefaults({y: 2}); //=> {x: 0, y: 2}
   * @symb R.mergeRight(a, b) = {...a, ...b}
   */

  var mergeRight =
  /*#__PURE__*/
  _curry2(function mergeRight(l, r) {
    return _objectAssign$1({}, l, r);
  });

  /**
   * Creates a new object with the own properties of the two provided objects. If
   * a key exists in both objects, the provided function is applied to the values
   * associated with the key in each object, with the result being used as the
   * value associated with the key in the returned object.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Object
   * @sig ((a, a) -> a) -> {a} -> {a} -> {a}
   * @param {Function} fn
   * @param {Object} l
   * @param {Object} r
   * @return {Object}
   * @see R.mergeDeepWith, R.merge, R.mergeWithKey
   * @example
   *
   *      R.mergeWith(R.concat,
   *                  { a: true, values: [10, 20] },
   *                  { b: true, values: [15, 35] });
   *      //=> { a: true, b: true, values: [10, 20, 15, 35] }
   */

  var mergeWith =
  /*#__PURE__*/
  _curry3(function mergeWith(fn, l, r) {
    return mergeWithKey(function (_, _l, _r) {
      return fn(_l, _r);
    }, l, r);
  });

  /**
   * Returns the smaller of its two arguments.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord a => a -> a -> a
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.minBy, R.max
   * @example
   *
   *      R.min(789, 123); //=> 123
   *      R.min('a', 'b'); //=> 'a'
   */

  var min =
  /*#__PURE__*/
  _curry2(function min(a, b) {
    return b < a ? b : a;
  });

  /**
   * Takes a function and two values, and returns whichever value produces the
   * smaller result when passed to the provided function.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Relation
   * @sig Ord b => (a -> b) -> a -> a -> a
   * @param {Function} f
   * @param {*} a
   * @param {*} b
   * @return {*}
   * @see R.min, R.maxBy
   * @example
   *
   *      //  square :: Number -> Number
   *      const square = n => n * n;
   *
   *      R.minBy(square, -3, 2); //=> 2
   *
   *      R.reduce(R.minBy(square), Infinity, [3, -5, 4, 1, -2]); //=> 1
   *      R.reduce(R.minBy(square), Infinity, []); //=> Infinity
   */

  var minBy =
  /*#__PURE__*/
  _curry3(function minBy(f, a, b) {
    return f(b) < f(a) ? b : a;
  });

  /**
   * Makes a shallow clone of an object, applying the given fn to the specified
   * property with the given value. Note that this copies and flattens prototype
   * properties onto the new object as well. All non-primitive properties are
   * copied by reference.
   *
   * @private
   * @param {String|Number} prop The property name to set
   * @param {Function} fn The function to apply to the property
   * @param {Object|Array} obj The object to clone
   * @return {Object|Array} A new object equivalent to the original except for the changed property.
   */

  function _modify(prop, fn, obj) {
    if (_isInteger(prop) && _isArray(obj)) {
      var arr = [].concat(obj);
      arr[prop] = fn(arr[prop]);
      return arr;
    }

    var result = {};

    for (var p in obj) {
      result[p] = obj[p];
    }

    result[prop] = fn(result[prop]);
    return result;
  }

  /**
   * Creates a shallow clone of the passed object by applying an `fn` function
   * to the value at the given path.
   *
   * The function will not be invoked, and the object will not change
   * if its corresponding path does not exist in the object.
   * All non-primitive properties are copied to the new object by reference.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig [Idx] -> (v -> v) -> {k: v} -> {k: v}
   * @param {Array} path The path to be modified.
   * @param {Function} fn The function to apply to the path.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      const person = {name: 'James', address: { zipCode: '90216' }};
   *      R.modifyPath(['address', 'zipCode'], R.reverse, person); //=> {name: 'James', address: { zipCode: '61209' }}
   *
   *      // Can handle arrays too
   *      const person = {name: 'James', addresses: [{ zipCode: '90216' }]};
   *      R.modifyPath(['addresses', 0, 'zipCode'], R.reverse, person); //=> {name: 'James', addresses: [{ zipCode: '61209' }]}
   */

  var modifyPath =
  /*#__PURE__*/
  _curry3(function modifyPath(path, fn, object) {
    if (!_isObject(object) && !_isArray(object) || path.length === 0) {
      return object;
    }

    var idx = path[0];

    if (!_has(idx, object)) {
      return object;
    }

    if (path.length === 1) {
      return _modify(idx, fn, object);
    }

    var val = modifyPath(Array.prototype.slice.call(path, 1), fn, object[idx]);

    if (val === object[idx]) {
      return object;
    }

    return _assoc(idx, val, object);
  });

  /**
   * Creates a copy of the passed object by applying an `fn` function to the given `prop` property.
   *
   * The function will not be invoked, and the object will not change
   * if its corresponding property does not exist in the object.
   * All non-primitive properties are copied to the new object by reference.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig Idx -> (v -> v) -> {k: v} -> {k: v}
   * @param {String|Number} prop The property to be modified.
   * @param {Function} fn The function to apply to the property.
   * @param {Object} object The object to be transformed.
   * @return {Object} The transformed object.
   * @example
   *
   *      const person = {name: 'James', age: 20, pets: ['dog', 'cat']};
   *      R.modify('age', R.add(1), person); //=> {name: 'James', age: 21, pets: ['dog', 'cat']}
   *      R.modify('pets', R.append('turtle'), person); //=> {name: 'James', age: 20, pets: ['dog', 'cat', 'turtle']}
   */

  var modify =
  /*#__PURE__*/
  _curry3(function modify(prop, fn, object) {
    return modifyPath([prop], fn, object);
  });

  /**
   * Divides the first parameter by the second and returns the remainder. Note
   * that this function preserves the JavaScript-style behavior for modulo. For
   * mathematical modulo see [`mathMod`](#mathMod).
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The value to the divide.
   * @param {Number} b The pseudo-modulus
   * @return {Number} The result of `b % a`.
   * @see R.mathMod
   * @example
   *
   *      R.modulo(17, 3); //=> 2
   *      // JS behavior:
   *      R.modulo(-17, 3); //=> -2
   *      R.modulo(17, -3); //=> 2
   *
   *      const isOdd = R.modulo(R.__, 2);
   *      isOdd(42); //=> 0
   *      isOdd(21); //=> 1
   */

  var modulo =
  /*#__PURE__*/
  _curry2(function modulo(a, b) {
    return a % b;
  });

  /**
   * Move an item, at index `from`, to index `to`, in a list of elements.
   * A new list will be created containing the new elements order.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category List
   * @sig Number -> Number -> [a] -> [a]
   * @param {Number} from The source index
   * @param {Number} to The destination index
   * @param {Array} list The list which will serve to realise the move
   * @return {Array} The new list reordered
   * @example
   *
   *      R.move(0, 2, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['b', 'c', 'a', 'd', 'e', 'f']
   *      R.move(-1, 0, ['a', 'b', 'c', 'd', 'e', 'f']); //=> ['f', 'a', 'b', 'c', 'd', 'e'] list rotation
   */

  var move =
  /*#__PURE__*/
  _curry3(function (from, to, list) {
    var length = list.length;
    var result = list.slice();
    var positiveFrom = from < 0 ? length + from : from;
    var positiveTo = to < 0 ? length + to : to;
    var item = result.splice(positiveFrom, 1);
    return positiveFrom < 0 || positiveFrom >= list.length || positiveTo < 0 || positiveTo >= list.length ? list : [].concat(result.slice(0, positiveTo)).concat(item).concat(result.slice(positiveTo, list.length));
  });

  /**
   * Multiplies two numbers. Equivalent to `a * b` but curried.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a * b`.
   * @see R.divide
   * @example
   *
   *      const double = R.multiply(2);
   *      const triple = R.multiply(3);
   *      double(3);       //=>  6
   *      triple(4);       //=> 12
   *      R.multiply(2, 5);  //=> 10
   */

  var multiply =
  /*#__PURE__*/
  _curry2(function multiply(a, b) {
    return a * b;
  });

  /**
   * Takes a function `f` and an object, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the object
   * provided initially merged deeply (right) with the object provided as an argument to `g`.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Function
   * @sig (({ a, b, c, ..., n }) -> x) -> { a, b, c, ...} -> ({ d, e, f, ..., n } -> x)
   * @param {Function} f
   * @param {Object} props
   * @return {Function}
   * @see R.partial, R.partialRight, R.curry, R.mergeDeepRight
   * @example
   *
   *      const multiply2 = ({ a, b }) => a * b;
   *      const double = R.partialObject(multiply2, { a: 2 });
   *      double({ b: 2 }); //=> 4
   *
   *      const greet = ({ salutation, title, firstName, lastName }) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      const sayHello = R.partialObject(greet, { salutation: 'Hello' });
   *      const sayHelloToMs = R.partialObject(sayHello, { title: 'Ms.' });
   *      sayHelloToMs({ firstName: 'Jane', lastName: 'Jones' }); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partialObject(f, { a, b })({ c, d }) = f({ a, b, c, d })
   */

  var partialObject = /*#__PURE__*/
  _curry2((f, o) => props => f.call(undefined, mergeDeepRight(o, props)));

  /**
   * Negates its argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Math
   * @sig Number -> Number
   * @param {Number} n
   * @return {Number}
   * @example
   *
   *      R.negate(42); //=> -42
   */

  var negate =
  /*#__PURE__*/
  _curry1(function negate(n) {
    return -n;
  });

  /**
   * Returns `true` if no elements of the list match the predicate, `false`
   * otherwise.
   *
   * Dispatches to the `all` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> Boolean
   * @param {Function} fn The predicate function.
   * @param {Array} list The array to consider.
   * @return {Boolean} `true` if the predicate is not satisfied by every element, `false` otherwise.
   * @see R.all, R.any
   * @example
   *
   *      const isEven = n => n % 2 === 0;
   *      const isOdd = n => n % 2 !== 0;
   *
   *      R.none(isEven, [1, 3, 5, 7, 9, 11]); //=> true
   *      R.none(isOdd, [1, 3, 5, 7, 8, 11]); //=> false
   */

  var none =
  /*#__PURE__*/
  _curry2(function none(fn, input) {
    return all(_complement(fn), input);
  });

  /**
   * Returns a function which returns its nth argument.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category Function
   * @sig Number -> *... -> *
   * @param {Number} n
   * @return {Function}
   * @example
   *
   *      R.nthArg(1)('a', 'b', 'c'); //=> 'b'
   *      R.nthArg(-1)('a', 'b', 'c'); //=> 'c'
   * @symb R.nthArg(-1)(a, b, c) = c
   * @symb R.nthArg(0)(a, b, c) = a
   * @symb R.nthArg(1)(a, b, c) = b
   */

  var nthArg =
  /*#__PURE__*/
  _curry1(function nthArg(n) {
    var arity = n < 0 ? 1 : n + 1;
    return curryN(arity, function () {
      return nth(n, arguments);
    });
  });

  /**
   * `o` is a curried composition function that returns a unary function.
   * Like [`compose`](#compose), `o` performs right-to-left function composition.
   * Unlike [`compose`](#compose), the rightmost function passed to `o` will be
   * invoked with only one argument. Also, unlike [`compose`](#compose), `o` is
   * limited to accepting only 2 unary functions. The name o was chosen because
   * of its similarity to the mathematical composition operator .
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category Function
   * @sig (b -> c) -> (a -> b) -> a -> c
   * @param {Function} f
   * @param {Function} g
   * @return {Function}
   * @see R.compose, R.pipe
   * @example
   *
   *      const classyGreeting = name => "The name's " + name.last + ", " + name.first + " " + name.last
   *      const yellGreeting = R.o(R.toUpper, classyGreeting);
   *      yellGreeting({first: 'James', last: 'Bond'}); //=> "THE NAME'S BOND, JAMES BOND"
   *
   *      R.o(R.multiply(10), R.add(10))(-4) //=> 60
   *
   * @symb R.o(f, g, x) = f(g(x))
   */

  var o =
  /*#__PURE__*/
  _curry3(function o(f, g, x) {
    return f(g(x));
  });

  function _of(x) {
    return [x];
  }

  /**
   * Returns a singleton array containing the value provided.
   *
   * Note this `of` is different from the ES6 `of`; See
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/of
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category Function
   * @sig a -> [a]
   * @param {*} x any value
   * @return {Array} An array wrapping `x`.
   * @example
   *
   *      R.of(null); //=> [null]
   *      R.of([42]); //=> [[42]]
   */

  var of =
  /*#__PURE__*/
  _curry1(_of);

  /**
   * Returns a partial copy of an object omitting the keys specified.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [String] -> {String: *} -> {String: *}
   * @param {Array} names an array of String property names to omit from the new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with properties from `names` not on it.
   * @see R.pick
   * @example
   *
   *      R.omit(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {b: 2, c: 3}
   */

  var omit =
  /*#__PURE__*/
  _curry2(function omit(names, obj) {
    var result = {};
    var index = {};
    var idx = 0;
    var len = names.length;

    while (idx < len) {
      index[names[idx]] = 1;
      idx += 1;
    }

    for (var prop in obj) {
      if (!index.hasOwnProperty(prop)) {
        result[prop] = obj[prop];
      }
    }

    return result;
  });

  /**
   * Takes a binary function `f`, a unary function `g`, and two values.
   * Applies `g` to each value, then applies the result of each to `f`.
   *
   * Also known as the P combinator.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Function
   * @sig ((a, a) -> b) -> (c -> a) -> c -> c -> b
   * @param {Function} f a binary function
   * @param {Function} g a unary function
   * @param {any} a any value
   * @param {any} b any value
   * @return {any} The result of `f`
   * @example
   *
   *      const eqBy = R.on((a, b) => a === b);
   *      eqBy(R.prop('a'), {b:0, a:1}, {a:1}) //=> true;
   *
   *      const containsInsensitive = R.on(R.contains, R.toLower);
   *      containsInsensitive('o', 'FOO'); //=> true
   * @symb R.on(f, g, a, b) = f(g(a), g(b))
   */

  var on =
  /*#__PURE__*/
  _curryN(4, [], function on(f, g, a, b) {
    return f(g(a), g(b));
  });

  /**
   * Accepts a function `fn` and returns a function that guards invocation of
   * `fn` such that `fn` can only ever be called once, no matter how many times
   * the returned function is invoked. The first value calculated is returned in
   * subsequent invocations.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a... -> b) -> (a... -> b)
   * @param {Function} fn The function to wrap in a call-only-once wrapper.
   * @return {Function} The wrapped function.
   * @example
   *
   *      const addOneOnce = R.once(x => x + 1);
   *      addOneOnce(10); //=> 11
   *      addOneOnce(addOneOnce(50)); //=> 11
   */

  var once =
  /*#__PURE__*/
  _curry1(function once(fn) {
    var called = false;
    var result;
    return _arity(fn.length, function () {
      if (called) {
        return result;
      }

      called = true;
      result = fn.apply(this, arguments);
      return result;
    });
  });

  function _assertPromise(name, p) {
    if (p == null || !_isFunction(p.then)) {
      throw new TypeError('`' + name + '` expected a Promise, received ' + _toString(p, []));
    }
  }

  /**
   * Returns the result of applying the onFailure function to the value inside
   * a failed promise. This is useful for handling rejected promises
   * inside function compositions.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig (e -> b) -> (Promise e a) -> (Promise e b)
   * @sig (e -> (Promise f b)) -> (Promise e a) -> (Promise f b)
   * @param {Function} onFailure The function to apply. Can return a value or a promise of a value.
   * @param {Promise} p
   * @return {Promise} The result of calling `p.then(null, onFailure)`
   * @see R.andThen
   * @example
   *
   *      const failedFetch = id => Promise.reject('bad ID');
   *      const useDefault = () => ({ firstName: 'Bob', lastName: 'Loblaw' });
   *
   *      //recoverFromFailure :: String -> Promise ({ firstName, lastName })
   *      const recoverFromFailure = R.pipe(
   *        failedFetch,
   *        R.otherwise(useDefault),
   *        R.andThen(R.pick(['firstName', 'lastName'])),
   *      );
   *      recoverFromFailure(12345).then(console.log);
   */

  var otherwise =
  /*#__PURE__*/
  _curry2(function otherwise(f, p) {
    _assertPromise('otherwise', p);

    return p.then(null, f);
  });

  // transforms the held value with the provided function.

  var Identity = function (x) {
    return {
      value: x,
      map: function (f) {
        return Identity(f(x));
      }
    };
  };
  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the result of applying the given function to
   * the focused value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> (a -> a) -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.view, R.set, R.lens, R.lensIndex, R.lensProp, R.lensPath
   * @example
   *
   *      const headLens = R.lensIndex(0);
   *
   *      R.over(headLens, R.toUpper, ['foo', 'bar', 'baz']); //=> ['FOO', 'bar', 'baz']
   */


  var over =
  /*#__PURE__*/
  _curry3(function over(lens, f, x) {
    // The value returned by the getter function is first transformed with `f`,
    // then set as the value of an `Identity`. This is then mapped over with the
    // setter function of the lens.
    return lens(function (y) {
      return Identity(f(y));
    })(x).value;
  });

  /**
   * Takes two arguments, `fst` and `snd`, and returns `[fst, snd]`.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category List
   * @sig a -> b -> (a,b)
   * @param {*} fst
   * @param {*} snd
   * @return {Array}
   * @see R.objOf, R.of
   * @example
   *
   *      R.pair('foo', 'bar'); //=> ['foo', 'bar']
   */

  var pair =
  /*#__PURE__*/
  _curry2(function pair(fst, snd) {
    return [fst, snd];
  });

  function _createPartialApplicator(concat) {
    return _curry2(function (fn, args) {
      return _arity(Math.max(0, fn.length - args.length), function () {
        return fn.apply(this, concat(args, arguments));
      });
    });
  }

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided initially followed by the arguments provided to `g`.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [a, b, c, ...] -> ((d, e, f, ..., n) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partialRight, R.curry
   * @example
   *
   *      const multiply2 = (a, b) => a * b;
   *      const double = R.partial(multiply2, [2]);
   *      double(3); //=> 6
   *
   *      const greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      const sayHello = R.partial(greet, ['Hello']);
   *      const sayHelloToMs = R.partial(sayHello, ['Ms.']);
   *      sayHelloToMs('Jane', 'Jones'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partial(f, [a, b])(c, d) = f(a, b, c, d)
   */

  var partial =
  /*#__PURE__*/
  _createPartialApplicator(_concat);

  /**
   * Takes a function `f` and a list of arguments, and returns a function `g`.
   * When applied, `g` returns the result of applying `f` to the arguments
   * provided to `g` followed by the arguments provided initially.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category Function
   * @sig ((a, b, c, ..., n) -> x) -> [d, e, f, ..., n] -> ((a, b, c, ...) -> x)
   * @param {Function} f
   * @param {Array} args
   * @return {Function}
   * @see R.partial
   * @example
   *
   *      const greet = (salutation, title, firstName, lastName) =>
   *        salutation + ', ' + title + ' ' + firstName + ' ' + lastName + '!';
   *
   *      const greetMsJaneJones = R.partialRight(greet, ['Ms.', 'Jane', 'Jones']);
   *
   *      greetMsJaneJones('Hello'); //=> 'Hello, Ms. Jane Jones!'
   * @symb R.partialRight(f, [a, b])(c, d) = f(c, d, a, b)
   */

  var partialRight =
  /*#__PURE__*/
  _createPartialApplicator(
  /*#__PURE__*/
  flip(_concat));

  /**
   * Takes a predicate and a list or other `Filterable` object and returns the
   * pair of filterable objects of the same type of elements which do and do not
   * satisfy, the predicate, respectively. Filterable objects include plain objects or any object
   * that has a filter method such as `Array`.
   *
   * @func
   * @memberOf R
   * @since v0.1.4
   * @category List
   * @sig Filterable f => (a -> Boolean) -> f a -> [f a, f a]
   * @param {Function} pred A predicate to determine which side the element belongs to.
   * @param {Array} filterable the list (or other filterable) to partition.
   * @return {Array} An array, containing first the subset of elements that satisfy the
   *         predicate, and second the subset of elements that do not satisfy.
   * @see R.filter, R.reject
   * @example
   *
   *      R.partition(R.includes('s'), ['sss', 'ttt', 'foo', 'bars']);
   *      // => [ [ 'sss', 'bars' ],  [ 'ttt', 'foo' ] ]
   *
   *      R.partition(R.includes('s'), { a: 'sss', b: 'ttt', foo: 'bars' });
   *      // => [ { a: 'sss', foo: 'bars' }, { b: 'ttt' }  ]
   */

  var partition =
  /*#__PURE__*/
  juxt([filter, reject$1]);

  /**
   * Determines whether a nested path on an object has a specific value, in
   * [`R.equals`](#equals) terms. Most likely used to filter a list.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category Relation
   * @typedefn Idx = String | Int | Symbol
   * @sig [Idx] -> a -> {a} -> Boolean
   * @param {Array} path The path of the nested property to use
   * @param {*} val The value to compare the nested property with
   * @param {Object} obj The object to check the nested property in
   * @return {Boolean} `true` if the value equals the nested object property,
   *         `false` otherwise.
   * @example
   *
   *      const user1 = { address: { zipCode: 90210 } };
   *      const user2 = { address: { zipCode: 55555 } };
   *      const user3 = { name: 'Bob' };
   *      const users = [ user1, user2, user3 ];
   *      const isFamous = R.pathEq(['address', 'zipCode'], 90210);
   *      R.filter(isFamous, users); //=> [ user1 ]
   */

  var pathEq =
  /*#__PURE__*/
  _curry3(function pathEq(_path, val, obj) {
    return equals(path(_path, obj), val);
  });

  /**
   * If the given, non-null object has a value at the given path, returns the
   * value at that path. Otherwise returns the provided default value.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Object
   * @typedefn Idx = String | Int | Symbol
   * @sig a -> [Idx] -> {a} -> a
   * @param {*} d The default value.
   * @param {Array} p The path to use.
   * @param {Object} obj The object to retrieve the nested property from.
   * @return {*} The data at `path` of the supplied object or the default value.
   * @example
   *
   *      R.pathOr('N/A', ['a', 'b'], {a: {b: 2}}); //=> 2
   *      R.pathOr('N/A', ['a', 'b'], {c: {b: 2}}); //=> "N/A"
   */

  var pathOr =
  /*#__PURE__*/
  _curry3(function pathOr(d, p, obj) {
    return defaultTo(d, path(p, obj));
  });

  /**
   * Returns `true` if the specified object property at given path satisfies the
   * given predicate; `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Logic
   * @typedefn Idx = String | Int | Symbol
   * @sig (a -> Boolean) -> [Idx] -> {a} -> Boolean
   * @param {Function} pred
   * @param {Array} propPath
   * @param {*} obj
   * @return {Boolean}
   * @see R.propSatisfies, R.path
   * @example
   *
   *      R.pathSatisfies(y => y > 0, ['x', 'y'], {x: {y: 2}}); //=> true
   *      R.pathSatisfies(R.is(Object), [], {x: {y: 2}}); //=> true
   */

  var pathSatisfies =
  /*#__PURE__*/
  _curry3(function pathSatisfies(pred, propPath, obj) {
    return pred(path(propPath, obj));
  });

  /**
   * Returns a partial copy of an object containing only the keys specified. If
   * the key does not exist, the property is ignored.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.omit, R.props
   * @example
   *
   *      R.pick(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pick(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1}
   */

  var pick =
  /*#__PURE__*/
  _curry2(function pick(names, obj) {
    var result = {};
    var idx = 0;

    while (idx < names.length) {
      if (names[idx] in obj) {
        result[names[idx]] = obj[names[idx]];
      }

      idx += 1;
    }

    return result;
  });

  /**
   * Similar to `pick` except that this one includes a `key: undefined` pair for
   * properties that don't exist.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> {k: v}
   * @param {Array} names an array of String property names to copy onto a new object
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties from `names` on it.
   * @see R.pick
   * @example
   *
   *      R.pickAll(['a', 'd'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, d: 4}
   *      R.pickAll(['a', 'e', 'f'], {a: 1, b: 2, c: 3, d: 4}); //=> {a: 1, e: undefined, f: undefined}
   */

  var pickAll =
  /*#__PURE__*/
  _curry2(function pickAll(names, obj) {
    var result = {};
    var idx = 0;
    var len = names.length;

    while (idx < len) {
      var name = names[idx];
      result[name] = obj[name];
      idx += 1;
    }

    return result;
  });

  /**
   * Returns a partial copy of an object containing only the keys that satisfy
   * the supplied predicate.
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Object
   * @sig ((v, k) -> Boolean) -> {k: v} -> {k: v}
   * @param {Function} pred A predicate to determine whether or not a key
   *        should be included on the output object.
   * @param {Object} obj The object to copy from
   * @return {Object} A new object with only properties that satisfy `pred`
   *         on it.
   * @see R.pick, R.filter
   * @example
   *
   *      const isUpperCase = (val, key) => key.toUpperCase() === key;
   *      R.pickBy(isUpperCase, {a: 1, b: 2, A: 3, B: 4}); //=> {A: 3, B: 4}
   */

  var pickBy =
  /*#__PURE__*/
  _curry2(function pickBy(test, obj) {
    var result = {};

    for (var prop in obj) {
      if (test(obj[prop], prop, obj)) {
        result[prop] = obj[prop];
      }
    }

    return result;
  });

  /**
   * Returns a new list with the given element at the front, followed by the
   * contents of the list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig a -> [a] -> [a]
   * @param {*} el The item to add to the head of the output list.
   * @param {Array} list The array to add to the tail of the output list.
   * @return {Array} A new array.
   * @see R.append
   * @example
   *
   *      R.prepend('fee', ['fi', 'fo', 'fum']); //=> ['fee', 'fi', 'fo', 'fum']
   */

  var prepend =
  /*#__PURE__*/
  _curry2(function prepend(el, list) {
    return _concat([el], list);
  });

  /**
   * Multiplies together all the elements of a list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig [Number] -> Number
   * @param {Array} list An array of numbers
   * @return {Number} The product of all the numbers in the list.
   * @see R.reduce
   * @example
   *
   *      R.product([2,4,6,8,100,1]); //=> 38400
   */

  var product =
  /*#__PURE__*/
  reduce(multiply, 1);

  /**
   * Accepts a function `fn` and a list of transformer functions and returns a
   * new curried function. When the new function is invoked, it calls the
   * function `fn` with parameters consisting of the result of calling each
   * supplied handler on successive arguments to the new function.
   *
   * If more arguments are passed to the returned function than transformer
   * functions, those arguments are passed directly to `fn` as additional
   * parameters. If you expect additional arguments that don't need to be
   * transformed, although you can ignore them, it's best to pass an identity
   * function so that the new function reports the correct arity.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig ((x1, x2, ...) -> z) -> [(a -> x1), (b -> x2), ...] -> (a -> b -> ... -> z)
   * @param {Function} fn The function to wrap.
   * @param {Array} transformers A list of transformer functions
   * @return {Function} The wrapped function.
   * @see R.converge
   * @example
   *
   *      R.useWith(Math.pow, [R.identity, R.identity])(3, 4); //=> 81
   *      R.useWith(Math.pow, [R.identity, R.identity])(3)(4); //=> 81
   *      R.useWith(Math.pow, [R.dec, R.inc])(3, 4); //=> 32
   *      R.useWith(Math.pow, [R.dec, R.inc])(3)(4); //=> 32
   * @symb R.useWith(f, [g, h])(a, b) = f(g(a), h(b))
   */

  var useWith =
  /*#__PURE__*/
  _curry2(function useWith(fn, transformers) {
    return curryN(transformers.length, function () {
      var args = [];
      var idx = 0;

      while (idx < transformers.length) {
        args.push(transformers[idx].call(this, arguments[idx]));
        idx += 1;
      }

      return fn.apply(this, args.concat(Array.prototype.slice.call(arguments, transformers.length)));
    });
  });

  /**
   * Reasonable analog to SQL `select` statement.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @category Relation
   * @sig [k] -> [{k: v}] -> [{k: v}]
   * @param {Array} props The property names to project
   * @param {Array} objs The objects to query
   * @return {Array} An array of objects with just the `props` properties.
   * @see R.pluck, R.props, R.prop
   * @example
   *
   *      const abby = {name: 'Abby', age: 7, hair: 'blond', grade: 2};
   *      const fred = {name: 'Fred', age: 12, hair: 'brown', grade: 7};
   *      const kids = [abby, fred];
   *      R.project(['name', 'grade'], kids); //=> [{name: 'Abby', grade: 2}, {name: 'Fred', grade: 7}]
   */

  var project =
  /*#__PURE__*/
  useWith(_map, [pickAll, identity]); // passing `identity` gives correct arity

  function _promap(f, g, profunctor) {
    return function (x) {
      return g(profunctor(f(x)));
    };
  }

  var XPromap =
  /*#__PURE__*/
  function () {
    function XPromap(f, g, xf) {
      this.xf = xf;
      this.f = f;
      this.g = g;
    }

    XPromap.prototype['@@transducer/init'] = _xfBase.init;
    XPromap.prototype['@@transducer/result'] = _xfBase.result;

    XPromap.prototype['@@transducer/step'] = function (result, input) {
      return this.xf['@@transducer/step'](result, _promap(this.f, this.g, input));
    };

    return XPromap;
  }();

  var _xpromap =
  /*#__PURE__*/
  _curry3(function _xpromap(f, g, xf) {
    return new XPromap(f, g, xf);
  });

  /**
   * Takes two functions as pre- and post- processors respectively for a third function,
   * i.e. `promap(f, g, h)(x) === g(h(f(x)))`.
   *
   * Dispatches to the `promap` method of the third argument, if present,
   * according to the [FantasyLand Profunctor spec](https://github.com/fantasyland/fantasy-land#profunctor).
   *
   * Acts as a transducer if a transformer is given in profunctor position.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Function
   * @sig (a -> b) -> (c -> d) -> (b -> c) -> (a -> d)
   * @sig Profunctor p => (a -> b) -> (c -> d) -> p b c -> p a d
   * @param {Function} f The preprocessor function, a -> b
   * @param {Function} g The postprocessor function, c -> d
   * @param {Profunctor} profunctor The profunctor instance to be promapped, e.g. b -> c
   * @return {Profunctor} The new profunctor instance, e.g. a -> d
   * @see R.transduce
   * @example
   *
   *      const decodeChar = R.promap(s => s.charCodeAt(), String.fromCharCode, R.add(-8))
   *      const decodeString = R.promap(R.split(''), R.join(''), R.map(decodeChar))
   *      decodeString("ziuli") //=> "ramda"
   *
   * @symb R.promap(f, g, h) = x => g(h(f(x)))
   * @symb R.promap(f, g, profunctor) = profunctor.promap(f, g)
   */

  var promap =
  /*#__PURE__*/
  _curry3(
  /*#__PURE__*/
  _dispatchable(['fantasy-land/promap', 'promap'], _xpromap, _promap));

  /**
   * Returns `true` if the specified object property is equal, in
   * [`R.equals`](#equals) terms, to the given value; `false` otherwise.
   * You can test multiple properties with [`R.whereEq`](#whereEq).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig String -> a -> Object -> Boolean
   * @param {String} name
   * @param {*} val
   * @param {*} obj
   * @return {Boolean}
   * @see R.whereEq, R.propSatisfies, R.equals
   * @example
   *
   *      const abby = {name: 'Abby', age: 7, hair: 'blond'};
   *      const fred = {name: 'Fred', age: 12, hair: 'brown'};
   *      const rusty = {name: 'Rusty', age: 10, hair: 'brown'};
   *      const alois = {name: 'Alois', age: 15, disposition: 'surly'};
   *      const kids = [abby, fred, rusty, alois];
   *      const hasBrownHair = R.propEq('hair', 'brown');
   *      R.filter(hasBrownHair, kids); //=> [fred, rusty]
   */

  var propEq =
  /*#__PURE__*/
  _curry3(function propEq(name, val, obj) {
    return equals(val, prop(name, obj));
  });

  /**
   * Returns `true` if the specified object property is of the given type;
   * `false` otherwise.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Type
   * @sig Type -> String -> Object -> Boolean
   * @param {Function} type
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.is, R.propSatisfies
   * @example
   *
   *      R.propIs(Number, 'x', {x: 1, y: 2});  //=> true
   *      R.propIs(Number, 'x', {x: 'foo'});    //=> false
   *      R.propIs(Number, 'x', {});            //=> false
   */

  var propIs =
  /*#__PURE__*/
  _curry3(function propIs(type, name, obj) {
    return is(type, prop(name, obj));
  });

  /**
   * Return the specified property of the given non-null object if the property
   * is present and it's value is not `null`, `undefined` or `NaN`.
   *
   * Otherwise the first argument is returned.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category Object
   * @sig a -> String -> Object -> a
   * @param {*} val The default value.
   * @param {String} p The name of the property to return.
   * @param {Object} obj The object to query.
   * @return {*} The value of given property of the supplied object or the default value.
   * @example
   *
   *      const alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      const favorite = R.prop('favoriteLibrary');
   *      const favoriteWithDefault = R.propOr('Ramda', 'favoriteLibrary');
   *
   *      favorite(alice);  //=> undefined
   *      favoriteWithDefault(alice);  //=> 'Ramda'
   */

  var propOr =
  /*#__PURE__*/
  _curry3(function propOr(val, p, obj) {
    return defaultTo(val, prop(p, obj));
  });

  /**
   * Returns `true` if the specified object property satisfies the given
   * predicate; `false` otherwise. You can test multiple properties with
   * [`R.where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Logic
   * @sig (a -> Boolean) -> String -> {String: a} -> Boolean
   * @param {Function} pred
   * @param {String} name
   * @param {*} obj
   * @return {Boolean}
   * @see R.where, R.propEq, R.propIs
   * @example
   *
   *      R.propSatisfies(x => x > 0, 'x', {x: 1, y: 2}); //=> true
   */

  var propSatisfies =
  /*#__PURE__*/
  _curry3(function propSatisfies(pred, name, obj) {
    return pred(prop(name, obj));
  });

  /**
   * Acts as multiple `prop`: array of keys in, array of values out. Preserves
   * order.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Object
   * @sig [k] -> {k: v} -> [v]
   * @param {Array} ps The property names to fetch
   * @param {Object} obj The object to query
   * @return {Array} The corresponding values or partially applied function.
   * @see R.prop, R.pluck, R.project
   * @example
   *
   *      R.props(['x', 'y'], {x: 1, y: 2}); //=> [1, 2]
   *      R.props(['c', 'a', 'b'], {b: 2, a: 1}); //=> [undefined, 1, 2]
   *
   *      const fullName = R.compose(R.join(' '), R.props(['first', 'last']));
   *      fullName({last: 'Bullet-Tooth', age: 33, first: 'Tony'}); //=> 'Tony Bullet-Tooth'
   */

  var props =
  /*#__PURE__*/
  _curry2(function props(ps, obj) {
    return ps.map(function (p) {
      return path([p], obj);
    });
  });

  /**
   * Returns a list of numbers from `from` (inclusive) to `to` (exclusive).
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig Number -> Number -> [Number]
   * @param {Number} from The first number in the list.
   * @param {Number} to One more than the last number in the list.
   * @return {Array} The list of numbers in the set `[a, b)`.
   * @example
   *
   *      R.range(1, 5);    //=> [1, 2, 3, 4]
   *      R.range(50, 53);  //=> [50, 51, 52]
   */

  var range =
  /*#__PURE__*/
  _curry2(function range(from, to) {
    if (!(_isNumber(from) && _isNumber(to))) {
      throw new TypeError('Both arguments to range must be numbers');
    }

    var result = [];
    var n = from;

    while (n < to) {
      result.push(n);
      n += 1;
    }

    return result;
  });

  /**
   * Returns a single item by iterating through the list, successively calling
   * the iterator function and passing it an accumulator value and the current
   * value from the array, and then passing the result to the next call.
   *
   * Similar to [`reduce`](#reduce), except moves through the input list from the
   * right to the left.
   *
   * The iterator function receives two values: *(value, acc)*, while the arguments'
   * order of `reduce`'s iterator function is *(acc, value)*. `reduceRight` may use [`reduced`](#reduced)
   * to short circuit the iteration.
   *
   * Note: `R.reduceRight` does not skip deleted or unassigned indices (sparse
   * arrays), unlike the native `Array.prototype.reduceRight` method. For more details
   * on this behavior, see:
   * https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/reduceRight#Description
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> b) -> b -> [a] -> b
   * @param {Function} fn The iterator function. Receives two values, the current element from the array
   *        and the accumulator.
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.addIndex, R.reduced
   * @example
   *
   *      R.reduceRight(R.subtract, 0, [1, 2, 3, 4]) // => (1 - (2 - (3 - (4 - 0)))) = -2
   *      //    -               -2
   *      //   / \              / \
   *      //  1   -            1   3
   *      //     / \              / \
   *      //    2   -     ==>    2  -1
   *      //       / \              / \
   *      //      3   -            3   4
   *      //         / \              / \
   *      //        4   0            4   0
   *
   * @symb R.reduceRight(f, a, [b, c, d]) = f(b, f(c, f(d, a)))
   */

  var reduceRight =
  /*#__PURE__*/
  _curry3(function reduceRight(fn, acc, list) {
    var idx = list.length - 1;

    while (idx >= 0) {
      acc = fn(list[idx], acc);

      if (acc && acc['@@transducer/reduced']) {
        acc = acc['@@transducer/value'];
        break;
      }

      idx -= 1;
    }

    return acc;
  });

  /**
   * Like [`reduce`](#reduce), `reduceWhile` returns a single item by iterating
   * through the list, successively calling the iterator function. `reduceWhile`
   * also takes a predicate that is evaluated before each step. If the predicate
   * returns `false`, it "short-circuits" the iteration and returns the current
   * value of the accumulator. `reduceWhile` may alternatively be short-circuited
   * via [`reduced`](#reduced).
   *
   * @func
   * @memberOf R
   * @since v0.22.0
   * @category List
   * @sig ((a, b) -> Boolean) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} pred The predicate. It is passed the accumulator and the
   *        current element.
   * @param {Function} fn The iterator function. Receives two values, the
   *        accumulator and the current element.
   * @param {*} a The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced
   * @example
   *
   *      const isOdd = (acc, x) => x % 2 !== 0;
   *      const xs = [1, 3, 5, 60, 777, 800];
   *      R.reduceWhile(isOdd, R.add, 0, xs); //=> 9
   *
   *      const ys = [2, 4, 6]
   *      R.reduceWhile(isOdd, R.add, 111, ys); //=> 111
   */

  var reduceWhile =
  /*#__PURE__*/
  _curryN(4, [], function _reduceWhile(pred, fn, a, list) {
    return _reduce(function (acc, x) {
      return pred(acc, x) ? fn(acc, x) : _reduced(acc);
    }, a, list);
  });

  /**
   * Returns a value wrapped to indicate that it is the final value of the reduce
   * and transduce functions. The returned value should be considered a black
   * box: the internal structure is not guaranteed to be stable.
   *
   * This optimization is available to the below functions:
   * - [`reduce`](#reduce)
   * - [`reduceWhile`](#reduceWhile)
   * - [`reduceBy`](#reduceBy)
   * - [`reduceRight`](#reduceRight)
   * - [`transduce`](#transduce)
   *
   * @func
   * @memberOf R
   * @since v0.15.0
   * @category List
   * @sig a -> *
   * @param {*} x The final value of the reduce.
   * @return {*} The wrapped value.
   * @see R.reduce, R.reduceWhile, R.reduceBy, R.reduceRight, R.transduce
   * @example
   *
   *     R.reduce(
   *       (acc, item) => item > 3 ? R.reduced(acc) : acc.concat(item),
   *       [],
   *       [1, 2, 3, 4, 5]) // [1, 2, 3]
   */

  var reduced =
  /*#__PURE__*/
  _curry1(_reduced);

  /**
   * Calls an input function `n` times, returning an array containing the results
   * of those function calls.
   *
   * `fn` is passed one argument: The current value of `n`, which begins at `0`
   * and is gradually incremented to `n - 1`.
   *
   * @func
   * @memberOf R
   * @since v0.2.3
   * @category List
   * @sig (Number -> a) -> Number -> [a]
   * @param {Function} fn The function to invoke. Passed one argument, the current value of `n`.
   * @param {Number} n A value between `0` and `n - 1`. Increments after each function call.
   * @return {Array} An array containing the return values of all calls to `fn`.
   * @see R.repeat
   * @example
   *
   *      R.times(R.identity, 5); //=> [0, 1, 2, 3, 4]
   * @symb R.times(f, 0) = []
   * @symb R.times(f, 1) = [f(0)]
   * @symb R.times(f, 2) = [f(0), f(1)]
   */

  var times =
  /*#__PURE__*/
  _curry2(function times(fn, n) {
    var len = Number(n);
    var idx = 0;
    var list;

    if (len < 0 || isNaN(len)) {
      throw new RangeError('n must be a non-negative number');
    }

    list = new Array(len);

    while (idx < len) {
      list[idx] = fn(idx);
      idx += 1;
    }

    return list;
  });

  /**
   * Returns a fixed list of size `n` containing a specified identical value.
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category List
   * @sig a -> n -> [a]
   * @param {*} value The value to repeat.
   * @param {Number} n The desired size of the output list.
   * @return {Array} A new array containing `n` `value`s.
   * @see R.times
   * @example
   *
   *      R.repeat('hi', 5); //=> ['hi', 'hi', 'hi', 'hi', 'hi']
   *
   *      const obj = {};
   *      const repeatedObjs = R.repeat(obj, 5); //=> [{}, {}, {}, {}, {}]
   *      repeatedObjs[0] === repeatedObjs[1]; //=> true
   * @symb R.repeat(a, 0) = []
   * @symb R.repeat(a, 1) = [a]
   * @symb R.repeat(a, 2) = [a, a]
   */

  var repeat =
  /*#__PURE__*/
  _curry2(function repeat(value, n) {
    return times(always(value), n);
  });

  /**
   * Replace a substring or regex match in a string with a replacement.
   *
   * The first two parameters correspond to the parameters of the
   * `String.prototype.replace()` function, so the second parameter can also be a
   * function.
   *
   * @func
   * @memberOf R
   * @since v0.7.0
   * @category String
   * @sig RegExp|String -> String -> String -> String
   * @param {RegExp|String} pattern A regular expression or a substring to match.
   * @param {String} replacement The string to replace the matches with.
   * @param {String} str The String to do the search and replacement in.
   * @return {String} The result.
   * @example
   *
   *      R.replace('foo', 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *      R.replace(/foo/, 'bar', 'foo foo foo'); //=> 'bar foo foo'
   *
   *      // Use the "g" (global) flag to replace all occurrences:
   *      R.replace(/foo/g, 'bar', 'foo foo foo'); //=> 'bar bar bar'
   */

  var replace =
  /*#__PURE__*/
  _curry3(function replace(regex, replacement, str) {
    return str.replace(regex, replacement);
  });

  /**
   * Scan is similar to [`reduce`](#reduce), but returns a list of successively
   * reduced values from the left
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig ((a, b) -> a) -> a -> [b] -> [a]
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array
   * @param {*} acc The accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {Array} A list of all intermediately reduced values.
   * @see R.reduce, R.mapAccum
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const factorials = R.scan(R.multiply, 1, numbers); //=> [1, 1, 2, 6, 24]
   * @symb R.scan(f, a, [b, c]) = [a, f(a, b), f(f(a, b), c)]
   */

  var scan =
  /*#__PURE__*/
  _curry3(function scan(fn, acc, list) {
    var idx = 0;
    var len = list.length;
    var result = [acc];

    while (idx < len) {
      acc = fn(acc, list[idx]);
      result[idx + 1] = acc;
      idx += 1;
    }

    return result;
  });

  /**
   * Transforms a [Traversable](https://github.com/fantasyland/fantasy-land#traversable)
   * of [Applicative](https://github.com/fantasyland/fantasy-land#applicative) into an
   * Applicative of Traversable.
   *
   * Dispatches to the `sequence` method of the second argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (Applicative f, Traversable t) => (a -> f a) -> t (f a) -> f (t a)
   * @param {Function} of
   * @param {*} traversable
   * @return {*}
   * @see R.traverse
   * @example
   *
   *      R.sequence(Maybe.of, [Just(1), Just(2), Just(3)]);   //=> Just([1, 2, 3])
   *      R.sequence(Maybe.of, [Just(1), Just(2), Nothing()]); //=> Nothing()
   *
   *      R.sequence(R.of, Just([1, 2, 3])); //=> [Just(1), Just(2), Just(3)]
   *      R.sequence(R.of, Nothing());       //=> [Nothing()]
   */

  var sequence =
  /*#__PURE__*/
  _curry2(function sequence(of, traversable) {
    return typeof traversable.sequence === 'function' ? traversable.sequence(of) : reduceRight(function (x, acc) {
      return ap$1(map$1(prepend, x), acc);
    }, of([]), traversable);
  });

  /**
   * Returns the result of "setting" the portion of the given data structure
   * focused by the given lens to the given value.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> a -> s -> s
   * @param {Lens} lens
   * @param {*} v
   * @param {*} x
   * @return {*}
   * @see R.view, R.over, R.lens, R.lensIndex, R.lensProp, R.lensPath
   * @example
   *
   *      const xLens = R.lensProp('x');
   *
   *      R.set(xLens, 4, {x: 1, y: 2});  //=> {x: 4, y: 2}
   *      R.set(xLens, 8, {x: 1, y: 2});  //=> {x: 8, y: 2}
   */

  var set =
  /*#__PURE__*/
  _curry3(function set(lens, v, x) {
    return over(lens, always(v), x);
  });

  /**
   * Returns a copy of the list, sorted according to the comparator function,
   * which should accept two values at a time and return a negative number if the
   * first value is smaller, a positive number if it's larger, and zero if they
   * are equal. Please note that this is a **copy** of the list. It does not
   * modify the original.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, a) -> Number) -> [a] -> [a]
   * @param {Function} comparator A sorting function :: a -> b -> Int
   * @param {Array} list The list to sort
   * @return {Array} a new array with its elements sorted by the comparator function.
   * @see R.ascend, R.descend
   * @example
   *
   *      const diff = function(a, b) { return a - b; };
   *      R.sort(diff, [4,2,7,5]); //=> [2, 4, 5, 7]
   */

  var sort =
  /*#__PURE__*/
  _curry2(function sort(comparator, list) {
    return Array.prototype.slice.call(list, 0).sort(comparator);
  });

  /**
   * Sorts the list according to the supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig Ord b => (a -> b) -> [a] -> [a]
   * @param {Function} fn
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted by the keys generated by `fn`.
   * @example
   *
   *      const sortByFirstItem = R.sortBy(R.prop(0));
   *      const pairs = [[-1, 1], [-2, 2], [-3, 3]];
   *      sortByFirstItem(pairs); //=> [[-3, 3], [-2, 2], [-1, 1]]
   *
   *      const sortByNameCaseInsensitive = R.sortBy(R.compose(R.toLower, R.prop('name')));
   *      const alice = {
   *        name: 'ALICE',
   *        age: 101
   *      };
   *      const bob = {
   *        name: 'Bob',
   *        age: -10
   *      };
   *      const clara = {
   *        name: 'clara',
   *        age: 314.159
   *      };
   *      const people = [clara, bob, alice];
   *      sortByNameCaseInsensitive(people); //=> [alice, bob, clara]
   */

  var sortBy =
  /*#__PURE__*/
  _curry2(function sortBy(fn, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var aa = fn(a);
      var bb = fn(b);
      return aa < bb ? -1 : aa > bb ? 1 : 0;
    });
  });

  /**
   * Sorts a list according to a list of comparators.
   *
   * @func
   * @memberOf R
   * @since v0.23.0
   * @category Relation
   * @sig [(a, a) -> Number] -> [a] -> [a]
   * @param {Array} functions A list of comparator functions.
   * @param {Array} list The list to sort.
   * @return {Array} A new list sorted according to the comarator functions.
   * @see R.ascend, R.descend
   * @example
   *
   *      const alice = {
   *        name: 'alice',
   *        age: 40
   *      };
   *      const bob = {
   *        name: 'bob',
   *        age: 30
   *      };
   *      const clara = {
   *        name: 'clara',
   *        age: 40
   *      };
   *      const people = [clara, bob, alice];
   *      const ageNameSort = R.sortWith([
   *        R.descend(R.prop('age')),
   *        R.ascend(R.prop('name'))
   *      ]);
   *      ageNameSort(people); //=> [alice, clara, bob]
   */

  var sortWith =
  /*#__PURE__*/
  _curry2(function sortWith(fns, list) {
    return Array.prototype.slice.call(list, 0).sort(function (a, b) {
      var result = 0;
      var i = 0;

      while (result === 0 && i < fns.length) {
        result = fns[i](a, b);
        i += 1;
      }

      return result;
    });
  });

  /**
   * Splits a string into an array of strings based on the given
   * separator.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category String
   * @sig (String | RegExp) -> String -> [String]
   * @param {String|RegExp} sep The pattern.
   * @param {String} str The string to separate into an array.
   * @return {Array} The array of strings from `str` separated by `sep`.
   * @see R.join
   * @example
   *
   *      const pathComponents = R.split('/');
   *      R.tail(pathComponents('/usr/local/bin/node')); //=> ['usr', 'local', 'bin', 'node']
   *
   *      R.split('.', 'a.b.c.xyz.d'); //=> ['a', 'b', 'c', 'xyz', 'd']
   */

  var split =
  /*#__PURE__*/
  invoker(1, 'split');

  /**
   * Splits a given list or string at a given index.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig Number -> [a] -> [[a], [a]]
   * @sig Number -> String -> [String, String]
   * @param {Number} index The index where the array/string is split.
   * @param {Array|String} array The array/string to be split.
   * @return {Array}
   * @example
   *
   *      R.splitAt(1, [1, 2, 3]);          //=> [[1], [2, 3]]
   *      R.splitAt(5, 'hello world');      //=> ['hello', ' world']
   *      R.splitAt(-1, 'foobar');          //=> ['fooba', 'r']
   */

  var splitAt =
  /*#__PURE__*/
  _curry2(function splitAt(index, array) {
    return [slice(0, index, array), slice(index, length(array), array)];
  });

  /**
   * Splits a collection into slices of the specified length.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig Number -> [a] -> [[a]]
   * @sig Number -> String -> [String]
   * @param {Number} n
   * @param {Array} list
   * @return {Array}
   * @example
   *
   *      R.splitEvery(3, [1, 2, 3, 4, 5, 6, 7]); //=> [[1, 2, 3], [4, 5, 6], [7]]
   *      R.splitEvery(3, 'foobarbaz'); //=> ['foo', 'bar', 'baz']
   */

  var splitEvery =
  /*#__PURE__*/
  _curry2(function splitEvery(n, list) {
    if (n <= 0) {
      throw new Error('First argument to splitEvery must be a positive integer');
    }

    var result = [];
    var idx = 0;

    while (idx < list.length) {
      result.push(slice(idx, idx += n, list));
    }

    return result;
  });

  /**
   * Takes a list and a predicate and returns a pair of lists with the following properties:
   *
   *  - the result of concatenating the two output lists is equivalent to the input list;
   *  - none of the elements of the first output list satisfies the predicate; and
   *  - if the second output list is non-empty, its first element satisfies the predicate.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [[a], [a]]
   * @param {Function} pred The predicate that determines where the array is split.
   * @param {Array} list The array to be split.
   * @return {Array}
   * @example
   *
   *      R.splitWhen(R.equals(2), [1, 2, 3, 1, 2, 3]);   //=> [[1], [2, 3, 1, 2, 3]]
   */

  var splitWhen =
  /*#__PURE__*/
  _curry2(function splitWhen(pred, list) {
    var idx = 0;
    var len = list.length;
    var prefix = [];

    while (idx < len && !pred(list[idx])) {
      prefix.push(list[idx]);
      idx += 1;
    }

    return [prefix, Array.prototype.slice.call(list, idx)];
  });

  /**
   * Splits an array into slices on every occurrence of a value.
   *
   * @func
   * @memberOf R
   * @since v0.26.1
   * @category List
   * @sig (a -> Boolean) -> [a] -> [[a]]
   * @param {Function} pred The predicate that determines where the array is split.
   * @param {Array} list The array to be split.
   * @return {Array}
   * @example
   *
   *      R.splitWhenever(R.equals(2), [1, 2, 3, 2, 4, 5, 2, 6, 7]); //=> [[1], [3], [4, 5], [6, 7]]
   */

  var splitWhenever =
  /*#__PURE__*/
  _curryN(2, [], function splitWhenever(pred, list) {
    var acc = [];
    var curr = [];

    for (var i = 0; i < list.length; i = i + 1) {
      if (!pred(list[i])) {
        curr.push(list[i]);
      }

      if ((i < list.length - 1 && pred(list[i + 1]) || i === list.length - 1) && curr.length > 0) {
        acc.push(curr);
        curr = [];
      }
    }

    return acc;
  });

  /**
   * Checks if a list starts with the provided sublist.
   *
   * Similarly, checks if a string starts with the provided substring.
   *
   * @func
   * @memberOf R
   * @since v0.24.0
   * @category List
   * @sig [a] -> [a] -> Boolean
   * @sig String -> String -> Boolean
   * @param {*} prefix
   * @param {*} list
   * @return {Boolean}
   * @see R.endsWith
   * @example
   *
   *      R.startsWith('a', 'abc')                //=> true
   *      R.startsWith('b', 'abc')                //=> false
   *      R.startsWith(['a'], ['a', 'b', 'c'])    //=> true
   *      R.startsWith(['b'], ['a', 'b', 'c'])    //=> false
   */

  var startsWith =
  /*#__PURE__*/
  _curry2(function (prefix, list) {
    return equals(take(prefix.length, list), prefix);
  });

  /**
   * Subtracts its second argument from its first argument.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Math
   * @sig Number -> Number -> Number
   * @param {Number} a The first value.
   * @param {Number} b The second value.
   * @return {Number} The result of `a - b`.
   * @see R.add
   * @example
   *
   *      R.subtract(10, 8); //=> 2
   *
   *      const minus5 = R.subtract(R.__, 5);
   *      minus5(17); //=> 12
   *
   *      const complementaryAngle = R.subtract(90);
   *      complementaryAngle(30); //=> 60
   *      complementaryAngle(72); //=> 18
   */

  var subtract =
  /*#__PURE__*/
  _curry2(function subtract(a, b) {
    return Number(a) - Number(b);
  });

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifferenceWith, R.difference, R.differenceWith
   * @example
   *
   *      R.symmetricDifference([1,2,3,4], [7,6,5,4,3]); //=> [1,2,7,6,5]
   *      R.symmetricDifference([7,6,5,4,3], [1,2,3,4]); //=> [7,6,5,1,2]
   */

  var symmetricDifference =
  /*#__PURE__*/
  _curry2(function symmetricDifference(list1, list2) {
    return concat(difference(list1, list2), difference(list2, list1));
  });

  /**
   * Finds the set (i.e. no duplicates) of all elements contained in the first or
   * second list, but not both. Duplication is determined according to the value
   * returned by applying the supplied predicate to two list elements.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [a] -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The elements in `list1` or `list2`, but not both.
   * @see R.symmetricDifference, R.difference, R.differenceWith
   * @example
   *
   *      const eqA = R.eqBy(R.prop('a'));
   *      const l1 = [{a: 1}, {a: 2}, {a: 3}, {a: 4}];
   *      const l2 = [{a: 3}, {a: 4}, {a: 5}, {a: 6}];
   *      R.symmetricDifferenceWith(eqA, l1, l2); //=> [{a: 1}, {a: 2}, {a: 5}, {a: 6}]
   */

  var symmetricDifferenceWith =
  /*#__PURE__*/
  _curry3(function symmetricDifferenceWith(pred, list1, list2) {
    return concat(differenceWith(pred, list1, list2), differenceWith(pred, list2, list1));
  });

  /**
   * Returns a new list containing the last `n` elements of a given list, passing
   * each value to the supplied predicate function, and terminating when the
   * predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropLastWhile, R.addIndex
   * @example
   *
   *      const isNotOne = x => x !== 1;
   *
   *      R.takeLastWhile(isNotOne, [1, 2, 3, 4]); //=> [2, 3, 4]
   *
   *      R.takeLastWhile(x => x !== 'R' , 'Ramda'); //=> 'amda'
   */

  var takeLastWhile =
  /*#__PURE__*/
  _curry2(function takeLastWhile(fn, xs) {
    var idx = xs.length - 1;

    while (idx >= 0 && fn(xs[idx])) {
      idx -= 1;
    }

    return slice(idx + 1, Infinity, xs);
  });

  var XTakeWhile =
  /*#__PURE__*/
  function () {
    function XTakeWhile(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XTakeWhile.prototype['@@transducer/init'] = _xfBase.init;
    XTakeWhile.prototype['@@transducer/result'] = _xfBase.result;

    XTakeWhile.prototype['@@transducer/step'] = function (result, input) {
      return this.f(input) ? this.xf['@@transducer/step'](result, input) : _reduced(result);
    };

    return XTakeWhile;
  }();

  var _xtakeWhile =
  /*#__PURE__*/
  _curry2(function _xtakeWhile(f, xf) {
    return new XTakeWhile(f, xf);
  });

  /**
   * Returns a new list containing the first `n` elements of a given list,
   * passing each value to the supplied predicate function, and terminating when
   * the predicate function returns `false`. Excludes the element that caused the
   * predicate function to fail. The predicate function is passed one argument:
   * *(value)*.
   *
   * Dispatches to the `takeWhile` method of the second argument, if present.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig (a -> Boolean) -> [a] -> [a]
   * @sig (a -> Boolean) -> String -> String
   * @param {Function} fn The function called per iteration.
   * @param {Array} xs The collection to iterate over.
   * @return {Array} A new array.
   * @see R.dropWhile, R.transduce, R.addIndex
   * @example
   *
   *      const isNotFour = x => x !== 4;
   *
   *      R.takeWhile(isNotFour, [1, 2, 3, 4, 3, 2, 1]); //=> [1, 2, 3]
   *
   *      R.takeWhile(x => x !== 'd' , 'Ramda'); //=> 'Ram'
   */

  var takeWhile =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable(['takeWhile'], _xtakeWhile, function takeWhile(fn, xs) {
    var idx = 0;
    var len = xs.length;

    while (idx < len && fn(xs[idx])) {
      idx += 1;
    }

    return slice(0, idx, xs);
  }));

  var XTap =
  /*#__PURE__*/
  function () {
    function XTap(f, xf) {
      this.xf = xf;
      this.f = f;
    }

    XTap.prototype['@@transducer/init'] = _xfBase.init;
    XTap.prototype['@@transducer/result'] = _xfBase.result;

    XTap.prototype['@@transducer/step'] = function (result, input) {
      this.f(input);
      return this.xf['@@transducer/step'](result, input);
    };

    return XTap;
  }();

  var _xtap =
  /*#__PURE__*/
  _curry2(function _xtap(f, xf) {
    return new XTap(f, xf);
  });

  /**
   * Runs the given function with the supplied object, then returns the object.
   *
   * Acts as a transducer if a transformer is given as second parameter.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Function
   * @sig (a -> *) -> a -> a
   * @param {Function} fn The function to call with `x`. The return value of `fn` will be thrown away.
   * @param {*} x
   * @return {*} `x`.
   * @example
   *
   *      const sayX = x => console.log('x is ' + x);
   *      R.tap(sayX, 100); //=> 100
   *      // logs 'x is 100'
   * @symb R.tap(f, a) = a
   */

  var tap =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xtap, function tap(fn, x) {
    fn(x);
    return x;
  }));

  function _isRegExp(x) {
    return Object.prototype.toString.call(x) === '[object RegExp]';
  }

  /**
   * Determines whether a given string matches a given regular expression.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category String
   * @sig RegExp -> String -> Boolean
   * @param {RegExp} pattern
   * @param {String} str
   * @return {Boolean}
   * @see R.match
   * @example
   *
   *      R.test(/^x/, 'xyz'); //=> true
   *      R.test(/^y/, 'xyz'); //=> false
   */

  var test =
  /*#__PURE__*/
  _curry2(function test(pattern, str) {
    if (!_isRegExp(pattern)) {
      throw new TypeError('test requires a value of type RegExp as its first argument; received ' + toString(pattern));
    }

    return _cloneRegExp(pattern).test(str);
  });

  /**
   * Returns the result of applying the onSuccess function to the value inside
   * a successfully resolved promise. This is useful for working with promises
   * inside function compositions.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category Function
   * @sig (a -> b) -> (Promise e a) -> (Promise e b)
   * @sig (a -> (Promise e b)) -> (Promise e a) -> (Promise e b)
   * @param {Function} onSuccess The function to apply. Can return a value or a promise of a value.
   * @param {Promise} p
   * @return {Promise} The result of calling `p.then(onSuccess)`
   * @see R.otherwise
   * @example
   *
   *      const makeQuery = email => ({ query: { email }});
   *      const fetchMember = request =>
   *        Promise.resolve({ firstName: 'Bob', lastName: 'Loblaw', id: 42 });
   *
   *      //getMemberName :: String -> Promise ({ firstName, lastName })
   *      const getMemberName = R.pipe(
   *        makeQuery,
   *        fetchMember,
   *        R.andThen(R.pick(['firstName', 'lastName']))
   *      );
   *
   *      getMemberName('bob@gmail.com').then(console.log);
   */

  var andThen =
  /*#__PURE__*/
  _curry2(function andThen(f, p) {
    _assertPromise('andThen', p);

    return p.then(f);
  });

  /**
   * The lower case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to lower case.
   * @return {String} The lower case version of `str`.
   * @see R.toUpper
   * @example
   *
   *      R.toLower('XYZ'); //=> 'xyz'
   */

  var toLower =
  /*#__PURE__*/
  invoker(0, 'toLowerCase');

  /**
   * Converts an object into an array of key, value arrays. Only the object's
   * own properties are used.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own properties.
   * @see R.fromPairs, R.keys, R.values
   * @example
   *
   *      R.toPairs({a: 1, b: 2, c: 3}); //=> [['a', 1], ['b', 2], ['c', 3]]
   */

  var toPairs =
  /*#__PURE__*/
  _curry1(function toPairs(obj) {
    var pairs = [];

    for (var prop in obj) {
      if (_has(prop, obj)) {
        pairs[pairs.length] = [prop, obj[prop]];
      }
    }

    return pairs;
  });

  /**
   * Converts an object into an array of key, value arrays. The object's own
   * properties and prototype properties are used. Note that the order of the
   * output array is not guaranteed to be consistent across different JS
   * platforms.
   *
   * @func
   * @memberOf R
   * @since v0.4.0
   * @category Object
   * @sig {String: *} -> [[String,*]]
   * @param {Object} obj The object to extract from
   * @return {Array} An array of key, value arrays from the object's own
   *         and prototype properties.
   * @example
   *
   *      const F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      const f = new F();
   *      R.toPairsIn(f); //=> [['x','X'], ['y','Y']]
   */

  var toPairsIn =
  /*#__PURE__*/
  _curry1(function toPairsIn(obj) {
    var pairs = [];

    for (var prop in obj) {
      pairs[pairs.length] = [prop, obj[prop]];
    }

    return pairs;
  });

  /**
   * The upper case version of a string.
   *
   * @func
   * @memberOf R
   * @since v0.9.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to upper case.
   * @return {String} The upper case version of `str`.
   * @see R.toLower
   * @example
   *
   *      R.toUpper('abc'); //=> 'ABC'
   */

  var toUpper =
  /*#__PURE__*/
  invoker(0, 'toUpperCase');

  /**
   * Initializes a transducer using supplied iterator function. Returns a single
   * item by iterating through the list, successively calling the transformed
   * iterator function and passing it an accumulator value and the current value
   * from the array, and then passing the result to the next call.
   *
   * The iterator function receives two values: *(acc, value)*. It will be
   * wrapped as a transformer to initialize the transducer. A transformer can be
   * passed directly in place of an iterator function. In both cases, iteration
   * may be stopped early with the [`R.reduced`](#reduced) function.
   *
   * A transducer is a function that accepts a transformer and returns a
   * transformer and can be composed directly.
   *
   * A transformer is an object that provides a 2-arity reducing iterator
   * function, step, 0-arity initial value function, init, and 1-arity result
   * extraction function, result. The step function is used as the iterator
   * function in reduce. The result function is used to convert the final
   * accumulator into the return type and in most cases is
   * [`R.identity`](#identity). The init function can be used to provide an
   * initial accumulator, but is ignored by transduce.
   *
   * The iteration is performed with [`R.reduce`](#reduce) after initializing the transducer.
   *
   * @func
   * @memberOf R
   * @since v0.12.0
   * @category List
   * @sig (c -> c) -> ((a, b) -> a) -> a -> [b] -> a
   * @param {Function} xf The transducer function. Receives a transformer and returns a transformer.
   * @param {Function} fn The iterator function. Receives two values, the accumulator and the
   *        current element from the array. Wrapped as transformer, if necessary, and used to
   *        initialize the transducer
   * @param {*} acc The initial accumulator value.
   * @param {Array} list The list to iterate over.
   * @return {*} The final, accumulated value.
   * @see R.reduce, R.reduced, R.into
   * @example
   *
   *      const numbers = [1, 2, 3, 4];
   *      const transducer = R.compose(R.map(R.add(1)), R.take(2));
   *      R.transduce(transducer, R.flip(R.append), [], numbers); //=> [2, 3]
   *
   *      const isOdd = (x) => x % 2 !== 0;
   *      const firstOddTransducer = R.compose(R.filter(isOdd), R.take(1));
   *      R.transduce(firstOddTransducer, R.flip(R.append), [], R.range(0, 100)); //=> [1]
   */

  var transduce =
  /*#__PURE__*/
  curryN(4, function transduce(xf, fn, acc, list) {
    return _reduce(xf(typeof fn === 'function' ? _xwrap(fn) : fn), acc, list);
  });

  /**
   * Transposes the rows and columns of a 2D list.
   * When passed a list of `n` lists of length `x`,
   * returns a list of `x` lists of length `n`.
   *
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [[a]] -> [[a]]
   * @param {Array} list A 2D list
   * @return {Array} A 2D list
   * @example
   *
   *      R.transpose([[1, 'a'], [2, 'b'], [3, 'c']]) //=> [[1, 2, 3], ['a', 'b', 'c']]
   *      R.transpose([[1, 2, 3], ['a', 'b', 'c']]) //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   *
   *      // If some of the rows are shorter than the following rows, their elements are skipped:
   *      R.transpose([[10, 11], [20], [], [30, 31, 32]]) //=> [[10, 20, 30], [11, 31], [32]]
   * @symb R.transpose([[a], [b], [c]]) = [a, b, c]
   * @symb R.transpose([[a, b], [c, d]]) = [[a, c], [b, d]]
   * @symb R.transpose([[a, b], [c]]) = [[a, c], [b]]
   */

  var transpose =
  /*#__PURE__*/
  _curry1(function transpose(outerlist) {
    var i = 0;
    var result = [];

    while (i < outerlist.length) {
      var innerlist = outerlist[i];
      var j = 0;

      while (j < innerlist.length) {
        if (typeof result[j] === 'undefined') {
          result[j] = [];
        }

        result[j].push(innerlist[j]);
        j += 1;
      }

      i += 1;
    }

    return result;
  });

  /**
   * Maps an [Applicative](https://github.com/fantasyland/fantasy-land#applicative)-returning
   * function over a [Traversable](https://github.com/fantasyland/fantasy-land#traversable),
   * then uses [`sequence`](#sequence) to transform the resulting Traversable of Applicative
   * into an Applicative of Traversable.
   *
   * Dispatches to the `traverse` method of the third argument, if present.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig (Applicative f, Traversable t) => (a -> f a) -> (a -> f b) -> t a -> f (t b)
   * @param {Function} of
   * @param {Function} f
   * @param {*} traversable
   * @return {*}
   * @see R.sequence
   * @example
   *
   *      // Returns `Maybe.Nothing` if the given divisor is `0`
   *      const safeDiv = n => d => d === 0 ? Maybe.Nothing() : Maybe.Just(n / d)
   *
   *      R.traverse(Maybe.of, safeDiv(10), [2, 4, 5]); //=> Maybe.Just([5, 2.5, 2])
   *      R.traverse(Maybe.of, safeDiv(10), [2, 0, 5]); //=> Maybe.Nothing
   */

  var traverse =
  /*#__PURE__*/
  _curry3(function traverse(of, f, traversable) {
    return typeof traversable['fantasy-land/traverse'] === 'function' ? traversable['fantasy-land/traverse'](f, of) : typeof traversable.traverse === 'function' ? traversable.traverse(f, of) : sequence(of, map$1(f, traversable));
  });

  var ws = '\x09\x0A\x0B\x0C\x0D\x20\xA0\u1680\u2000\u2001\u2002\u2003' + '\u2004\u2005\u2006\u2007\u2008\u2009\u200A\u202F\u205F\u3000\u2028' + '\u2029\uFEFF';
  var zeroWidth = '\u200b';
  var hasProtoTrim = typeof String.prototype.trim === 'function';
  /**
   * Removes (strips) whitespace from both ends of the string.
   *
   * @func
   * @memberOf R
   * @since v0.6.0
   * @category String
   * @sig String -> String
   * @param {String} str The string to trim.
   * @return {String} Trimmed version of `str`.
   * @example
   *
   *      R.trim('   xyz  '); //=> 'xyz'
   *      R.map(R.trim, R.split(',', 'x, y, z')); //=> ['x', 'y', 'z']
   */

  var trim = !hasProtoTrim ||
  /*#__PURE__*/
  ws.trim() || !
  /*#__PURE__*/
  zeroWidth.trim() ?
  /*#__PURE__*/
  _curry1(function trim(str) {
    var beginRx = new RegExp('^[' + ws + '][' + ws + ']*');
    var endRx = new RegExp('[' + ws + '][' + ws + ']*$');
    return str.replace(beginRx, '').replace(endRx, '');
  }) :
  /*#__PURE__*/
  _curry1(function trim(str) {
    return str.trim();
  });

  /**
   * `tryCatch` takes two functions, a `tryer` and a `catcher`. The returned
   * function evaluates the `tryer`; if it does not throw, it simply returns the
   * result. If the `tryer` *does* throw, the returned function evaluates the
   * `catcher` function and returns its result. Note that for effective
   * composition with this function, both the `tryer` and `catcher` functions
   * must return the same type of results.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Function
   * @sig (...x -> a) -> ((e, ...x) -> a) -> (...x -> a)
   * @param {Function} tryer The function that may throw.
   * @param {Function} catcher The function that will be evaluated if `tryer` throws.
   * @return {Function} A new function that will catch exceptions and send them to the catcher.
   * @example
   *
   *      R.tryCatch(R.prop('x'), R.F)({x: true}); //=> true
   *      R.tryCatch(() => { throw 'foo'}, R.always('caught'))('bar') // =>
   *      'caught'
   *      R.tryCatch(R.times(R.identity), R.always([]))('s') // => []
   *      R.tryCatch(() => { throw 'this is not a valid value'}, (err, value)=>({error : err,  value }))('bar') // => {'error': 'this is not a valid value', 'value': 'bar'}
   */

  var tryCatch =
  /*#__PURE__*/
  _curry2(function _tryCatch(tryer, catcher) {
    return _arity(tryer.length, function () {
      try {
        return tryer.apply(this, arguments);
      } catch (e) {
        return catcher.apply(this, _concat([e], arguments));
      }
    });
  });

  /**
   * Takes a function `fn`, which takes a single array argument, and returns a
   * function which:
   *
   *   - takes any number of positional arguments;
   *   - passes these arguments to `fn` as an array; and
   *   - returns the result.
   *
   * In other words, `R.unapply` derives a variadic function from a function which
   * takes an array. `R.unapply` is the inverse of [`R.apply`](#apply).
   *
   * @func
   * @memberOf R
   * @since v0.8.0
   * @category Function
   * @sig ([*...] -> a) -> (*... -> a)
   * @param {Function} fn
   * @return {Function}
   * @see R.apply
   * @example
   *
   *      R.unapply(JSON.stringify)(1, 2, 3); //=> '[1,2,3]'
   * @symb R.unapply(f)(a, b) = f([a, b])
   */

  var unapply =
  /*#__PURE__*/
  _curry1(function unapply(fn) {
    return function () {
      return fn(Array.prototype.slice.call(arguments, 0));
    };
  });

  /**
   * Wraps a function of any arity (including nullary) in a function that accepts
   * exactly 1 parameter. Any extraneous parameters will not be passed to the
   * supplied function.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Function
   * @sig (a -> b -> c -> ... -> z) -> (a -> z)
   * @param {Function} fn The function to wrap.
   * @return {Function} A new function wrapping `fn`. The new function is guaranteed to be of
   *         arity 1.
   * @see R.binary, R.nAry
   * @example
   *
   *      const takesTwoArgs = function(a, b) {
   *        return [a, b];
   *      };
   *      takesTwoArgs.length; //=> 2
   *      takesTwoArgs(1, 2); //=> [1, 2]
   *
   *      const takesOneArg = R.unary(takesTwoArgs);
   *      takesOneArg.length; //=> 1
   *      // Only 1 argument is passed to the wrapped function
   *      takesOneArg(1, 2); //=> [1, undefined]
   * @symb R.unary(f)(a, b, c) = f(a)
   */

  var unary =
  /*#__PURE__*/
  _curry1(function unary(fn) {
    return nAry(1, fn);
  });

  /**
   * Returns a function of arity `n` from a (manually) curried function.
   * Note that, the returned function is actually a ramda style
   * curryied function, which can accept one or more arguments in each
   * function calling.
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Function
   * @sig Number -> (a -> b -> c ... -> z) -> ((a -> b -> c ...) -> z)
   * @param {Number} length The arity for the returned function.
   * @param {Function} fn The function to uncurry.
   * @return {Function} A new function.
   * @see R.curry, R.curryN
   * @example
   *
   *      const addFour = a => b => c => d => a + b + c + d;
   *
   *      const uncurriedAddFour = R.uncurryN(4, addFour);
   *      uncurriedAddFour(1, 2, 3, 4); //=> 10
   */

  var uncurryN =
  /*#__PURE__*/
  _curry2(function uncurryN(depth, fn) {
    return curryN(depth, function () {
      var currentDepth = 1;
      var value = fn;
      var idx = 0;
      var endIdx;

      while (currentDepth <= depth && typeof value === 'function') {
        endIdx = currentDepth === depth ? arguments.length : idx + value.length;
        value = value.apply(this, Array.prototype.slice.call(arguments, idx, endIdx));
        currentDepth += 1;
        idx = endIdx;
      }

      return value;
    });
  });

  /**
   * Builds a list from a seed value. Accepts an iterator function, which returns
   * either false to stop iteration or an array of length 2 containing the value
   * to add to the resulting list and the seed to be used in the next call to the
   * iterator function.
   *
   * The iterator function receives one argument: *(seed)*.
   *
   * @func
   * @memberOf R
   * @since v0.10.0
   * @category List
   * @sig (a -> [b]) -> * -> [b]
   * @param {Function} fn The iterator function. receives one argument, `seed`, and returns
   *        either false to quit iteration or an array of length two to proceed. The element
   *        at index 0 of this array will be added to the resulting array, and the element
   *        at index 1 will be passed to the next call to `fn`.
   * @param {*} seed The seed value.
   * @return {Array} The final list.
   * @example
   *
   *      const f = n => n > 50 ? false : [-n, n + 10];
   *      R.unfold(f, 10); //=> [-10, -20, -30, -40, -50]
   * @symb R.unfold(f, x) = [f(x)[0], f(f(x)[1])[0], f(f(f(x)[1])[1])[0], ...]
   */

  var unfold =
  /*#__PURE__*/
  _curry2(function unfold(fn, seed) {
    var pair = fn(seed);
    var result = [];

    while (pair && pair.length) {
      result[result.length] = pair[0];
      pair = fn(pair[1]);
    }

    return result;
  });

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig [*] -> [*] -> [*]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @example
   *
   *      R.union([1, 2, 3], [2, 3, 4]); //=> [1, 2, 3, 4]
   */

  var union =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  compose(uniq, _concat));

  var XUniqWith =
  /*#__PURE__*/
  function () {
    function XUniqWith(pred, xf) {
      this.xf = xf;
      this.pred = pred;
      this.items = [];
    }

    XUniqWith.prototype['@@transducer/init'] = _xfBase.init;
    XUniqWith.prototype['@@transducer/result'] = _xfBase.result;

    XUniqWith.prototype['@@transducer/step'] = function (result, input) {
      if (_includesWith(this.pred, input, this.items)) {
        return result;
      } else {
        this.items.push(input);
        return this.xf['@@transducer/step'](result, input);
      }
    };

    return XUniqWith;
  }();

  var _xuniqWith =
  /*#__PURE__*/
  _curry2(function _xuniqWith(pred, xf) {
    return new XUniqWith(pred, xf);
  });

  /**
   * Returns a new list containing only one copy of each element in the original
   * list, based upon the value returned by applying the supplied predicate to
   * two list elements. Prefers the first item if two items compare equal based
   * on the predicate.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category List
   * @sig ((a, a) -> Boolean) -> [a] -> [a]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list The array to consider.
   * @return {Array} The list of unique items.
   * @example
   *
   *      const strEq = R.eqBy(String);
   *      R.uniqWith(strEq)([1, '1', 2, 1]); //=> [1, 2]
   *      R.uniqWith(strEq)([{}, {}]);       //=> [{}]
   *      R.uniqWith(strEq)([1, '1', 1]);    //=> [1]
   *      R.uniqWith(strEq)(['1', 1, 1]);    //=> ['1']
   */

  var uniqWith =
  /*#__PURE__*/
  _curry2(
  /*#__PURE__*/
  _dispatchable([], _xuniqWith, function (pred, list) {
    var idx = 0;
    var len = list.length;
    var result = [];
    var item;

    while (idx < len) {
      item = list[idx];

      if (!_includesWith(pred, item, result)) {
        result[result.length] = item;
      }

      idx += 1;
    }

    return result;
  }));

  /**
   * Combines two lists into a set (i.e. no duplicates) composed of the elements
   * of each list. Duplication is determined according to the value returned by
   * applying the supplied predicate to two list elements. If an element exists
   * in both lists, the first element from the first list will be used.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category Relation
   * @sig ((a, a) -> Boolean) -> [*] -> [*] -> [*]
   * @param {Function} pred A predicate used to test whether two items are equal.
   * @param {Array} list1 The first list.
   * @param {Array} list2 The second list.
   * @return {Array} The first and second lists concatenated, with
   *         duplicates removed.
   * @see R.union
   * @example
   *
   *      const l1 = [{a: 1}, {a: 2}];
   *      const l2 = [{a: 1}, {a: 4}];
   *      R.unionWith(R.eqBy(R.prop('a')), l1, l2); //=> [{a: 1}, {a: 2}, {a: 4}]
   */

  var unionWith =
  /*#__PURE__*/
  _curry3(function unionWith(pred, list1, list2) {
    return uniqWith(pred, _concat(list1, list2));
  });

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is not satisfied, the function will return the result of
   * calling the `whenFalseFn` function with the same argument. If the predicate
   * is satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> b) -> a -> a | b
   * @param {Function} pred        A predicate function
   * @param {Function} whenFalseFn A function to invoke when the `pred` evaluates
   *                               to a falsy value.
   * @param {*}        x           An object to test with the `pred` function and
   *                               pass to `whenFalseFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenFalseFn`.
   * @see R.ifElse, R.when, R.cond
   * @example
   *
   *      let safeInc = R.unless(R.isNil, R.inc);
   *      safeInc(null); //=> null
   *      safeInc(1); //=> 2
   */

  var unless =
  /*#__PURE__*/
  _curry3(function unless(pred, whenFalseFn, x) {
    return pred(x) ? x : whenFalseFn(x);
  });

  /**
   * Shorthand for `R.chain(R.identity)`, which removes one level of nesting from
   * any [Chain](https://github.com/fantasyland/fantasy-land#chain).
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig Chain c => c (c a) -> c a
   * @param {*} list
   * @return {*}
   * @see R.flatten, R.chain
   * @example
   *
   *      R.unnest([1, [2], [[3]]]); //=> [1, 2, [3]]
   *      R.unnest([[1, 2], [3, 4], [5, 6]]); //=> [1, 2, 3, 4, 5, 6]
   */

  var unnest =
  /*#__PURE__*/
  chain$1(_identity);

  /**
   * Takes a predicate, a transformation function, and an initial value,
   * and returns a value of the same type as the initial value.
   * It does so by applying the transformation until the predicate is satisfied,
   * at which point it returns the satisfactory value.
   *
   * @func
   * @memberOf R
   * @since v0.20.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> a) -> a -> a
   * @param {Function} pred A predicate function
   * @param {Function} fn The iterator function
   * @param {*} init Initial value
   * @return {*} Final value that satisfies predicate
   * @example
   *
   *      R.until(R.gt(R.__, 100), R.multiply(2))(1) // => 128
   */

  var until =
  /*#__PURE__*/
  _curry3(function until(pred, fn, init) {
    var val = init;

    while (!pred(val)) {
      val = fn(val);
    }

    return val;
  });

  /**
   *
   * Deconstructs an array field from the input documents to output a document for each element.
   * Each output document is the input document with the value of the array field replaced by the element.
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig String -> {k: [v]} -> [{k: v}]
   * @param {String} key The key to determine which property of the object should be unwind
   * @param {Object} object The object containing list under property named as key which is to unwind
   * @return {List} A new list of object containing the value of input key having list replaced by each element in the object.
   * @example
   *
   * R.unwind('hobbies', {
   *   name: 'alice',
   *   hobbies: ['Golf', 'Hacking'],
   *   colors: ['red', 'green'],
   * });
   * // [
   * //   { name: 'alice', hobbies: 'Golf', colors: ['red', 'green'] },
   * //   { name: 'alice', hobbies: 'Hacking', colors: ['red', 'green'] }
   * // ]
   */

  var unwind =
  /*#__PURE__*/
  _curry2(function (key, object) {
    // If key is not in object or key is not as a list in object
    if (!(key in object && _isArray(object[key]))) {
      return [object];
    } // Map over object[key] which is a list and assoc each element with key


    return _map(function (item) {
      return _assoc(key, item, object);
    }, object[key]);
  });

  /**
   * Returns a list of all the properties, including prototype properties, of the
   * supplied object.
   * Note that the order of the output array is not guaranteed to be consistent
   * across different JS platforms.
   *
   * @func
   * @memberOf R
   * @since v0.2.0
   * @category Object
   * @sig {k: v} -> [v]
   * @param {Object} obj The object to extract values from
   * @return {Array} An array of the values of the object's own and prototype properties.
   * @see R.values, R.keysIn
   * @example
   *
   *      const F = function() { this.x = 'X'; };
   *      F.prototype.y = 'Y';
   *      const f = new F();
   *      R.valuesIn(f); //=> ['X', 'Y']
   */

  var valuesIn =
  /*#__PURE__*/
  _curry1(function valuesIn(obj) {
    var prop;
    var vs = [];

    for (prop in obj) {
      vs[vs.length] = obj[prop];
    }

    return vs;
  });

  var Const = function (x) {
    return {
      value: x,
      'fantasy-land/map': function () {
        return this;
      }
    };
  };
  /**
   * Returns a "view" of the given data structure, determined by the given lens.
   * The lens's focus determines which portion of the data structure is visible.
   *
   * @func
   * @memberOf R
   * @since v0.16.0
   * @category Object
   * @typedefn Lens s a = Functor f => (a -> f a) -> s -> f s
   * @sig Lens s a -> s -> a
   * @param {Lens} lens
   * @param {*} x
   * @return {*}
   * @see R.set, R.over, R.lens, R.lensIndex, R.lensProp, R.lensPath
   * @example
   *
   *      const xLens = R.lensProp('x');
   *
   *      R.view(xLens, {x: 1, y: 2});  //=> 1
   *      R.view(xLens, {x: 4, y: 2});  //=> 4
   */


  var view =
  /*#__PURE__*/
  _curry2(function view(lens, x) {
    // Using `Const` effectively ignores the setter function of the `lens`,
    // leaving the value returned by the getter function unmodified.
    return lens(Const)(x).value;
  });

  /**
   * Tests the final argument by passing it to the given predicate function. If
   * the predicate is satisfied, the function will return the result of calling
   * the `whenTrueFn` function with the same argument. If the predicate is not
   * satisfied, the argument is returned as is.
   *
   * @func
   * @memberOf R
   * @since v0.18.0
   * @category Logic
   * @sig (a -> Boolean) -> (a -> b) -> a -> a | b
   * @param {Function} pred       A predicate function
   * @param {Function} whenTrueFn A function to invoke when the `condition`
   *                              evaluates to a truthy value.
   * @param {*}        x          An object to test with the `pred` function and
   *                              pass to `whenTrueFn` if necessary.
   * @return {*} Either `x` or the result of applying `x` to `whenTrueFn`.
   * @see R.ifElse, R.unless, R.cond
   * @example
   *
   *      // truncate :: String -> String
   *      const truncate = R.when(
   *        R.propSatisfies(R.gt(R.__, 10), 'length'),
   *        R.pipe(R.take(10), R.append(''), R.join(''))
   *      );
   *      truncate('12345');         //=> '12345'
   *      truncate('0123456789ABC'); //=> '0123456789'
   */

  var when =
  /*#__PURE__*/
  _curry3(function when(pred, whenTrueFn, x) {
    return pred(x) ? whenTrueFn(x) : x;
  });

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec. Each of the spec's own properties must be a predicate function.
   * Each predicate is applied to the value of the corresponding property of the
   * test object. `where` returns true if all the predicates return true, false
   * otherwise.
   *
   * `where` is well suited to declaratively expressing constraints for other
   * functions such as [`filter`](#filter) and [`find`](#find).
   *
   * @func
   * @memberOf R
   * @since v0.1.1
   * @category Object
   * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propSatisfies, R.whereEq
   * @example
   *
   *      // pred :: Object -> Boolean
   *      const pred = R.where({
   *        a: R.equals('foo'),
   *        b: R.complement(R.equals('bar')),
   *        x: R.gt(R.__, 10),
   *        y: R.lt(R.__, 20)
   *      });
   *
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 19}); //=> true
   *      pred({a: 'xxx', b: 'xxx', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'bar', x: 11, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 10, y: 19}); //=> false
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> false
   */

  var where =
  /*#__PURE__*/
  _curry2(function where(spec, testObj) {
    for (var prop in spec) {
      if (_has(prop, spec) && !spec[prop](testObj[prop])) {
        return false;
      }
    }

    return true;
  });

  /**
   * Takes a spec object and a test object; each of the spec's own properties must be a predicate function.
   * Each predicate is applied to the value of the corresponding property of the
   * test object. `whereAny` returns true if at least one of the predicates return true,
   * false otherwise.
   *
   * `whereAny` is well suited to declaratively expressing constraints for other
   * functions such as [`filter`](#filter) and [`find`](#find).
   *
   * @func
   * @memberOf R
   * @since v0.28.0
   * @category Object
   * @sig {String: (* -> Boolean)} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propSatisfies, R.where
   * @example
   *
   *      // pred :: Object -> Boolean
   *      const pred = R.whereAny({
   *        a: R.equals('foo'),
   *        b: R.complement(R.equals('xxx')),
   *        x: R.gt(R.__, 10),
   *        y: R.lt(R.__, 20)
   *      });
   *
   *      pred({a: 'foo', b: 'xxx', x: 8, y: 34}); //=> true
   *      pred({a: 'xxx', b: 'xxx', x: 9, y: 21}); //=> false
   *      pred({a: 'bar', b: 'xxx', x: 10, y: 20}); //=> false
   *      pred({a: 'foo', b: 'bar', x: 10, y: 20}); //=> true
   *      pred({a: 'foo', b: 'xxx', x: 11, y: 20}); //=> true
   */

  var whereAny =
  /*#__PURE__*/
  _curry2(function whereAny(spec, testObj) {
    for (var prop in spec) {
      if (_has(prop, spec) && spec[prop](testObj[prop])) {
        return true;
      }
    }

    return false;
  });

  /**
   * Takes a spec object and a test object; returns true if the test satisfies
   * the spec, false otherwise. An object satisfies the spec if, for each of the
   * spec's own properties, accessing that property of the object gives the same
   * value (in [`R.equals`](#equals) terms) as accessing that property of the
   * spec.
   *
   * `whereEq` is a specialization of [`where`](#where).
   *
   * @func
   * @memberOf R
   * @since v0.14.0
   * @category Object
   * @sig {String: *} -> {String: *} -> Boolean
   * @param {Object} spec
   * @param {Object} testObj
   * @return {Boolean}
   * @see R.propEq, R.where
   * @example
   *
   *      // pred :: Object -> Boolean
   *      const pred = R.whereEq({a: 1, b: 2});
   *
   *      pred({a: 1});              //=> false
   *      pred({a: 1, b: 2});        //=> true
   *      pred({a: 1, b: 2, c: 3});  //=> true
   *      pred({a: 1, b: 1});        //=> false
   */

  var whereEq =
  /*#__PURE__*/
  _curry2(function whereEq(spec, testObj) {
    return where(map$1(equals, spec), testObj);
  });

  /**
   * Returns a new list without values in the first argument.
   * [`R.equals`](#equals) is used to determine equality.
   *
   * Acts as a transducer if a transformer is given in list position.
   *
   * @func
   * @memberOf R
   * @since v0.19.0
   * @category List
   * @sig [a] -> [a] -> [a]
   * @param {Array} list1 The values to be removed from `list2`.
   * @param {Array} list2 The array to remove values from.
   * @return {Array} The new array without values in `list1`.
   * @see R.transduce, R.difference, R.remove
   * @example
   *
   *      R.without([1, 2], [1, 2, 1, 3, 4]); //=> [3, 4]
   */

  var without =
  /*#__PURE__*/
  _curry2(function (xs, list) {
    return reject$1(flip(_includes)(xs), list);
  });

  /**
   * Exclusive disjunction logical operation.
   * Returns `true` if one of the arguments is truthy and the other is falsy.
   * Otherwise, it returns `false`.
   *
   * @func
   * @memberOf R
   * @since v0.27.1
   * @category Logic
   * @sig a -> b -> Boolean
   * @param {Any} a
   * @param {Any} b
   * @return {Boolean} true if one of the arguments is truthy and the other is falsy
   * @see R.or, R.and
   * @example
   *
   *      R.xor(true, true); //=> false
   *      R.xor(true, false); //=> true
   *      R.xor(false, true); //=> true
   *      R.xor(false, false); //=> false
   */

  var xor =
  /*#__PURE__*/
  _curry2(function xor(a, b) {
    return Boolean(!a ^ !b);
  });

  /**
   * Creates a new list out of the two supplied by creating each possible pair
   * from the lists.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} as The first list.
   * @param {Array} bs The second list.
   * @return {Array} The list made by combining each possible pair from
   *         `as` and `bs` into pairs (`[a, b]`).
   * @example
   *
   *      R.xprod([1, 2], ['a', 'b']); //=> [[1, 'a'], [1, 'b'], [2, 'a'], [2, 'b']]
   * @symb R.xprod([a, b], [c, d]) = [[a, c], [a, d], [b, c], [b, d]]
   */

  var xprod =
  /*#__PURE__*/
  _curry2(function xprod(a, b) {
    // = xprodWith(prepend); (takes about 3 times as long...)
    var idx = 0;
    var ilen = a.length;
    var j;
    var jlen = b.length;
    var result = [];

    while (idx < ilen) {
      j = 0;

      while (j < jlen) {
        result[result.length] = [a[idx], b[j]];
        j += 1;
      }

      idx += 1;
    }

    return result;
  });

  /**
   * Creates a new list out of the two supplied by pairing up equally-positioned
   * items from both lists. The returned list is truncated to the length of the
   * shorter of the two input lists.
   * Note: `zip` is equivalent to `zipWith(function(a, b) { return [a, b] })`.
   *
   * @func
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig [a] -> [b] -> [[a,b]]
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by pairing up same-indexed elements of `list1` and `list2`.
   * @example
   *
   *      R.zip([1, 2, 3], ['a', 'b', 'c']); //=> [[1, 'a'], [2, 'b'], [3, 'c']]
   * @symb R.zip([a, b, c], [d, e, f]) = [[a, d], [b, e], [c, f]]
   */

  var zip =
  /*#__PURE__*/
  _curry2(function zip(a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);

    while (idx < len) {
      rv[idx] = [a[idx], b[idx]];
      idx += 1;
    }

    return rv;
  });

  /**
   * Creates a new object out of a list of keys and a list of values.
   * Key/value pairing is truncated to the length of the shorter of the two lists.
   * Note: `zipObj` is equivalent to `pipe(zip, fromPairs)`.
   *
   * @func
   * @memberOf R
   * @since v0.3.0
   * @category List
   * @sig [String] -> [*] -> {String: *}
   * @param {Array} keys The array that will be properties on the output object.
   * @param {Array} values The list of values on the output object.
   * @return {Object} The object made by pairing up same-indexed elements of `keys` and `values`.
   * @example
   *
   *      R.zipObj(['a', 'b', 'c'], [1, 2, 3]); //=> {a: 1, b: 2, c: 3}
   */

  var zipObj =
  /*#__PURE__*/
  _curry2(function zipObj(keys, values) {
    var idx = 0;
    var len = Math.min(keys.length, values.length);
    var out = {};

    while (idx < len) {
      out[keys[idx]] = values[idx];
      idx += 1;
    }

    return out;
  });

  /**
   * Creates a new list out of the two supplied by applying the function to each
   * equally-positioned pair in the lists. The returned list is truncated to the
   * length of the shorter of the two input lists.
   *
   * @function
   * @memberOf R
   * @since v0.1.0
   * @category List
   * @sig ((a, b) -> c) -> [a] -> [b] -> [c]
   * @param {Function} fn The function used to combine the two elements into one value.
   * @param {Array} list1 The first array to consider.
   * @param {Array} list2 The second array to consider.
   * @return {Array} The list made by combining same-indexed elements of `list1` and `list2`
   *         using `fn`.
   * @example
   *
   *      const f = (x, y) => {
   *        // ...
   *      };
   *      R.zipWith(f, [1, 2, 3], ['a', 'b', 'c']);
   *      //=> [f(1, 'a'), f(2, 'b'), f(3, 'c')]
   * @symb R.zipWith(fn, [a, b, c], [d, e, f]) = [fn(a, d), fn(b, e), fn(c, f)]
   */

  var zipWith =
  /*#__PURE__*/
  _curry3(function zipWith(fn, a, b) {
    var rv = [];
    var idx = 0;
    var len = Math.min(a.length, b.length);

    while (idx < len) {
      rv[idx] = fn(a[idx], b[idx]);
      idx += 1;
    }

    return rv;
  });

  /**
   * Creates a thunk out of a function. A thunk delays a calculation until
   * its result is needed, providing lazy evaluation of arguments.
   *
   * @func
   * @memberOf R
   * @since v0.26.0
   * @category Function
   * @sig ((a, b, ..., j) -> k) -> (a, b, ..., j) -> (() -> k)
   * @param {Function} fn A function to wrap in a thunk
   * @return {Function} Expects arguments for `fn` and returns a new function
   *  that, when called, applies those arguments to `fn`.
   * @see R.partial, R.partialRight
   * @example
   *
   *      R.thunkify(R.identity)(42)(); //=> 42
   *      R.thunkify((a, b) => a + b)(25, 17)(); //=> 42
   */

  var thunkify =
  /*#__PURE__*/
  _curry1(function thunkify(fn) {
    return curryN(fn.length, function createThunk() {
      var fnArgs = arguments;
      return function invokeThunk() {
        return fn.apply(this, fnArgs);
      };
    });
  });

  var index = /*#__PURE__*/Object.freeze({
    __proto__: null,
    F: F$2,
    T: T,
    __: __,
    add: add,
    addIndex: addIndex,
    adjust: adjust,
    all: all,
    allPass: allPass,
    always: always,
    and: and$1,
    any: any$1,
    anyPass: anyPass,
    ap: ap$1,
    aperture: aperture,
    append: append,
    apply: apply$1,
    applySpec: applySpec,
    applyTo: applyTo,
    ascend: ascend,
    assoc: assoc,
    assocPath: assocPath,
    binary: binary,
    bind: bind,
    both: both$1,
    call: call$1,
    chain: chain$1,
    clamp: clamp,
    clone: clone$1,
    collectBy: collectBy,
    comparator: comparator,
    complement: complement,
    compose: compose,
    composeWith: composeWith,
    concat: concat,
    cond: cond,
    construct: construct,
    constructN: constructN,
    converge: converge,
    count: count,
    countBy: countBy,
    curry: curry,
    curryN: curryN,
    dec: dec,
    defaultTo: defaultTo,
    descend: descend,
    difference: difference,
    differenceWith: differenceWith,
    dissoc: dissoc,
    dissocPath: dissocPath,
    divide: divide,
    drop: drop,
    dropLast: dropLast,
    dropLastWhile: dropLastWhile,
    dropRepeats: dropRepeats,
    dropRepeatsWith: dropRepeatsWith,
    dropWhile: dropWhile,
    either: either,
    empty: empty,
    endsWith: endsWith,
    eqBy: eqBy,
    eqProps: eqProps,
    equals: equals,
    evolve: evolve,
    filter: filter,
    find: find,
    findIndex: findIndex,
    findLast: findLast,
    findLastIndex: findLastIndex,
    flatten: flatten,
    flip: flip,
    forEach: forEach,
    forEachObjIndexed: forEachObjIndexed,
    fromPairs: fromPairs,
    groupBy: groupBy,
    groupWith: groupWith,
    gt: gt,
    gte: gte,
    has: has,
    hasIn: hasIn,
    hasPath: hasPath,
    head: head,
    identical: identical,
    identity: identity,
    ifElse: ifElse,
    inc: inc,
    includes: includes,
    indexBy: indexBy,
    indexOf: indexOf,
    init: init,
    innerJoin: innerJoin,
    insert: insert,
    insertAll: insertAll,
    intersection: intersection,
    intersperse: intersperse,
    into: into,
    invert: invert,
    invertObj: invertObj,
    invoker: invoker,
    is: is,
    isEmpty: isEmpty,
    isNil: isNil$1,
    join: join,
    juxt: juxt,
    keys: keys,
    keysIn: keysIn,
    last: last,
    lastIndexOf: lastIndexOf,
    length: length,
    lens: lens,
    lensIndex: lensIndex,
    lensPath: lensPath,
    lensProp: lensProp,
    lift: lift,
    liftN: liftN,
    lt: lt,
    lte: lte,
    map: map$1,
    mapAccum: mapAccum,
    mapAccumRight: mapAccumRight,
    mapObjIndexed: mapObjIndexed,
    match: match,
    mathMod: mathMod,
    max: max,
    maxBy: maxBy,
    mean: mean,
    median: median,
    memoizeWith: memoizeWith,
    mergeAll: mergeAll,
    mergeDeepLeft: mergeDeepLeft,
    mergeDeepRight: mergeDeepRight,
    mergeDeepWith: mergeDeepWith,
    mergeDeepWithKey: mergeDeepWithKey,
    mergeLeft: mergeLeft,
    mergeRight: mergeRight,
    mergeWith: mergeWith,
    mergeWithKey: mergeWithKey,
    min: min,
    minBy: minBy,
    modify: modify,
    modifyPath: modifyPath,
    modulo: modulo,
    move: move,
    multiply: multiply,
    nAry: nAry,
    partialObject: partialObject,
    negate: negate,
    none: none,
    not: not,
    nth: nth,
    nthArg: nthArg,
    o: o,
    objOf: objOf,
    of: of,
    omit: omit,
    on: on,
    once: once,
    or: or,
    otherwise: otherwise,
    over: over,
    pair: pair,
    partial: partial,
    partialRight: partialRight,
    partition: partition,
    path: path,
    paths: paths,
    pathEq: pathEq,
    pathOr: pathOr,
    pathSatisfies: pathSatisfies,
    pick: pick,
    pickAll: pickAll,
    pickBy: pickBy,
    pipe: pipe$1,
    pipeWith: pipeWith,
    pluck: pluck,
    prepend: prepend,
    product: product,
    project: project,
    promap: promap,
    prop: prop,
    propEq: propEq,
    propIs: propIs,
    propOr: propOr,
    propSatisfies: propSatisfies,
    props: props,
    range: range,
    reduce: reduce,
    reduceBy: reduceBy,
    reduceRight: reduceRight,
    reduceWhile: reduceWhile,
    reduced: reduced,
    reject: reject$1,
    remove: remove,
    repeat: repeat,
    replace: replace,
    reverse: reverse$1,
    scan: scan,
    sequence: sequence,
    set: set,
    slice: slice,
    sort: sort,
    sortBy: sortBy,
    sortWith: sortWith,
    split: split,
    splitAt: splitAt,
    splitEvery: splitEvery,
    splitWhen: splitWhen,
    splitWhenever: splitWhenever,
    startsWith: startsWith,
    subtract: subtract,
    sum: sum,
    symmetricDifference: symmetricDifference,
    symmetricDifferenceWith: symmetricDifferenceWith,
    tail: tail,
    take: take,
    takeLast: takeLast,
    takeLastWhile: takeLastWhile,
    takeWhile: takeWhile,
    tap: tap,
    test: test,
    andThen: andThen,
    times: times,
    toLower: toLower,
    toPairs: toPairs,
    toPairsIn: toPairsIn,
    toString: toString,
    toUpper: toUpper,
    transduce: transduce,
    transpose: transpose,
    traverse: traverse,
    trim: trim,
    tryCatch: tryCatch,
    type: type$1,
    unapply: unapply,
    unary: unary,
    uncurryN: uncurryN,
    unfold: unfold,
    union: union,
    unionWith: unionWith,
    uniq: uniq,
    uniqBy: uniqBy,
    uniqWith: uniqWith,
    unless: unless,
    unnest: unnest,
    until: until,
    unwind: unwind,
    update: update,
    useWith: useWith,
    values: values,
    valuesIn: valuesIn,
    view: view,
    when: when,
    where: where,
    whereAny: whereAny,
    whereEq: whereEq,
    without: without,
    xor: xor,
    xprod: xprod,
    zip: zip,
    zipObj: zipObj,
    zipWith: zipWith,
    thunkify: thunkify
  });

  var sanctuaryTypeIdentifiers = {exports: {}};

  /*
          @@@@@@@            @@@@@@@         @@
        @@       @@        @@       @@      @@@
      @@   @@@ @@  @@    @@   @@@ @@  @@   @@@@@@ @@   @@@  @@ @@@      @@@@
     @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@   @@
     @@  @@   @@@   @@  @@  @@   @@@   @@   @@@   @@   @@@  @@@   @@  @@@@@@@@
     @@  @@   @@@  @@   @@  @@   @@@  @@    @@@   @@   @@@  @@@   @@  @@@
      @@   @@@ @@@@@     @@   @@@ @@@@@      @@@    @@@ @@  @@@@@@      @@@@@
        @@                 @@                           @@  @@
          @@@@@@@            @@@@@@@               @@@@@    @@
                                                            */

  (function (module) {
  	//. # sanctuary-type-identifiers
  	//.
  	//. A type is a set of values. Boolean, for example, is the type comprising
  	//. `true` and `false`. A value may be a member of multiple types (`42` is a
  	//. member of Number, PositiveNumber, Integer, and many other types).
  	//.
  	//. In certain situations it is useful to divide JavaScript values into
  	//. non-overlapping types. The language provides two constructs for this
  	//. purpose: the [`typeof`][1] operator and [`Object.prototype.toString`][2].
  	//. Each has pros and cons, but neither supports user-defined types.
  	//.
  	//. sanctuary-type-identifiers comprises:
  	//.
  	//.   - an npm and browser -compatible package for deriving the
  	//.     _type identifier_ of a JavaScript value; and
  	//.   - a specification which authors may follow to specify type
  	//.     identifiers for their types.
  	//.
  	//. ### Specification
  	//.
  	//. For a type to be compatible with the algorithm:
  	//.
  	//.   - every member of the type MUST have a `@@type` property
  	//.     (the _type identifier_); and
  	//.
  	//.   - the type identifier MUST be a string primitive and SHOULD have
  	//.     format `'<namespace>/<name>[@<version>]'`, where:
  	//.
  	//.       - `<namespace>` MUST consist of one or more characters, and
  	//.         SHOULD equal the name of the npm package which defines the
  	//.         type (including [scope][3] where appropriate);
  	//.
  	//.       - `<name>` MUST consist of one or more characters, and SHOULD
  	//.         be the unique name of the type; and
  	//.
  	//.       - `<version>` MUST consist of one or more digits, and SHOULD
  	//.         represent the version of the type.
  	//.
  	//. If the type identifier does not conform to the format specified above,
  	//. it is assumed that the entire string represents the _name_ of the type;
  	//. _namespace_ will be `null` and _version_ will be `0`.
  	//.
  	//. If the _version_ is not given, it is assumed to be `0`.

  	(function(f) {

  	  /* istanbul ignore else */
  	  {
  	    module.exports = f ();
  	  }

  	} (function() {

  	  //  $$type :: String
  	  var $$type = '@@type';

  	  //  pattern :: RegExp
  	  var pattern = new RegExp (
  	    '^'
  	  + '([\\s\\S]+)'   //  <namespace>
  	  + '/'             //  SOLIDUS (U+002F)
  	  + '([\\s\\S]+?)'  //  <name>
  	  + '(?:'           //  optional non-capturing group {
  	  +   '@'           //    COMMERCIAL AT (U+0040)
  	  +   '([0-9]+)'    //    <version>
  	  + ')?'            //  }
  	  + '$'
  	  );

  	  //. ### Usage
  	  //.
  	  //. ```javascript
  	  //. const type = require ('sanctuary-type-identifiers');
  	  //. ```
  	  //.
  	  //. ```javascript
  	  //. > const Identity$prototype = {
  	  //. .   '@@type': 'my-package/Identity@1',
  	  //. .   '@@show': function() {
  	  //. .     return 'Identity (' + show (this.value) + ')';
  	  //. .   }
  	  //. . }
  	  //.
  	  //. > const Identity = value =>
  	  //. .   Object.assign (Object.create (Identity$prototype), {value})
  	  //.
  	  //. > type (Identity (0))
  	  //. 'my-package/Identity@1'
  	  //.
  	  //. > type.parse (type (Identity (0)))
  	  //. {namespace: 'my-package', name: 'Identity', version: 1}
  	  //. ```
  	  //.
  	  //. ### API
  	  //.
  	  //# type :: Any -> String
  	  //.
  	  //. Takes any value and returns a string which identifies its type. If the
  	  //. value conforms to the [specification][4], the custom type identifier is
  	  //. returned.
  	  //.
  	  //. ```javascript
  	  //. > type (null)
  	  //. 'Null'
  	  //.
  	  //. > type (true)
  	  //. 'Boolean'
  	  //.
  	  //. > type (Identity (0))
  	  //. 'my-package/Identity@1'
  	  //. ```
  	  function type(x) {
  	    return x != null &&
  	           x.constructor != null &&
  	           x.constructor.prototype !== x &&
  	           typeof x[$$type] === 'string' ?
  	      x[$$type] :
  	      (Object.prototype.toString.call (x)).slice ('[object '.length,
  	                                                  -']'.length);
  	  }

  	  //# type.parse :: String -> { namespace :: Nullable String, name :: String, version :: Number }
  	  //.
  	  //. Takes any string and parses it according to the [specification][4],
  	  //. returning an object with `namespace`, `name`, and `version` fields.
  	  //.
  	  //. ```javascript
  	  //. > type.parse ('my-package/List@2')
  	  //. {namespace: 'my-package', name: 'List', version: 2}
  	  //.
  	  //. > type.parse ('nonsense!')
  	  //. {namespace: null, name: 'nonsense!', version: 0}
  	  //.
  	  //. > type.parse (type (Identity (0)))
  	  //. {namespace: 'my-package', name: 'Identity', version: 1}
  	  //. ```
  	  type.parse = function parse(s) {
  	    var namespace = null;
  	    var name = s;
  	    var version = 0;
  	    var groups = pattern.exec (s);
  	    if (groups != null) {
  	      namespace = groups[1];
  	      name = groups[2];
  	      if (groups[3] != null) version = Number (groups[3]);
  	    }
  	    return {namespace: namespace, name: name, version: version};
  	  };

  	  return type;

  	}));

  	//. [1]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/typeof
  	//. [2]: https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/toString
  	//. [3]: https://docs.npmjs.com/misc/scope
  	//. [4]: #specification
  } (sanctuaryTypeIdentifiers));

  var type = sanctuaryTypeIdentifiers.exports;

  var FL = {
    alt: 'fantasy-land/alt',
    ap: 'fantasy-land/ap',
    bimap: 'fantasy-land/bimap',
    chain: 'fantasy-land/chain',
    chainRec: 'fantasy-land/chainRec',
    map: 'fantasy-land/map',
    of: 'fantasy-land/of',
    zero: 'fantasy-land/zero'
  };

  var ordinal = ['first', 'second', 'third', 'fourth', 'fifth'];

  var namespace = 'fluture';
  var name = 'Future';
  var version = 5;

  var $$type$1 = namespace + '/' + name + '@' + version;

  function List(head, tail){
    this.head = head;
    this.tail = tail;
  }

  List.prototype.toJSON = function(){
    return toArray(this);
  };

  var nil = new List(null, null);
  nil.tail = nil;

  function isNil(list){
    return list.tail === list;
  }

  // cons :: (a, List a) -> List a
  //      -- O(1) append operation
  function cons(head, tail){
    return new List(head, tail);
  }

  // reverse :: List a -> List a
  //         -- O(n) list reversal
  function reverse(xs){
    var ys = nil, tail = xs;
    while(!isNil(tail)){
      ys = cons(tail.head, ys);
      tail = tail.tail;
    }
    return ys;
  }

  // cat :: (List a, List a) -> List a
  //     -- O(n) list concatenation
  function cat(xs, ys){
    var zs = ys, tail = reverse(xs);
    while(!isNil(tail)){
      zs = cons(tail.head, zs);
      tail = tail.tail;
    }
    return zs;
  }

  // toArray :: List a -> Array a
  //         -- O(n) list to Array
  function toArray(xs){
    var tail = xs, arr = [];
    while(!isNil(tail)){
      arr.push(tail.head);
      tail = tail.tail;
    }
    return arr;
  }

  /* c8 ignore next */
  var captureStackTrace = Error.captureStackTrace || captureStackTraceFallback;
  var _debug = debugHandleNone;

  function debugMode(debug){
    _debug = debug ? debugHandleAll : debugHandleNone;
  }

  function debugHandleNone(x){
    return x;
  }

  function debugHandleAll(x, fn, a, b, c){
    return fn(a, b, c);
  }

  function debug(x, fn, a, b, c){
    return _debug(x, fn, a, b, c);
  }

  function captureContext(previous, tag, fn){
    return debug(previous, debugCaptureContext, previous, tag, fn);
  }

  function debugCaptureContext(previous, tag, fn){
    var context = {tag: tag, name: ' from ' + tag + ':'};
    captureStackTrace(context, fn);
    return cons(context, previous);
  }

  function captureApplicationContext(context, n, f){
    return debug(context, debugCaptureApplicationContext, context, n, f);
  }

  function debugCaptureApplicationContext(context, n, f){
    return debugCaptureContext(context, ordinal[n - 1] + ' application of ' + f.name, f);
  }

  function captureStackTraceFallback(x){
    var e = new Error;
    if(typeof e.stack === 'string'){
      x.stack = x.name + '\n' + e.stack.split('\n').slice(1).join('\n');
    /* c8 ignore next 3 */
    }else {
      x.stack = x.name;
    }
  }

  var sanctuaryShow = {exports: {}};

  (function (module) {
  	//. # sanctuary-show
  	//.
  	//. Haskell has a `show` function which can be applied to a compatible value to
  	//. produce a descriptive string representation of that value. The idea is that
  	//. the string representation should, if possible, be an expression which would
  	//. produce the original value if evaluated.
  	//.
  	//. This library provides a similar [`show`](#show) function.
  	//.
  	//. In general, this property should hold: `eval (show (x)) = x`. In some cases
  	//. parens are necessary to ensure correct interpretation (`{}`, for example,
  	//. is an empty block rather than an empty object in some contexts). Thus the
  	//. property is more accurately stated `eval ('(' + show (x) + ')') = x`.
  	//.
  	//. One can make values of a custom type compatible with [`show`](#show) by
  	//. defining a `@@show` method. For example:
  	//.
  	//. ```javascript
  	//. //# Maybe#@@show :: Maybe a ~> () -> String
  	//. //.
  	//. //. ```javascript
  	//. //. > show (Nothing)
  	//. //. 'Nothing'
  	//. //.
  	//. //. > show (Just (['foo', 'bar', 'baz']))
  	//. //. 'Just (["foo", "bar", "baz"])'
  	//. //. ```
  	//. Maybe.prototype['@@show'] = function() {
  	//.   return this.isNothing ? 'Nothing' : 'Just (' + show (this.value) + ')';
  	//. };
  	//. ```

  	(function(f) {

  	  /* istanbul ignore else */
  	  {
  	    module.exports = f ();
  	  }

  	} (function() {

  	  //  $$show :: String
  	  var $$show = '@@show';

  	  //  seen :: Array Any
  	  var seen = [];

  	  //  entry :: Object -> String -> String
  	  function entry(o) {
  	    return function(k) {
  	      return show (k) + ': ' + show (o[k]);
  	    };
  	  }

  	  //  sortedKeys :: Object -> Array String
  	  function sortedKeys(o) {
  	    return (Object.keys (o)).sort ();
  	  }

  	  //# show :: Showable a => a -> String
  	  //.
  	  //. Returns a useful string representation of the given value.
  	  //.
  	  //. Dispatches to the value's `@@show` method if present.
  	  //.
  	  //. Where practical, `show (eval ('(' + show (x) + ')')) = show (x)`.
  	  //.
  	  //. ```javascript
  	  //. > show (null)
  	  //. 'null'
  	  //.
  	  //. > show (undefined)
  	  //. 'undefined'
  	  //.
  	  //. > show (true)
  	  //. 'true'
  	  //.
  	  //. > show (new Boolean (false))
  	  //. 'new Boolean (false)'
  	  //.
  	  //. > show (-0)
  	  //. '-0'
  	  //.
  	  //. > show (NaN)
  	  //. 'NaN'
  	  //.
  	  //. > show (new Number (Infinity))
  	  //. 'new Number (Infinity)'
  	  //.
  	  //. > show ('foo\n"bar"\nbaz\n')
  	  //. '"foo\\n\\"bar\\"\\nbaz\\n"'
  	  //.
  	  //. > show (new String (''))
  	  //. 'new String ("")'
  	  //.
  	  //. > show (['foo', 'bar', 'baz'])
  	  //. '["foo", "bar", "baz"]'
  	  //.
  	  //. > show ([[[[[0]]]]])
  	  //. '[[[[[0]]]]]'
  	  //.
  	  //. > show ({x: [1, 2], y: [3, 4], z: [5, 6]})
  	  //. '{"x": [1, 2], "y": [3, 4], "z": [5, 6]}'
  	  //. ```
  	  function show(x) {
  	    if (seen.indexOf (x) >= 0) return '<Circular>';

  	    switch (Object.prototype.toString.call (x)) {

  	      case '[object Boolean]':
  	        return typeof x === 'object' ?
  	          'new Boolean (' + show (x.valueOf ()) + ')' :
  	          x.toString ();

  	      case '[object Number]':
  	        return typeof x === 'object' ?
  	          'new Number (' + show (x.valueOf ()) + ')' :
  	          1 / x === -Infinity ? '-0' : x.toString (10);

  	      case '[object String]':
  	        return typeof x === 'object' ?
  	          'new String (' + show (x.valueOf ()) + ')' :
  	          JSON.stringify (x);

  	      case '[object Date]':
  	        return 'new Date (' +
  	               show (isNaN (x.valueOf ()) ? NaN : x.toISOString ()) +
  	               ')';

  	      case '[object Error]':
  	        return 'new ' + x.name + ' (' + show (x.message) + ')';

  	      case '[object Arguments]':
  	        return 'function () { return arguments; } (' +
  	               (Array.prototype.map.call (x, show)).join (', ') +
  	               ')';

  	      case '[object Array]':
  	        seen.push (x);
  	        try {
  	          return '[' + ((x.map (show)).concat (
  	            sortedKeys (x)
  	            .filter (function(k) { return !(/^\d+$/.test (k)); })
  	            .map (entry (x))
  	          )).join (', ') + ']';
  	        } finally {
  	          seen.pop ();
  	        }

  	      case '[object Object]':
  	        seen.push (x);
  	        try {
  	          return (
  	            $$show in x &&
  	            (x.constructor == null || x.constructor.prototype !== x) ?
  	              x[$$show] () :
  	              '{' + ((sortedKeys (x)).map (entry (x))).join (', ') + '}'
  	          );
  	        } finally {
  	          seen.pop ();
  	        }

  	      case '[object Set]':
  	        seen.push (x);
  	        try {
  	          return 'new Set (' + show (Array.from (x.values ())) + ')';
  	        } finally {
  	          seen.pop ();
  	        }

  	      case '[object Map]':
  	        seen.push (x);
  	        try {
  	          return 'new Map (' + show (Array.from (x.entries ())) + ')';
  	        } finally {
  	          seen.pop ();
  	        }

  	      default:
  	        return String (x);

  	    }
  	  }

  	  return show;

  	}));
  } (sanctuaryShow));

  var show = sanctuaryShow.exports;

  /* c8 ignore next */
  var setImmediate$1 = typeof setImmediate$1 === 'undefined' ? setImmediateFallback : setImmediate$1;

  function noop$1(){}
  function moop(){ return this }
  function call(f, x){ return f(x) }

  function setImmediateFallback(f, x){
    return setTimeout(f, 0, x);
  }

  function raise(x){
    setImmediate$1(function rethrowErrorDelayedToEscapePromiseCatch(){
      throw x;
    });
  }

  function showArg$1(x){
    return show(x) + ' :: ' + type.parse(type(x)).name;
  }

  function error(message){
    return new Error(message);
  }

  function typeError(message){
    return new TypeError(message);
  }

  function invalidArgument(it, at, expected, actual){
    return typeError(
      it + '() expects its ' + ordinal[at] + ' argument to ' + expected + '.' +
      '\n  Actual: ' + showArg$1(actual)
    );
  }

  function invalidArgumentOf(expected){
    return function(it, at, actual){
      return invalidArgument(it, at, expected, actual);
    };
  }

  function invalidArity(f, args){
    return new TypeError(
      f.name + '() expects to be called with a single argument per invocation\n' +
      '  Saw: ' + args.length + ' arguments' +
      Array.prototype.slice.call(args).map(function(arg, i){
        return '\n  ' + (
          ordinal[i] ?
          ordinal[i].charAt(0).toUpperCase() + ordinal[i].slice(1) :
          'Argument ' + String(i + 1)
        ) + ': ' + showArg$1(arg);
      }).join('')
    );
  }

  function invalidNamespace(m, x){
    return (
      'The Future was not created by ' + namespace + '. '
    + 'Make sure you transform other Futures to ' + namespace + ' Futures. '
    + 'Got ' + (x ? ('a Future from ' + x) : 'an unscoped Future') + '.'
    + '\n  See: https://github.com/fluture-js/Fluture#casting-futures'
    );
  }

  function invalidVersion(m, x){
    return (
      'The Future was created by ' + (x < version ? 'an older' : 'a newer')
    + ' version of ' + namespace + '. '
    + 'This means that one of the sources which creates Futures is outdated. '
    + 'Update this source, or transform its created Futures to be compatible.'
    + '\n  See: https://github.com/fluture-js/Fluture#casting-futures'
    );
  }

  function invalidFuture(desc, m, s){
    var id = type.parse(type(m));
    var info = id.name === name ? '\n' + (
      id.namespace !== namespace ? invalidNamespace(m, id.namespace)
    : id.version !== version ? invalidVersion(m, id.version)
    : 'Nothing seems wrong. Contact the Fluture maintainers.') : '';
    return typeError(
      desc + ' to be a valid Future.' + info + '\n' +
      '  Actual: ' + show(m) + ' :: ' + id.name + (s || '')
    );
  }

  function invalidFutureArgument(it, at, m, s){
    return invalidFuture(it + '() expects its ' + ordinal[at] + ' argument', m, s);
  }

  function ensureError(value, fn){
    var message;
    try{
      if(value instanceof Error) return value;
      message = 'A Non-Error was thrown from a Future: ' + show(value);
    }catch (_){
      message = 'Something was thrown from a Future, but it could not be converted to String';
    }
    var e = error(message);
    captureStackTrace(e, fn);
    return e;
  }

  function assignUnenumerable(o, prop, value){
    Object.defineProperty(o, prop, {value: value, writable: true, configurable: true});
  }

  function wrapException(caught, callingFuture){
    var origin = ensureError(caught, wrapException);
    var context = cat(origin.context || nil, callingFuture.context);
    var e = error(origin.message);
    assignUnenumerable(e, 'future', origin.future || callingFuture);
    assignUnenumerable(e, 'reason', origin.reason || origin);
    assignUnenumerable(e, 'stack', e.reason.stack);
    return withExtraContext(e, context);
  }

  function withExtraContext(e, context){
    assignUnenumerable(e, 'context', context);
    assignUnenumerable(e, 'stack', e.stack + contextToStackTrace(context));
    return e;
  }

  function contextToStackTrace(context){
    var stack = '', tail = context;
    while(tail !== nil){
      stack = stack + '\n' + tail.head.stack;
      tail = tail.tail;
    }
    return stack;
  }

  function isFunction(f){
    return typeof f === 'function';
  }

  function isThenable(m){
    return m instanceof Promise || m != null && isFunction(m.then);
  }

  function isBoolean(f){
    return typeof f === 'boolean';
  }

  function isNumber(f){
    return typeof f === 'number';
  }

  function isUnsigned(n){
    return (n === Infinity || isNumber(n) && n > 0 && n % 1 === 0);
  }

  function isObject(o){
    return o !== null && typeof o === 'object';
  }

  function isIterator(i){
    return isObject(i) && isFunction(i.next);
  }

  function isArray(x){
    return Array.isArray(x);
  }

  function hasMethod(method, x){
    return x != null && isFunction(x[method]);
  }

  function isFunctor(x){
    return hasMethod(FL.map, x);
  }

  function isAlt(x){
    return isFunctor(x) && hasMethod(FL.alt, x);
  }

  function isApply(x){
    return isFunctor(x) && hasMethod(FL.ap, x);
  }

  function isBifunctor(x){
    return isFunctor(x) && hasMethod(FL.bimap, x);
  }

  function isChain(x){
    return isApply(x) && hasMethod(FL.chain, x);
  }

  function Next(x){
    return {done: false, value: x};
  }

  function Done(x){
    return {done: true, value: x};
  }

  function isIteration(x){
    return isObject(x) && isBoolean(x.done);
  }

  /*eslint no-cond-assign:0, no-constant-condition:0 */

  function alwaysTrue(){
    return true;
  }

  function getArgs(it){
    var args = new Array(it.arity);
    for(var i = 1; i <= it.arity; i++){
      args[i - 1] = it['$' + String(i)];
    }
    return args;
  }

  function showArg(arg){
    return ' (' + show(arg) + ')';
  }

  var any = {pred: alwaysTrue, error: invalidArgumentOf('be anything')};
  var func = {pred: isFunction, error: invalidArgumentOf('be a Function')};
  var future = {pred: isFuture, error: invalidFutureArgument};
  var positiveInteger = {pred: isUnsigned, error: invalidArgumentOf('be a positive Integer')};

  function application(n, f, type, args, prev){
    if(args.length < 2 && type.pred(args[0])) return captureApplicationContext(prev, n, f);
    var e = args.length > 1 ? invalidArity(f, args) : type.error(f.name, n - 1, args[0]);
    captureStackTrace(e, f);
    throw withExtraContext(e, prev);
  }

  function application1(f, type, args){
    return application(1, f, type, args, nil);
  }

  function Future$1(computation){
    var context = application1(Future$1, func, arguments);
    return new Computation(context, computation);
  }

  function isFuture(x){
    return x instanceof Future$1 || type(x) === $$type$1;
  }

  // Compliance with sanctuary-type-identifiers versions 1 and 2.
  // To prevent sanctuary-type-identifiers version 3 from identifying 'Future'
  // as being of the type denoted by $$type, we ensure that
  // Future.constructor.prototype is equal to Future.
  Future$1['@@type'] = $$type$1;
  Future$1.constructor = {prototype: Future$1};

  Future$1[FL.of] = resolve;
  Future$1[FL.chainRec] = chainRec;

  Future$1.prototype['@@type'] = $$type$1;

  Future$1.prototype['@@show'] = function Future$show(){
    return this.toString();
  };

  Future$1.prototype.pipe = function Future$pipe(f){
    if(!isFunction(f)) throw invalidArgument('Future#pipe', 0, 'be a Function', f);
    return f(this);
  };

  Future$1.prototype[FL.ap] = function Future$FL$ap(other){
    var context = captureContext(nil, 'a Fantasy Land dispatch to ap', Future$FL$ap);
    return other._transform(new ApTransformation(context, this));
  };

  Future$1.prototype[FL.map] = function Future$FL$map(mapper){
    var context = captureContext(nil, 'a Fantasy Land dispatch to map', Future$FL$map);
    return this._transform(new MapTransformation(context, mapper));
  };

  Future$1.prototype[FL.bimap] = function Future$FL$bimap(lmapper, rmapper){
    var context = captureContext(nil, 'a Fantasy Land dispatch to bimap', Future$FL$bimap);
    return this._transform(new BimapTransformation(context, lmapper, rmapper));
  };

  Future$1.prototype[FL.chain] = function Future$FL$chain(mapper){
    var context = captureContext(nil, 'a Fantasy Land dispatch to chain', Future$FL$chain);
    return this._transform(new ChainTransformation(context, mapper));
  };

  Future$1.prototype[FL.alt] = function Future$FL$alt(other){
    var context = captureContext(nil, 'a Fantasy Land dispatch to alt', Future$FL$alt);
    return this._transform(new AltTransformation(context, other));
  };

  Future$1.prototype.extractLeft = function Future$extractLeft(){
    return [];
  };

  Future$1.prototype.extractRight = function Future$extractRight(){
    return [];
  };

  Future$1.prototype._transform = function Future$transform(transformation){
    return new Transformer$1(transformation.context, this, cons(transformation, nil));
  };

  Future$1.prototype.isTransformer = false;
  Future$1.prototype.context = nil;
  Future$1.prototype.arity = 0;
  Future$1.prototype.name = 'future';

  Future$1.prototype.toString = function Future$toString(){
    return this.name + getArgs(this).map(showArg).join('');
  };

  Future$1.prototype.toJSON = function Future$toJSON(){
    return {$: $$type$1, kind: 'interpreter', type: this.name, args: getArgs(this)};
  };

  function createInterpreter(arity, name, interpret){
    var Interpreter = function(context, $1, $2, $3){
      this.context = context;
      this.$1 = $1;
      this.$2 = $2;
      this.$3 = $3;
    };

    Interpreter.prototype = Object.create(Future$1.prototype);
    Interpreter.prototype.arity = arity;
    Interpreter.prototype.name = name;
    Interpreter.prototype._interpret = interpret;

    return Interpreter;
  }

  var Computation =
  createInterpreter(1, 'Future', function Computation$interpret(rec, rej, res){
    var computation = this.$1, open = false, cancel = noop$1, cont = function(){ open = true; };
    try{
      cancel = computation(function Computation$rej(x){
        cont = function Computation$rej$cont(){
          open = false;
          rej(x);
        };
        if(open){
          cont();
        }
      }, function Computation$res(x){
        cont = function Computation$res$cont(){
          open = false;
          res(x);
        };
        if(open){
          cont();
        }
      });
    }catch(e){
      rec(wrapException(e, this));
      return noop$1;
    }
    if(!(isFunction(cancel) && cancel.length === 0)){
      rec(wrapException(typeError(
        'The computation was expected to return a nullary cancellation function\n' +
        '  Actual: ' + show(cancel)
      ), this));
      return noop$1;
    }
    cont();
    return function Computation$cancel(){
      if(open){
        open = false;
        cancel && cancel();
      }
    };
  });

  var Never = createInterpreter(0, 'never', function Never$interpret(){
    return noop$1;
  });

  Never.prototype._isNever = true;

  var never = new Never(nil);

  function isNever(x){
    return isFuture(x) && x._isNever === true;
  }

  var Crash = createInterpreter(1, 'crash', function Crash$interpret(rec){
    rec(this.$1);
    return noop$1;
  });

  function crash(x){
    return new Crash(application1(crash, any, arguments), x);
  }

  var Reject = createInterpreter(1, 'reject', function Reject$interpret(rec, rej){
    rej(this.$1);
    return noop$1;
  });

  Reject.prototype.extractLeft = function Reject$extractLeft(){
    return [this.$1];
  };

  function reject(x){
    return new Reject(application1(reject, any, arguments), x);
  }

  var Resolve = createInterpreter(1, 'resolve', function Resolve$interpret(rec, rej, res){
    res(this.$1);
    return noop$1;
  });

  Resolve.prototype.extractRight = function Resolve$extractRight(){
    return [this.$1];
  };

  function resolve(x){
    return new Resolve(application1(resolve, any, arguments), x);
  }

  //Note: This function is not curried because it's only used to satisfy the
  //      Fantasy Land ChainRec specification.
  function chainRec(step, init){
    return resolve(Next(init))._transform(new ChainTransformation(nil, function chainRec$recur(o){
      return o.done ?
             resolve(o.value) :
             step(Next, Done, o.value)._transform(new ChainTransformation(nil, chainRec$recur));
    }));
  }

  var Transformer$1 =
  createInterpreter(2, 'transform', function Transformer$interpret(rec, rej, res){

    //These are the cold, and hot, transformation stacks. The cold actions are those that
    //have yet to run parallel computations, and hot are those that have.
    var cold = nil, hot = nil;

    //These combined variables define our current state.
    // future         = the future we are currently forking
    // transformation = the transformation to be informed when the future settles
    // cancel         = the cancel function of the current future
    // settled        = a boolean indicating whether a new tick should start
    // async          = a boolean indicating whether we are awaiting a result asynchronously
    var future, transformation, cancel = noop$1, settled, async = true, it;

    //Takes a transformation from the top of the hot stack and returns it.
    function nextHot(){
      var x = hot.head;
      hot = hot.tail;
      return x;
    }

    //Takes a transformation from the top of the cold stack and returns it.
    function nextCold(){
      var x = cold.head;
      cold = cold.tail;
      return x;
    }

    //This function is called with a future to use in the next tick.
    //Here we "flatten" the actions of another Sequence into our own actions,
    //this is the magic that allows for infinitely stack safe recursion because
    //actions like ChainAction will return a new Sequence.
    //If we settled asynchronously, we call drain() directly to run the next tick.
    function settle(m){
      settled = true;
      future = m;
      if(future.isTransformer){
        var tail = future.$2;
        while(!isNil(tail)){
          cold = cons(tail.head, cold);
          tail = tail.tail;
        }
        future = future.$1;
      }
      if(async) drain();
    }

    //This function serves as a rejection handler for our current future.
    //It will tell the current transformation that the future rejected, and it will
    //settle the current tick with the transformation's answer to that.
    function rejected(x){
      settle(transformation.rejected(x));
    }

    //This function serves as a resolution handler for our current future.
    //It will tell the current transformation that the future resolved, and it will
    //settle the current tick with the transformation's answer to that.
    function resolved(x){
      settle(transformation.resolved(x));
    }

    //This function is passed into actions when they are "warmed up".
    //If the transformation decides that it has its result, without the need to await
    //anything else, then it can call this function to force "early termination".
    //When early termination occurs, all actions which were stacked prior to the
    //terminator will be skipped. If they were already hot, they will also be
    //sent a cancel signal so they can cancel their own concurrent computations,
    //as their results are no longer needed.
    function early(m, terminator){
      cancel();
      cold = nil;
      if(async && transformation !== terminator){
        transformation.cancel();
        while((it = nextHot()) && it !== terminator) it.cancel();
      }
      settle(m);
    }

    //This will cancel the current Future, the current transformation, and all stacked hot actions.
    function Sequence$cancel(){
      cancel();
      transformation && transformation.cancel();
      while(it = nextHot()) it.cancel();
    }

    //This function is called when an exception is caught.
    function exception(e){
      Sequence$cancel();
      settled = true;
      cold = hot = nil;
      var error = wrapException(e, future);
      future = never;
      rec(error);
    }

    //This function serves to kickstart concurrent computations.
    //Takes all actions from the cold stack in reverse order, and calls run() on
    //each of them, passing them the "early" function. If any of them settles (by
    //calling early()), we abort. After warming up all actions in the cold queue,
    //we warm up the current transformation as well.
    function warmupActions(){
      cold = reverse(cold);
      while(cold !== nil){
        it = cold.head.run(early);
        if(settled) return;
        hot = cons(it, hot);
        cold = cold.tail;
      }
      transformation = transformation.run(early);
    }

    //This function represents our main execution loop. By "tick", we've been
    //referring to the execution of one iteration in the while-loop below.
    function drain(){
      async = false;
      while(true){
        settled = false;
        if(transformation = nextCold()){
          cancel = future._interpret(exception, rejected, resolved);
          if(!settled) warmupActions();
        }else if(transformation = nextHot()){
          cancel = future._interpret(exception, rejected, resolved);
        }else break;
        if(settled) continue;
        async = true;
        return;
      }
      cancel = future._interpret(exception, rej, res);
    }

    //Start the execution loop.
    settle(this);

    //Return the cancellation function.
    return Sequence$cancel;

  });

  Transformer$1.prototype.isTransformer = true;

  Transformer$1.prototype._transform = function Transformer$_transform(transformation){
    return new Transformer$1(transformation.context, this.$1, cons(transformation, this.$2));
  };

  Transformer$1.prototype.toString = function Transformer$toString(){
    return toArray(reverse(this.$2)).reduce(function(str, action){
      return action.name + getArgs(action).map(showArg).join('') + ' (' + str + ')';
    }, this.$1.toString());
  };

  function BaseTransformation$rejected(x){
    this.cancel();
    return new Reject(this.context, x);
  }

  function BaseTransformation$resolved(x){
    this.cancel();
    return new Resolve(this.context, x);
  }

  function BaseTransformation$toJSON(){
    return {$: $$type$1, kind: 'transformation', type: this.name, args: getArgs(this)};
  }

  var BaseTransformation = {
    rejected: BaseTransformation$rejected,
    resolved: BaseTransformation$resolved,
    run: moop,
    cancel: noop$1,
    context: nil,
    arity: 0,
    name: 'transform',
    toJSON: BaseTransformation$toJSON
  };

  function wrapHandler(handler){
    return function transformationHandler(x){
      var m;
      try{
        m = handler.call(this, x);
      }catch(e){
        return new Crash(this.context, e);
      }
      if(isFuture(m)){
        return m;
      }
      return new Crash(this.context, invalidFuture(
        this.name + ' expects the return value from the function it\'s given', m,
        '\n  When called with: ' + show(x)
      ));
    };
  }

  function createTransformation(arity, name, prototype){
    var Transformation = function(context, $1, $2){
      this.context = context;
      this.$1 = $1;
      this.$2 = $2;
    };

    Transformation.prototype = Object.create(BaseTransformation);
    Transformation.prototype.arity = arity;
    Transformation.prototype.name = name;

    if(typeof prototype.rejected === 'function'){
      Transformation.prototype.rejected = wrapHandler(prototype.rejected);
    }

    if(typeof prototype.resolved === 'function'){
      Transformation.prototype.resolved = wrapHandler(prototype.resolved);
    }

    if(typeof prototype.run === 'function'){
      Transformation.prototype.run = prototype.run;
    }

    return Transformation;
  }

  var ApTransformation = createTransformation(1, 'ap', {
    resolved: function ApTransformation$resolved(f){
      if(isFunction(f)) return this.$1._transform(new MapTransformation(this.context, f));
      throw typeError(
        'ap expects the second Future to resolve to a Function\n' +
        '  Actual: ' + show(f)
      );
    }
  });

  var AltTransformation = createTransformation(1, 'alt', {
    rejected: function AltTransformation$rejected(){ return this.$1 }
  });

  var MapTransformation = createTransformation(1, 'map', {
    resolved: function MapTransformation$resolved(x){
      return new Resolve(this.context, call(this.$1, x));
    }
  });

  var BimapTransformation = createTransformation(2, 'bimap', {
    rejected: function BimapTransformation$rejected(x){
      return new Reject(this.context, call(this.$1, x));
    },
    resolved: function BimapTransformation$resolved(x){
      return new Resolve(this.context, call(this.$2, x));
    }
  });

  var ChainTransformation = createTransformation(1, 'chain', {
    resolved: function ChainTransformation$resolved(x){ return call(this.$1, x) }
  });

  var After = createInterpreter(2, 'after', function After$interpret(rec, rej, res){
    var id = setTimeout(res, this.$1, this.$2);
    return function After$cancel(){ clearTimeout(id); };
  });

  After.prototype.extractRight = function After$extractRight(){
    return [this.$2];
  };

  function alwaysNever$1(_){
    return never;
  }

  function after(time){
    var context1 = application1(after, positiveInteger, arguments);
    return time === Infinity ? alwaysNever$1 : (function after(value){
      var context2 = application(2, after, any, arguments, context1);
      return new After(context2, time, value);
    });
  }

  var alternative = {pred: isAlt, error: invalidArgumentOf('have Alt implemented')};

  function alt(left){
    if(isFuture(left)){
      var context1 = application1(alt, future, arguments);
      return function alt(right){
        var context2 = application(2, alt, future, arguments, context1);
        return right._transform(new AltTransformation(context2, left));
      };
    }

    var context = application1(alt, alternative, arguments);
    return function alt(right){
      application(2, alt, alternative, arguments, context);
      return left[FL.alt](right);
    };
  }

  var AndTransformation = createTransformation(1, 'and', {
    resolved: function AndTransformation$resolved(){ return this.$1 }
  });

  function and(left){
    var context1 = application1(and, future, arguments);
    return function and(right){
      var context2 = application(2, and, future, arguments, context1);
      return right._transform(new AndTransformation(context2, left));
    };
  }

  var apply = {pred: isApply, error: invalidArgumentOf('have Apply implemented')};

  function ap(mx){
    if(isFuture(mx)){
      var context1 = application1(ap, future, arguments);
      return function ap(mf){
        var context2 = application(2, ap, future, arguments, context1);
        return mf._transform(new ApTransformation(context2, mx));
      };
    }

    var context = application1(ap, apply, arguments);
    return function ap(mf){
      application(2, ap, apply, arguments, context);
      return mx[FL.ap](mf);
    };
  }

  function invalidPromise(p, f, a){
    return typeError(
      'encaseP() expects the function it\'s given to return a Promise/Thenable'
      + '\n  Actual: ' + show(p) + '\n  From calling: ' + show(f)
      + '\n  With: ' + show(a)
    );
  }

  var EncaseP = createInterpreter(2, 'encaseP', function EncaseP$interpret(rec, rej, res){
    var open = true, fn = this.$1, arg = this.$2, p;
    try{
      p = fn(arg);
    }catch(e){
      rec(wrapException(e, this));
      return noop$1;
    }
    if(!isThenable(p)){
      rec(wrapException(invalidPromise(p, fn, arg), this));
      return noop$1;
    }
    p.then(function EncaseP$res(x){
      if(open){
        open = false;
        res(x);
      }
    }, function EncaseP$rej(x){
      if(open){
        open = false;
        rej(x);
      }
    });
    return function EncaseP$cancel(){ open = false; };
  });

  function encaseP(f){
    var context1 = application1(encaseP, func, arguments);
    return function encaseP(x){
      var context2 = application(2, encaseP, any, arguments, context1);
      return new EncaseP(context2, f, x);
    };
  }

  function attemptP$1(_){
    return encaseP.apply(this, arguments)(undefined);
  }

  var Encase = createInterpreter(2, 'encase', function Encase$interpret(rec, rej, res){
    var fn = this.$1, r;
    try{ r = fn(this.$2); }catch(e){ rej(e); return noop$1 }
    res(r);
    return noop$1;
  });

  function encase(f){
    var context1 = application1(encase, func, arguments);
    return function encase(x){
      var context2 = application(2, encase, any, arguments, context1);
      return new Encase(context2, f, x);
    };
  }

  function attempt(_){
    return encase.apply(this, arguments)(undefined);
  }

  var bifunctor = {pred: isBifunctor, error: invalidArgumentOf('have Bifunctor implemented')};

  function bimap(f){
    var context1 = application1(bimap, func, arguments);
    return function bimap(g){
      var context2 = application(2, bimap, func, arguments, context1);
      return function bimap(m){
        var context3 = application(3, bimap, bifunctor, arguments, context2);
        return isFuture(m) ?
               m._transform(new BimapTransformation(context3, f, g)) :
               m[FL.bimap](f, g);
      };
    };
  }

  var BichainTransformation = createTransformation(2, 'bichain', {
    rejected: function BichainTransformation$rejected(x){ return call(this.$1, x) },
    resolved: function BichainTransformation$resolved(x){ return call(this.$2, x) }
  });

  function bichain(f){
    var context1 = application1(bichain, func, arguments);
    return function bichain(g){
      var context2 = application(2, bichain, func, arguments, context1);
      return function bichain(m){
        var context3 = application(3, bichain, future, arguments, context2);
        return m._transform(new BichainTransformation(context3, f, g));
      };
    };
  }

  function Eager(future){
    var _this = this;
    _this.rec = noop$1;
    _this.rej = noop$1;
    _this.res = noop$1;
    _this.crashed = false;
    _this.rejected = false;
    _this.resolved = false;
    _this.value = null;
    _this.cancel = future._interpret(function Eager$crash(x){
      _this.value = x;
      _this.crashed = true;
      _this.cancel = noop$1;
      _this.rec(x);
    }, function Eager$reject(x){
      _this.value = x;
      _this.rejected = true;
      _this.cancel = noop$1;
      _this.rej(x);
    }, function Eager$resolve(x){
      _this.value = x;
      _this.resolved = true;
      _this.cancel = noop$1;
      _this.res(x);
    });
  }

  Eager.prototype = Object.create(Future$1.prototype);

  Eager.prototype._interpret = function Eager$interpret(rec, rej, res){
    if(this.crashed) rec(this.value);
    else if(this.rejected) rej(this.value);
    else if(this.resolved) res(this.value);
    else {
      this.rec = rec;
      this.rej = rej;
      this.res = res;
    }
    return this.cancel;
  };

  function earlyCrash(early, x){
    early(crash(x));
  }

  function earlyReject(early, x){
    early(reject(x));
  }

  function earlyResolve(early, x){
    early(resolve(x));
  }

  function createParallelTransformation(name, rec, rej, res, prototype){
    var ParallelTransformation = createTransformation(1, name, Object.assign({
      run: function Parallel$run(early){
        var eager = new Eager(this.$1);
        var transformation = new ParallelTransformation(this.context, eager);
        function Parallel$early(m){ early(m, transformation); }
        transformation.cancel = eager._interpret(
          function Parallel$rec(x){ rec(Parallel$early, x); },
          function Parallel$rej(x){ rej(Parallel$early, x); },
          function Parallel$res(x){ res(Parallel$early, x); }
        );
        return transformation;
      }
    }, prototype));
    return ParallelTransformation;
  }

  var PairTransformation = createTransformation(1, 'pair', {
    resolved: function PairTransformation$resolved(x){
      return new Resolve(this.context, [x, this.$1]);
    }
  });

  var BothTransformation =
  createParallelTransformation('both', earlyCrash, earlyReject, noop$1, {
    resolved: function BothTransformation$resolved(x){
      return this.$1._transform(new PairTransformation(this.context, x));
    }
  });

  function both(left){
    var context1 = application1(both, future, arguments);
    return function both(right){
      var context2 = application(2, both, future, arguments, context1);
      return right._transform(new BothTransformation(context2, left));
    };
  }

  var Cold = 0;
  var Pending = 1;
  var Crashed = 2;
  var Rejected = 3;
  var Resolved = 4;

  function Queued(rec, rej, res){
    this[Crashed] = rec;
    this[Rejected] = rej;
    this[Resolved] = res;
  }

  var Cache = createInterpreter(1, 'cache', function Cache$interpret(rec, rej, res){
    var cancel = noop$1;

    switch(this._state){
      /* c8 ignore next 4 */
      case Pending: cancel = this._addToQueue(rec, rej, res); break;
      case Crashed: rec(this._value); break;
      case Rejected: rej(this._value); break;
      case Resolved: res(this._value); break;
      default:
        this._queue = [];
        cancel = this._addToQueue(rec, rej, res);
        this.run();
    }

    return cancel;
  });

  Cache.prototype._cancel = noop$1;
  Cache.prototype._queue = null;
  Cache.prototype._queued = 0;
  Cache.prototype._value = undefined;
  Cache.prototype._state = Cold;

  Cache.prototype.extractLeft = function Cache$extractLeft(){
    return this._state === Rejected ? [this._value] : [];
  };

  Cache.prototype.extractRight = function Cache$extractRight(){
    return this._state === Resolved ? [this._value] : [];
  };

  Cache.prototype._addToQueue = function Cache$addToQueue(rec, rej, res){
    var _this = this;
    if(_this._state > Pending) return noop$1;
    var i = _this._queue.push(new Queued(rec, rej, res)) - 1;
    _this._queued = _this._queued + 1;

    return function Cache$removeFromQueue(){
      if(_this._state > Pending) return;
      _this._queue[i] = undefined;
      _this._queued = _this._queued - 1;
      if(_this._queued === 0) _this.reset();
    };
  };

  Cache.prototype._drainQueue = function Cache$drainQueue(){
    if(this._state <= Pending) return;
    if(this._queued === 0) return;
    var queue = this._queue;
    var length = queue.length;
    var state = this._state;
    var value = this._value;

    for(var i = 0; i < length; i++){
      queue[i] && queue[i][state](value);
      queue[i] = undefined;
    }

    this._queue = undefined;
    this._queued = 0;
  };

  Cache.prototype.crash = function Cache$crash(error){
    if(this._state > Pending) return;
    this._value = error;
    this._state = Crashed;
    this._drainQueue();
  };

  Cache.prototype.reject = function Cache$reject(reason){
    if(this._state > Pending) return;
    this._value = reason;
    this._state = Rejected;
    this._drainQueue();
  };

  Cache.prototype.resolve = function Cache$resolve(value){
    if(this._state > Pending) return;
    this._value = value;
    this._state = Resolved;
    this._drainQueue();
  };

  Cache.prototype.run = function Cache$run(){
    var _this = this;
    if(_this._state > Cold) return;
    _this._state = Pending;
    _this._cancel = _this.$1._interpret(
      function Cache$fork$rec(x){ _this.crash(x); },
      function Cache$fork$rej(x){ _this.reject(x); },
      function Cache$fork$res(x){ _this.resolve(x); }
    );
  };

  Cache.prototype.reset = function Cache$reset(){
    if(this._state === Cold) return;
    if(this._state === Pending) this._cancel();
    this._cancel = noop$1;
    this._queue = [];
    this._queued = 0;
    this._value = undefined;
    this._state = Cold;
  };

  function cache(m){
    return new Cache(application1(cache, future, arguments), m);
  }

  var ChainRejTransformation = createTransformation(1, 'chainRej', {
    rejected: function ChainRejTransformation$rejected(x){ return call(this.$1, x) }
  });

  function chainRej(f){
    var context1 = application1(chainRej, func, arguments);
    return function chainRej(m){
      var context2 = application(2, chainRej, future, arguments, context1);
      return m._transform(new ChainRejTransformation(context2, f));
    };
  }

  var monad = {pred: isChain, error: invalidArgumentOf('have Chain implemented')};

  function chain(f){
    var context1 = application1(chain, func, arguments);
    return function chain(m){
      var context2 = application(2, chain, monad, arguments, context1);
      return isFuture(m) ?
             m._transform(new ChainTransformation(context2, f)) :
             m[FL.chain](f);
    };
  }

  function done(callback){
    var context1 = application1(done, func, arguments);
    function done$res(x){
      callback(null, x);
    }
    return function done(m){
      application(2, done, future, arguments, context1);
      return m._interpret(raise, callback, done$res);
    };
  }

  function extractLeft(m){
    application1(extractLeft, future, arguments);
    return m.extractLeft();
  }

  function extractRight(m){
    application1(extractRight, future, arguments);
    return m.extractRight();
  }

  var CoalesceTransformation = createTransformation(2, 'coalesce', {
    rejected: function CoalesceTransformation$rejected(x){
      return new Resolve(this.context, call(this.$1, x));
    },
    resolved: function CoalesceTransformation$resolved(x){
      return new Resolve(this.context, call(this.$2, x));
    }
  });

  function coalesce(f){
    var context1 = application1(coalesce, func, arguments);
    return function coalesce(g){
      var context2 = application(2, coalesce, func, arguments, context1);
      return function coalesce(m){
        var context3 = application(3, coalesce, future, arguments, context2);
        return m._transform(new CoalesceTransformation(context3, f, g));
      };
    };
  }

  function forkCatch(f){
    var context1 = application1(forkCatch, func, arguments);
    return function forkCatch(g){
      var context2 = application(2, forkCatch, func, arguments, context1);
      return function forkCatch(h){
        var context3 = application(3, forkCatch, func, arguments, context2);
        return function forkCatch(m){
          application(4, forkCatch, future, arguments, context3);
          return m._interpret(f, g, h);
        };
      };
    };
  }

  function fork(f){
    var context1 = application1(fork, func, arguments);
    return function fork(g){
      var context2 = application(2, fork, func, arguments, context1);
      return function fork(m){
        application(3, fork, future, arguments, context2);
        return m._interpret(raise, f, g);
      };
    };
  }

  var Undetermined = 0;
  var Synchronous = 1;
  var Asynchronous = 2;

  /*eslint consistent-return: 0 */

  function invalidIteration(o){
    return typeError(
      'The iterator did not return a valid iteration from iterator.next()\n' +
      '  Actual: ' + show(o)
    );
  }

  function invalidState(x){
    return invalidFuture(
      'go() expects the value produced by the iterator', x,
      '\n  Tip: If you\'re using a generator, make sure you always yield a Future'
    );
  }

  var Go = createInterpreter(1, 'go', function Go$interpret(rec, rej, res){

    var _this = this, timing = Undetermined, cancel = noop$1, state, value, iterator;

    function crash(e){
      rec(wrapException(e, _this));
    }

    try{
      iterator = _this.$1();
    }catch(e){
      crash(e);
      return noop$1;
    }

    if(!isIterator(iterator)){
      crash(invalidArgument('go', 0, 'return an iterator, maybe you forgot the "*"', iterator));
      return noop$1;
    }

    function resolved(x){
      value = x;
      if(timing === Asynchronous) return drain();
      timing = Synchronous;
    }

    function drain(){
      //eslint-disable-next-line no-constant-condition
      while(true){
        try{
          state = iterator.next(value);
        }catch(e){
          return crash(e);
        }
        if(!isIteration(state)) return crash(invalidIteration(state));
        if(state.done) break;
        if(!isFuture(state.value)){
          return crash(invalidState(state.value));
        }
        timing = Undetermined;
        cancel = state.value._interpret(crash, rej, resolved);
        if(timing === Undetermined) return timing = Asynchronous;
      }
      res(state.value);
    }

    drain();

    return function Go$cancel(){ cancel(); };

  });

  function go(generator){
    return new Go(application1(go, func, arguments), generator);
  }

  function invalidDisposal(m, f, x){
    return invalidFuture(
      'hook() expects the return value from the first function it\'s given', m,
      '\n  From calling: ' + show(f) + '\n  With: ' + show(x)
    );
  }

  function invalidConsumption(m, f, x){
    return invalidFuture(
      'hook() expects the return value from the second function it\'s given', m,
      '\n  From calling: ' + show(f) + '\n  With: ' + show(x)
    );
  }

  var Hook = createInterpreter(3, 'hook', function Hook$interpret(rec, rej, res){

    var _this = this, _acquire = this.$1, _dispose = this.$2, _consume = this.$3;
    var cancel, cancelConsume = noop$1, resource, value, cont = noop$1;

    function Hook$done(){
      cont(value);
    }

    function Hook$rec(x){
      rec(wrapException(x, _this));
    }

    function Hook$dispose(){
      var disposal;
      try{
        disposal = _dispose(resource);
      }catch(e){
        return Hook$rec(e);
      }
      if(!isFuture(disposal)){
        return Hook$rec(invalidDisposal(disposal, _dispose, resource));
      }
      cancel = Hook$cancelDisposal;
      disposal._interpret(Hook$rec, Hook$disposalRejected, Hook$done);
    }

    function Hook$cancelConsumption(){
      cancelConsume();
      Hook$dispose();
      Hook$cancelDisposal();
    }

    function Hook$cancelDisposal(){
      cont = noop$1;
    }

    function Hook$disposalRejected(x){
      Hook$rec(new Error('The disposal Future rejected with ' + show(x)));
    }

    function Hook$consumptionException(x){
      cont = Hook$rec;
      value = x;
      Hook$dispose();
    }

    function Hook$consumptionRejected(x){
      cont = rej;
      value = x;
      Hook$dispose();
    }

    function Hook$consumptionResolved(x){
      cont = res;
      value = x;
      Hook$dispose();
    }

    function Hook$consume(x){
      resource = x;
      var consumption;
      try{
        consumption = _consume(resource);
      }catch(e){
        return Hook$consumptionException(e);
      }
      if(!isFuture(consumption)){
        return Hook$consumptionException(invalidConsumption(consumption, _consume, resource));
      }
      cancel = Hook$cancelConsumption;
      cancelConsume = consumption._interpret(
        Hook$consumptionException,
        Hook$consumptionRejected,
        Hook$consumptionResolved
      );
    }

    var cancelAcquire = _acquire._interpret(Hook$rec, rej, Hook$consume);
    cancel = cancel || cancelAcquire;

    return function Hook$fork$cancel(){
      rec = raise;
      cancel();
    };

  });

  function hook(acquire){
    var context1 = application1(hook, future, arguments);
    return function hook(dispose){
      var context2 = application(2, hook, func, arguments, context1);
      return function hook(consume){
        var context3 = application(3, hook, func, arguments, context2);
        return new Hook(context3, acquire, dispose, consume);
      };
    };
  }

  var LastlyTransformation = createTransformation(1, 'lastly', {
    rejected: function LastlyAction$rejected(x){
      return this.$1._transform(new AndTransformation(this.context, new Reject(this.context, x)));
    },
    resolved: function LastlyAction$resolved(x){
      return this.$1._transform(new AndTransformation(this.context, new Resolve(this.context, x)));
    }
  });

  function lastly(cleanup){
    var context1 = application1(lastly, future, arguments);
    return function lastly(program){
      var context2 = application(2, lastly, future, arguments, context1);
      return program._transform(new LastlyTransformation(context2, cleanup));
    };
  }

  var MapRejTransformation = createTransformation(1, 'mapRej', {
    rejected: function MapRejTransformation$rejected(x){
      return new Reject(this.context, call(this.$1, x));
    }
  });

  function mapRej(f){
    var context1 = application1(mapRej, func, arguments);
    return function mapRej(m){
      var context2 = application(2, mapRej, future, arguments, context1);
      return m._transform(new MapRejTransformation(context2, f));
    };
  }

  var functor = {pred: isFunctor, error: invalidArgumentOf('have Functor implemented')};

  function map(f){
    var context1 = application1(map, func, arguments);
    return function map(m){
      var context2 = application(2, map, functor, arguments, context1);
      return isFuture(m) ?
             m._transform(new MapTransformation(context2, f)) :
             m[FL.map](f);
    };
  }

  var Node = createInterpreter(1, 'node', function Node$interpret(rec, rej, res){
    function Node$done(err, val){
      cont = err ? function EncaseN3$rej(){
        open = false;
        rej(err);
      } : function EncaseN3$res(){
        open = false;
        res(val);
      };
      if(open){
        cont();
      }
    }
    var open = false, cont = function(){ open = true; };
    try{
      call(this.$1, Node$done);
    }catch(e){
      rec(wrapException(e, this));
      open = false;
      return noop$1;
    }
    cont();
    return function Node$cancel(){ open = false; };
  });

  function node(f){
    return new Node(application1(node, func, arguments), f);
  }

  var ParallelApTransformation =
  createParallelTransformation('pap', earlyCrash, earlyReject, noop$1, {
    resolved: function ParallelApTransformation$resolved(f){
      if(isFunction(f)) return this.$1._transform(new MapTransformation(this.context, f));
      throw typeError(
        'pap expects the second Future to resolve to a Function\n' +
        '  Actual: ' + show(f)
      );
    }
  });

  function pap(mx){
    var context1 = application1(pap, future, arguments);
    return function pap(mf){
      var context2 = application(2, pap, future, arguments, context1);
      return mf._transform(new ParallelApTransformation(context2, mx));
    };
  }

  function isFutureArray(xs){
    if(!isArray(xs)) return false;
    for(var i = 0; i < xs.length; i++){
      if(!isFuture(xs[i])) return false;
    }
    return true;
  }

  var futureArray = {
    pred: isFutureArray,
    error: invalidArgumentOf('be an Array of valid Futures')
  };

  var Parallel = createInterpreter(2, 'parallel', function Parallel$interpret(rec, rej, res){

    var _this = this, futures = this.$2, length = futures.length;
    var max = Math.min(this.$1, length), cancels = new Array(length), out = new Array(length);
    var cursor = 0, running = 0, blocked = false, cont = noop$1;

    function Parallel$cancel(){
      rec = noop$1;
      rej = noop$1;
      res = noop$1;
      cursor = length;
      for(var n = 0; n < length; n++) cancels[n] && cancels[n]();
    }

    function Parallel$run(idx){
      running++;
      cancels[idx] = futures[idx]._interpret(function Parallel$rec(e){
        cont = rec;
        cancels[idx] = noop$1;
        Parallel$cancel();
        cont(wrapException(e, _this));
      }, function Parallel$rej(reason){
        cont = rej;
        cancels[idx] = noop$1;
        Parallel$cancel();
        cont(reason);
      }, function Parallel$res(value){
        cancels[idx] = noop$1;
        out[idx] = value;
        running--;
        if(cursor === length && running === 0) res(out);
        else if(blocked) Parallel$drain();
      });
    }

    function Parallel$drain(){
      blocked = false;
      while(cursor < length && running < max) Parallel$run(cursor++);
      blocked = true;
    }

    Parallel$drain();

    return Parallel$cancel;

  });

  var emptyArray = resolve([]);

  function parallel$2(max){
    var context1 = application1(parallel$2, positiveInteger, arguments);
    return function parallel(ms){
      var context2 = application(2, parallel, futureArray, arguments, context1);
      return ms.length === 0 ? emptyArray : new Parallel(context2, max, ms);
    };
  }

  var RaceTransformation =
  createParallelTransformation('race', earlyCrash, earlyReject, earlyResolve, {});

  function race(left){
    var context1 = application1(race, future, arguments);
    return function race(right){
      var context2 = application(2, race, future, arguments, context1);
      return right._transform(new RaceTransformation(context2, left));
    };
  }

  function ConcurrentFuture (sequential){
    this.sequential = sequential;
  }

  ConcurrentFuture.prototype = Object.create(Par.prototype);

  function Par (sequential){
    if(!isFuture(sequential)) throw invalidFutureArgument(Par.name, 0, sequential);
    return new ConcurrentFuture(sequential);
  }

  var $$type = namespace + '/ConcurrentFuture@' + version;
  var zeroInstance = new ConcurrentFuture(never);

  // Compliance with sanctuary-type-identifiers versions 1 and 2.
  // To prevent sanctuary-type-identifiers version 3 from identifying
  // 'Par' as being of the type denoted by $$type, we ensure that
  // Par.constructor.prototype is equal to Par.
  Par['@@type'] = $$type;
  Par.constructor = {prototype: Par};

  Par[FL.of] = function Par$of(x){
    return new ConcurrentFuture(resolve(x));
  };

  Par[FL.zero] = function Par$zero(){
    return zeroInstance;
  };

  Par.prototype['@@type'] = $$type;

  Par.prototype['@@show'] = function Par$show(){
    return this.toString();
  };

  Par.prototype.toString = function Par$toString(){
    return 'Par (' + this.sequential.toString() + ')';
  };

  Par.prototype[FL.map] = function Par$FL$map(f){
    var context = captureContext(
      nil,
      'a Fantasy Land dispatch to map via ConcurrentFuture',
      Par$FL$map
    );
    return new ConcurrentFuture(this.sequential._transform(new MapTransformation(context, f)));
  };

  Par.prototype[FL.ap] = function Par$FL$ap(other){
    var context = captureContext(
      nil,
      'a Fantasy Land dispatch to ap via ConcurrentFuture',
      Par$FL$ap
    );
    return new ConcurrentFuture(other.sequential._transform(
      new ParallelApTransformation(context, this.sequential)
    ));
  };

  Par.prototype[FL.alt] = function Par$FL$alt(other){
    var context = captureContext(
      nil,
      'a Fantasy Land dispatch to alt via ConcurrentFuture',
      Par$FL$alt
    );
    return new ConcurrentFuture(other.sequential._transform(
      new RaceTransformation(context, this.sequential)
    ));
  };

  function isParallel(x){
    return x instanceof ConcurrentFuture || type(x) === $$type;
  }

  function promise(m){
    application1(promise, future, arguments);
    return new Promise(function promise$computation(res, rej){
      m._interpret(rej, rej, res);
    });
  }

  var RejectAfter =
  createInterpreter(2, 'rejectAfter', function RejectAfter$interpret(rec, rej){
    var id = setTimeout(rej, this.$1, this.$2);
    return function RejectAfter$cancel(){ clearTimeout(id); };
  });

  RejectAfter.prototype.extractLeft = function RejectAfter$extractLeft(){
    return [this.$2];
  };

  function alwaysNever(_){
    return never;
  }

  function rejectAfter(time){
    var context1 = application1(rejectAfter, positiveInteger, arguments);
    return time === Infinity ? alwaysNever : (function rejectAfter(value){
      var context2 = application(2, rejectAfter, any, arguments, context1);
      return new RejectAfter(context2, time, value);
    });
  }

  var parallel$1 = {pred: isParallel, error: invalidArgumentOf('be a ConcurrentFuture')};

  function seq(par){
    application1(seq, parallel$1, arguments);
    return par.sequential;
  }

  var SwapTransformation = createTransformation(0, 'swap', {
    resolved: function SwapTransformation$resolved(x){
      return new Reject(this.context, x);
    },
    rejected: function SwapTransformation$rejected(x){
      return new Resolve(this.context, x);
    }
  });

  function swap(m){
    var context = application1(swap, future, arguments);
    return m._transform(new SwapTransformation(context));
  }

  function value(res){
    var context1 = application1(value, func, arguments);
    return function value(m){
      application(2, value, future, arguments, context1);
      function value$rej(x){
        raise(error(
          'Future#value was called on a rejected Future\n' +
          '  Rejection: ' + show(x) + '\n' +
          '  Future: ' + show(m)
        ));
      }
      return m._interpret(raise, value$rej, res);
    };
  }

  var F$1 = /*#__PURE__*/Object.freeze({
    __proto__: null,
    'default': Future$1,
    Future: Future$1,
    isFuture: isFuture,
    isNever: isNever,
    never: never,
    reject: reject,
    resolve: resolve,
    after: after,
    alt: alt,
    and: and,
    ap: ap,
    attemptP: attemptP$1,
    attempt: attempt,
    bimap: bimap,
    bichain: bichain,
    both: both,
    cache: cache,
    chainRej: chainRej,
    chain: chain,
    done: done,
    encaseP: encaseP,
    encase: encase,
    extractLeft: extractLeft,
    extractRight: extractRight,
    coalesce: coalesce,
    forkCatch: forkCatch,
    fork: fork,
    go: go,
    hook: hook,
    lastly: lastly,
    mapRej: mapRej,
    map: map,
    node: node,
    pap: pap,
    parallel: parallel$2,
    Par: Par,
    promise: promise,
    race: race,
    rejectAfter: rejectAfter,
    seq: seq,
    swap: swap,
    value: value,
    debugMode: debugMode
  });

  // ts-check
  const { cloneDeep } = _;

  // Only needed for testing
  // import {  after, both, chain, map, fork } from 'fluture';
  // import { repeat, CustomError } from './jsUtils.js' 

  const RE = {};

  const groupByWithCalcUnc = (cond, keyOp) => data => {

    const opsToApply = Object.entries(keyOp);

    const groupObj = data.reduce(
      (acum, current, index) => {
        const indexRow = cond(current);
        opsToApply.forEach(
          ([key, opFunc]) => {
            acum[indexRow] = acum[indexRow] ?? {};
            acum[indexRow][key] = opFunc(acum[indexRow]?.[key], current?.[key]);
          }
        );
        acum[indexRow] = { ...current, ...acum[indexRow] };
        return acum
      },
      {}
    );

    return Object.values(groupObj)
  };

  const groupByWithCalc = curryN(2, groupByWithCalcUnc);
  RE.groupByWithCalc = groupByWithCalc;
  // RE.groupByWithCalc(
  //   (row) => row.date,
  //   {
  //     total:(l,r) => (l??0) + r,
  //     count:(l,r) => (l??0) + 1
  //   },
  // )(
  //   [
  //     {date:'2020-01-02', total:6}, 
  //     {date:'2020-01-03', total:5}, 
  //     {date:'2020-01-02', total:11}, 
  //     {date:'2020-01-03', total:6}, 
  //     {date:'2020-01-02', total:-5}
  //   ]
  // )//?

  const innerRightJoinWithUnc = (joinCond, transform = (k, l, r) => r, left, right) => {

    const joinCondCurry = uncurryN(2, joinCond);
    return chain$1(rightRow => {

      const mergeRecords = pipe$1(
        filter(joinCondCurry(__, rightRow)),
        map$1(mergeWithKey(transform, __, rightRow))
      )(left);

      if (mergeRecords.length === 0) return rightRow

      return mergeRecords

    })(right)

  };
  const innerRightJoinWith = curryN(4, innerRightJoinWithUnc);
  RE.innerRightJoinWith = innerRightJoinWith;
  // RE.innerRightJoinWith(
  //   (l,r) => l.date === r.date,
  //   (k, l, r) => k==='total' 
  //     ? l + r
  //     : r,
  //   [{date:'2020-01-02', total:6},  {date:'2020-01-08', total:8}, {date:'2020-01-03', total:5}]
  // )
  // (
  //   [{date:'2020-01-02', total:11},  {date:'2020-01-09', total:9}, {date:'2020-01-03', total:6}]
  // )//?

  function unionWithHashKeysUnc(isAsc, hashAddNoDups, addNoDupsToTheEnd, hashMaster, master) {
    const union = new Map();

    for (let elem of master) {
      union.set(hashMaster(elem), elem);
    }

    for (let elem of addNoDupsToTheEnd) {
      if (union.get(hashAddNoDups(elem)) === undefined) union.set(hashAddNoDups(elem), elem);
    }

    if (isAsc === true || isAsc === false) {
      return Array.from(union.entries()).sort(sorterByPaths('0', isAsc)).map(elem => elem[1])
    }

    return Array.from(union.values())
  }
  const unionWithHashKeys = curryN(5, unionWithHashKeysUnc);
  RE.unionWithHashKeys = unionWithHashKeys;
  // RE.unionWithHashKeys(undefined,
  //   elem=>elem.date,
  //   [{date:'2020-01-02', a:4},{date:'2020-01-03'}],
  //   elem=>elem.date
  // )(
  //   [{date:'2020-01-01'},{date:'2020-01-02',a:1}]
  // )//?


  // function updateWithHashKeysUnc(isAsc, hashAddNoDups, addNoDupsToTheEnd, hashMaster, master) {
  //   const union = new Map()

  //   for (let elem of master) {
  //     union.set(hashMaster(elem), elem)
  //   }

  //   for (let elem of addNoDupsToTheEnd) {
  //     union.set(hashAddNoDups(elem), elem)
  //   }

  //   if(isAsc === true || isAsc === false) {
  //     return Array.from(union.entries()).sort(sorterByPaths('0',isAsc)).map(elem => elem[1]) 
  //   }

  //   return Array.from(union.values())
  // }
  // const updateWithHashKeys = R.curryN(5, updateWithHashKeysUnc)
  // RE.updateWithHashKeys = updateWithHashKeys
  // RE.updateWithHashKeys(
  //   true,
  //   elem=>elem.date,
  //   [{date:'2020-01-08'},{date:'2020-01-03'},{date:'2020-01-02',a:2},{date:'2020-01-05',a:1}],
  //   elem=>elem.date
  // )(
  //   [{date:'2020-01-08',a:4},{date:'2020-01-01',a:1},{date:'2020-01-05',a:5}]
  // )//?


  function isOldLessThanNew(hashOldRecords, hashNewRecords) {
    if (hashOldRecords === hashNewRecords) return false

    if (hashNewRecords === undefined) return true
    if (hashOldRecords < hashNewRecords) return true

    return false
  }

  function isOldGreatThanNew(hashOldRecords, hashNewRecords) {
    if (hashOldRecords === hashNewRecords) return false

    if (hashOldRecords === undefined) return true
    if (hashOldRecords > hashNewRecords) return true

    return false
  }

  function callFuncOrUndefinedIfError(value, func) {
    try {
      return func(value)
    } catch (err) {
      return undefined
    }
  }

  function updateWithHashKeysUnc(isAsc, getHashNewRecords, newRecords, getHashOldRecords, oldRecords) {
    const union = new Map();

    let hashNewRecords = callFuncOrUndefinedIfError(newRecords[0], getHashNewRecords);
    let hashOldRecords = callFuncOrUndefinedIfError(oldRecords[0], getHashOldRecords);

    for (let i = 0, j = 0; i < newRecords.length || j < oldRecords.length;) {
      if (isOldLessThanNew(hashOldRecords, hashNewRecords)) {
        if (union.get(hashOldRecords) === undefined) union.set(hashOldRecords, oldRecords[j]);
        j++;
        hashOldRecords = callFuncOrUndefinedIfError(oldRecords[j], getHashOldRecords);
      } else {
        if (isOldGreatThanNew(hashOldRecords, hashNewRecords)) {
          union.set(hashNewRecords, newRecords[i]);
          i++;
          hashNewRecords = callFuncOrUndefinedIfError(newRecords[i], getHashNewRecords);
        } else {
          union.set(hashNewRecords, newRecords[i]);
          i++;
          j++;

          hashNewRecords = callFuncOrUndefinedIfError(newRecords[i], getHashNewRecords);
          hashOldRecords = callFuncOrUndefinedIfError(oldRecords[j], getHashOldRecords);
        }
      }
    }

    if (isAsc === true || isAsc === false) {
      return Array.from(union.entries()).sort(sorterByPaths('0', isAsc)).map(elem => elem[1])
    }

    return Array.from(union.values())
  }
  const updateWithHashKeys = curryN(5, updateWithHashKeysUnc);
  RE.updateWithHashKeys = updateWithHashKeys;
  // RE.updateWithHashKeys(
  //   true,
  //   elem=>elem.date,
  //    [{date:'2020-01-08'},{date:'2020-01-03'},{date:'2020-01-02',a:2},{date:'2020-01-05',a:1}],
  //    elem=>elem.date
  // )(
  //   [{date:'2020-01-08',a:4},{date:'2020-01-01',a:1},{date:'2020-01-05',a:5}]
  // )//?

  // RE.updateWithHashKeys(
  //   undefined,
  //   elem=>elem.date,
  //    [{date:'2020-01-01'},{date:'2020-01-03'},{date:'2020-01-05',a:2},{date:'2020-01-08',a:1}],
  //    elem=>elem.date
  // )(
  //   [{date:'2020-01-02',a:4},{date:'2020-01-03',a:1},{date:'2020-01-08',a:5}]
  // )//?



  const between = curry((l, r) => (both$1(gte(__, l), lt(__, r))));
  RE.between = between;

  const matchById = (l, r) =>
    isNil$1(l) === false
    && isNil$1(r) === false
    && ((l.id || l.Id || l.ID) === (r.id || r.Id || r.ID))
    && ((l.id || l.Id || l.ID) !== undefined);


  const matchByPropId = curryN(2, matchById);
  RE.matchByPropId = matchByPropId;

  // Returns matching in 1st index and filtered out in 0 index... followin success goes to the end rule.
  function splitCondUnc(condFun, array) {
    return reduce((acu, cur) => {
      if (condFun(cur)) return update(1, append(cur, acu[1]), acu)
      else return update(0, append(cur, acu[0]), acu)
    }, [[], []])
  }
  const splitCond = curryN(2, splitCondUnc);
  RE.splitCond = splitCond;

  const filterMap = curry(
    (filter, map, data) =>
      reduce(
        (acum, current) =>
          filter(current) ?
            append(map(current), acum) :
            acum, [], data)
  );
  RE.filterMap = filterMap;

  const mapWithNext = curry(
    (mapper, endValue, array) =>
      array.map(
        (elem, index) => {
          let nextValue;
          if (index === array.length - 1) nextValue = endValue;
          else nextValue = array[index + 1];
          return mapper(elem, nextValue)
        }
      )
  );
  RE.mapWithNext = mapWithNext;

  const mapWithPrevious = curry(
    (mapper, iniValue, array) =>
      array.map(
        (elem, index) => {
          let previousValue;
          if (index === 0) previousValue = iniValue;
          else previousValue = array[index - 1];
          return mapper(previousValue, elem)
        }
      )
  );
  RE.mapWithPrevious = mapWithPrevious;

  const n0IsNotUnfold =
    pipe$1(
      propEq('0', 'unfold'),
      not
    );

  const n1IsFunction =
    pipe$1(
      prop('1'),
      type$1,
      equals('Function')
    );

  function something(lib) {
    return (...args) =>
      pipe$1(
        // Convert to an array of for each function with array of 2 elements: 0 (key) name of function, 1 (value) function
        Object.entries,
        RE.filterMap(
          both$1(
            n0IsNotUnfold,
            n1IsFunction
          ),
          chain$1(
            // add a 3rd value. Now we will have 0: name function, 1: function, 2 result
            append,
            pipe$1(
              //R.tap(R.pipe(R.prop('0'),console.log)),
              prop('1'),
              tryCatch(
                pipe$1(
                  //R.uncurryN(args.length),
                  fun => {
                    const funU = uncurry(true)(fun);
                    const firstResult = funU(...clone$1(args));

                    if (typeof firstResult[0] === 'function' && args.length > 1) {
                      return funU(clone$1(...init(args)))(clone$1(last(args)))
                    }
                    return firstResult
                  }
                ),
                (exc, fun) => {
                  try {
                    return [
                      fun(clone$1(...init(args)))(clone$1(last(args))),
                      '(all,arguments,but)(last)'
                    ]
                  } catch (e) {
                    return ['error']
                  }
                }
              ),
              //R.tap(console.log)//(R.pipe(R.prop('2'),console.log)),
            )
          )
        )
      )(lib)
  }

  /* Returns:
  [ { fun: 'applySpec', sign: '(object)(object)' },
    { fun: 'juxt', sign: '(object)(object)' } ]
  */
  //findSolution([{a:2},{a:2,b:2}, 7], something(R)([obj=>obj,obj=>({...obj, b:2}), obj=>obj.a+5], {a:2})) //?

  /*
    findSolution(solution, something(R)(param1, param2, param3))

    Find the function in the library (this case R) that calling using the params gives the input solution.

    for example below: 
      We need to find a function in R that given the parameters 4,3 the result is 7. Of course it is R.add
  */
  //const Rsomething = something(R)
  //findSolution(7, Rsomething(4, 3)) //?
  //
  // findSolution(
  //   [[true,false],[1,{a:2},3]], 
  //   something(R)(
  //     (elem)=> typeof elem === 'boolean'?0:1,
  //     [true, 1, {a:2},false,3]
  //   )
  // ) //? [ { fun: 'collectBy', sign: '(function,object)' } ]

  function findSolution(solutionToFind, solutions) {
    return tryCatch(
      pipe$1(
        filter(
          (solution) => equals(solution[2][0], solutionToFind)
        ),
        map$1(applySpec({ fun: prop('0'), sign: path(['2', '1']) }))
      ),
      () => []
    )(solutions)
  }

  function partialAtPos(fun, pos) {
    return (...paramValues) => {
      let funAcum = fun;
      let count = 0;
      if (pos === 0) return funAcum(...paramValues)

      const iteFun = (...params) => {
        if (count >= pos) return funAcum(...paramValues)(...params)

        funAcum = funAcum(...params);
        count = count + params.length;

        if (count >= pos) return funAcum(...paramValues)

        return iteFun
      };

      return iteFun
    }
  }
  RE.partialAtPos = partialAtPos;
  // const nestedFun = (a,b) => c => (d,e) => f => console.log(a,b,c,d,e,f)
  // partialAtPos(nestedFun, 3)('jose','Luchi')('a','b')('c')('d')
  // partialAtPos(nestedFun, 5)('jose')('a','b')('c')('d','e')


  function uncurry(withLog = false) {
    return function uncurryWithOrWithoutLog(funcParam) {
      let prevConsumedUpTo = 0;
      let func = funcParam;
      let howWasCalled = '';

      return uncurryFunc

      function uncurryFunc(...args) {
        let end, listOfArgs;
        while (prevConsumedUpTo < args.length && typeof func === 'function') {
          if (func.length === 0) end = args.length;
          else end = prevConsumedUpTo + func.length;

          listOfArgs = args.slice(prevConsumedUpTo, end);
          prevConsumedUpTo = end;

          if (typeof func === 'function') {
            howWasCalled = `${howWasCalled}(${listOfArgs.map((elem) => typeof elem).join(',')})`;

            func = func(...listOfArgs);
          }
        }

        if (typeof func === 'function')
          return withLog ? [uncurryWithOrWithoutLog(func), howWasCalled] : uncurryWithOrWithoutLog(func)

        return withLog ? [func, howWasCalled] : func
      }
    }
  }

  function createReject(baseObject, elem) {
    return baseObject.constructor(
      (rej, res) => {
        rej(elem);
        return (() => { })
      }
    )
  }

  function isAcumAFutureAndElemAnError(acum, elem) {
    return elem instanceof Error && acum?.constructor?.name === 'Future'
  }

  function isAcumAPromiseAndElemAnError(acum, elem) {
    return elem instanceof Error && types.isPromise(acum)
  }

  const pipeWithChain = function (...func) {
    return function (...params) {
      return func.reduce(
        // iterate over functions to call in a specific way with the acum value. 
        (acum, currentPipeFunc, index$1) => {

          let chainFun;
          let pipeFunc = currentPipeFunc;

          // First function accepts multiVariant function... but there must meet certain condition.
          if (index$1 === 0 && acum.length > 1) {
            const numberOfFutures = acum.filter(param => param?.constructor?.name === 'Future').length;
            if (numberOfFutures > 1)
              acum[acum.length - 1] = reject(new Error('Only one Future allowed...'));
            else
              if (numberOfFutures === 1 && last(acum)?.constructor?.name !== 'Future')
                acum[acum.length - 1] = reject(new Error('Future param must be the last param of the function'));
              else
                //Apply all the parameters to convert it to a unary function.
                pipeFunc = currentPipeFunc.bind(undefined, ...acum.slice(0, acum.length - 1));
          }

          // Then extract last parameter
          if (index$1 === 0) {
            acum = acum[acum.length - 1];
          }

          if (acum instanceof Error) {
            return acum
          }

          // Try to find a chain kind of method for the accumlated drag value
          if (typeof acum?.chain === 'function')
            chainFun = acum.chain;
          else if (typeof acum?.['fantasy-land/chain'] === 'function')
            chainFun = acum['fantasy-land/chain'].bind(acum);
          else if (typeof acum?.flatMap === 'function')
            chainFun = acum.flatMap.bind(acum);

          // if acum is a chain type the pipeFunc will be executed inside the chain.
          if (chainFun) {
            return chainFun(
              (elem) => {
                if (isAcumAFutureAndElemAnError(acum, elem)) {
                  return createReject(acum, elem)
                }

                let result;

                // For flutures we try catch so there will be transformed in a reject,
                if (acum?.constructor?.name === 'Future') {
                  try {
                    result = pipeFunc(elem);
                  } catch (e) {
                    result = e;
                  }
                } else result = pipeFunc(elem);

                if (isAcumAFutureAndElemAnError(acum, result)) {
                  return createReject(acum, result)
                }

                // inside chainFun the return needs to be of the same type as the original acum drag value.
                // else we wrap the result using the constructor.
                if (result?.constructor?.name === acum?.constructor?.name)
                  return result
                else {
                  if (typeof acum?.constructor?.of === 'function') return acum.constructor.of(result)
                  if (typeof acum?.constructor?.['fantasy-land/of'] === 'function') return acum.constructor['fantasy-land/of'](result)

                  return result
                }
              }
            )
          }

          // If acum drag value is not chainable we execute pipeFunc in a normal way.
          return pipeFunc(acum)
        }
        , params
      )

    }
  };

  RE.pipeWithChain = pipeWithChain;

  // Example with Future monad
  // last parameter (and only this one) must be wrapped in a Future as in ((5, resolve(6)), and resolve(6) gives us that.
  // pipeWithChain will chain the function (called flatmap as well). It means to descend the function to be executed with the unwrapepd value. 
  // Chain always wraps the function return value... BUT if this value is already wrapped it will collapsed the two nested wraps into one,
  // flatting the structure. then we will use this wrap value in the next function and so on.
  // RE.pipeWithChain(
  //   (x,y) => x+y,
  //   x => x * 2,
  //   x => resolve([x+8, x+3]),
  //   x => resolve([x[0] +2, x[1] + 4]),
  //   x => x.filter(elem => elem > 15)
  // )(5, 6)
  // .pipe(fork(RLog('pipeWithChain-Ex1-Err: '))(RLog('pipeWithChain-Ex1-OK: ')))

  // // //
  // // // Example with Array monad
  // RE.pipeWithChain(
  //   (x,y) => x+y,
  //   (x) => (x+1)/2,
  //   x => [x * 2, x+5],
  //   //x => { throw new Error('asdas') },
  //   x => [x+5, x*2]
  // )(5, 6)
  // .filter(elem => elem >= 17)//?

  // // Example with Future and Array monad mixed
  // RE.pipeWithChain(
  //   R.map(
  //     R.pipe (
  //       R.add(2),
  //       R.divide(3)
  //     )
  //   )
  // )(resolve([1,2,3,4,56]))
  // .pipe(fork(RLog('pipeWithChain-Ex2-Err: '))(RLog('pipeWithChain-Ex2-OK: ')))

  // // Example with error
  // RE.pipeWithChain(
  //   (x,y) => x+y,
  //   x => resolve([x+8, x+3]),
  //   x => new Error('My controlled error...'),
  //   x => x.filter(elem => elem > 15)
  // )(5, 6)
  // .pipe(fork(RLog('pipeWithChain-Ex3-Err: '))(RLog('pipeWithChain-Ex3-OK: ')))

  // RE.pipeWithChain(
  //   (x,y) => x+y,
  //   x => new Error('My controlled error...'),
  // )(5, 6).message //?


  // RE.pipeWithChain(
  //   (x,y) => x+y,
  //   x => reject('my error...'),
  //   x=>x+3
  // )(5, 6)
  // .pipe(fork(RLog('pipeWithChain-Ex4-Err: '))(RLog('pipeWithChain-Ex4-OK: ')))

  // // Example with throw error
  // RE.pipeWithChain(
  //   (x,y) => x+y,
  //   x => resolve([x+8, x+3]),
  //   // throw new error for flutures are transform to reject.
  //   x => {throw new Error('aaaa')},
  //   x => x.filter(elem => elem > 15)
  // )(5, 6)
  // .pipe(fork(RLog('pipeWithChain-Ex5-Err: '))(RLog('pipeWithChain-Ex5-OK: ')))

  // // Example with throw error
  // RE.pipeWithChain(
  //   (x,y) => x,
  //   x => x +2,
  // )(5, reject(10))
  // .pipe(fork(RLog('pipeWithChain-Ex6-Err: '))(RLog('pipeWithChain-Ex6-OK: ')))

  // // Passing a Future as a parameter. Remember this must be the last one.
  // RE.pipeWithChain(
  //   (x,y) => x + y,
  //   x => x + ' --- The End!!! ---',
  // )('the value after 5ms is: ', after(5)('5'))
  // .pipe(fork(RLog('pipeWithChain-Ex7-Err: '))(RLog('pipeWithChain-Ex7-OK: ')))

  // // Example with throw error
  // RE.pipeWithChain(
  //   (x,y) => x,
  //   x => x +2,
  // )(5, new Error('return error')).message //?

  // // Note!: Arrays passing through each function of the pipeWithChain will be flatmap
  // RLog
  //   ('pipe doesnt apply flatmap to arrays: ')
  //   (
  //     RE.pipe(
  //       R.identity
  //     )([['a','b'], ['c','d']])
  //   )

  // Same as pipe with chain but arrays are not chainable:
  const pipe = function (...func) {
    return function (...params) {
      return func.reduce(
        // iterate over functions to call in a specific way with the acum value. 
        (acum, currentPipeFunc, index$1) => {

          let chainFun;
          let pipeFunc = currentPipeFunc;

          // First function accepts multiVariant function... but there must meet certain condition.
          if (index$1 === 0 && acum.length > 1) {
            const numberOfFutures = acum.filter(param => param?.constructor?.name === 'Future').length;
            if (numberOfFutures > 1)
              acum[acum.length - 1] = reject(new Error('Only one Future allowed...'));
            else
              if (numberOfFutures === 1 && last(acum)?.constructor?.name !== 'Future')
                acum[acum.length - 1] = reject(new Error('Future param must be the last param of the function'));
              else
                //Apply all the parameters to convert it to a unary function.
                pipeFunc = currentPipeFunc.bind(undefined, ...acum.slice(0, acum.length - 1));
          }

          // Then extract last parameter
          if (index$1 === 0) {
            acum = acum[acum.length - 1];
          }

          if (acum instanceof Error) {
            return acum
          }

          // Try to find a chain kind of method for the accumlated drag value
          if (typeof acum?.chain === 'function')
            chainFun = acum.chain;
          else if (typeof acum?.['fantasy-land/chain'] === 'function')
            chainFun = acum['fantasy-land/chain'].bind(acum);
          else if (types.isPromise(acum))
            chainFun = acum.then.bind(acum);
          //else if (typeof acum?.flatMap === 'function')
          //  chainFun = acum.flatMap.bind(acum)

          // if acum is a chain type the pipeFunc will be executed inside the chain.
          if (chainFun) {
            return chainFun(
              (elem) => {
                if (isAcumAFutureAndElemAnError(acum, elem)) {
                  return createReject(acum, elem)
                }

                let result;

                // For flutures we try catch so there will be transformed in a reject,
                if (acum?.constructor?.name === 'Future' || types.isPromise(acum)) {
                  try {
                    result = pipeFunc(elem);
                  } catch (e) {
                    result = e;
                  }
                } else result = pipeFunc(elem);

                if (isAcumAFutureAndElemAnError(acum, result)) {
                  return createReject(acum, result)
                }

                if (isAcumAPromiseAndElemAnError(acum, result)) {
                  return acum.then(() => Promise.reject(result))
                }

                // inside chainFun the return needs to be of the same type as the original acum drag value.
                // else we wrap the result using the constructor.
                if (result?.constructor?.name === acum?.constructor?.name)
                  return result
                else {
                  if (typeof acum?.constructor?.of === 'function') return acum.constructor.of(result)
                  if (typeof acum?.constructor?.['fantasy-land/of'] === 'function') return acum.constructor['fantasy-land/of'](result)

                  return result
                }
              }
            )
          }

          // If acum drag value is not chainable we execute pipeFunc in a normal way.
          return pipeFunc(acum)
        }
        , params
      )

    }
  };

  RE.pipe = pipe;

  // RLog
  //   ('pipe doesnt apply flatmap to arrays: ')
  //   (
  //     RE.pipe(
  //       R.identity
  //     )([['a','b'], ['c','d']])
  //   )


  // RE.pipe(
  //   R.identity,
  //   RLog('RLog print the whole array in one go. RLog is not iterated as it would in pipeWithChain ')
  // )([['a','b'], ['c','d']])

  // // Example with error
  // RE.pipe(
  //   (x,y) => x+y,
  //   x => resolve([x+8, x+3]),
  //   x => new Error('My controlled error...'),
  //   x => x.filter(elem => elem > 15)
  // )(5, 6)
  // .pipe(fork(RLog('pipeWithChain-Ex3-Err: '))(RLog('pipeWithChain-Ex3-OK: ')))


  // // Example with Future reject(error)
  // RE.pipe(
  //   (x,y) => x+y,
  //   x => reject('my error...'),
  //   x=>x+3
  // )(5, 6)
  // .pipe(fork(RLog('pipe-Ex4-Err: '))(RLog('pipe-Ex4-OK: ')))

  // // Example with Promise.reject(error)
  // RE.pipe(
  //   (x,y) => x+y,
  //   x => Promise.reject('my error...'),
  //   x=>x+3
  // )(5, 6)
  // .then(RLog('pipe-Ex5-OK: '),RLog('pipe-Ex5-Err: ') )


  // // Example with throw error Future
  // RE.pipe(
  //   (x,y) => x+y,
  //   x => resolve([x+8, x+3]),
  //   // throw new error for flutures are transform to reject.
  //   x => {throw new Error('aaaa')},
  //   x => x.filter(elem => elem > 15)
  // )(5, 6)
  // .pipe(fork(RLog('pipeWithChain-Ex6-Err: '))(RLog('pipeWithChain-Ex6-OK: ')))

  // // Example with throw error Promise
  // RE.pipe(
  //   (x,y) => x+y,
  //   x => Promise.resolve([x+8, x+3]),
  //   // throw new error for flutures are transform to reject.
  //   x => {throw new Error('aaaa')},
  //   x => x.filter(elem => elem > 15)
  // )(5, 6)
  // .then(RLog('pipe-Ex7-OK: '),RLog('pipe-Ex7-Err: ') )


  const pipeWhile = (funCond, ini) => (...funcs) => (...inputs) => {
    if (
      typeof funCond !== 'function' ||
      funcs.some(func => typeof func !== 'function') ||
      (ini !== undefined && typeof ini !== 'function')
    ) {
      const dataErrorString =
        `funCond: ${typeof funCond} ${ini === undefined ? '' : 'ini: ' + typeof ini} funcs: ${funcs.map(el => typeof el)}`;
      throw new Error(`pipeWhile was called without funcfion/s in funCond or pipe functions ${dataErrorString}`)
    }

    if (typeof ini === 'function') ini(...inputs);

    let finalReturn = inputs;
    while (funCond(...finalReturn)) {
      finalReturn = funcs.reduce(
        (acum, func) => [func(...acum)],
        finalReturn
      );
    }

    return last(finalReturn)
  };
  RE.pipeWhile = pipeWhile;

  // pipeWhile(x => x < 20)
  // (
  //  x => x + 2
  // )(2) //?

  function parallel(numberOfthreads = Infinity) {
    return futuresOrValues =>
      parallel$2
        (numberOfthreads)
        (futuresOrValues.map(elem => isFuture(elem) ? elem : resolve(elem)))
  }
  RE.parallel = parallel;

  const runFutureFunctionsInParallel =
    (numberOfThreads = Infinity) =>
      (functionsToRunInParallel) =>
        data =>
          RE.parallel(numberOfThreads)
            (
              functionsToRunInParallel.map(fun => fun(data))
            );
  RE.runFutureFunctionsInParallel = runFutureFunctionsInParallel;


  const runFunctionsSyncOrParallel =
    (numberOfFunctionsToRunInParallel = Infinity) =>
      (functionsToRun) =>
        data => {
          if (!(numberOfFunctionsToRunInParallel > 0))
            throw new CustomError('NUMBEROFFUNCTIONSTORUNINPARALLEL_MUST_BE_BETWEEN_0_TO_INFINITY')

          let activeFunctions = 0;
          let nextIndex = 0;
          let globalTypeSync = 'sync';
          let currentTypeSync = 'sync';
          let resultWithValuesPromisesOrFuture = [];


          return run()
          function run() {

            if (nextIndex >= functionsToRun.length) return finalResult()

            if (currentTypeSync === 'promise' && activeFunctions >= numberOfFunctionsToRunInParallel) {
              activeFunctions--;
              return last(resultWithValuesPromisesOrFuture).then(run)
            } else {
              resultWithValuesPromisesOrFuture[nextIndex] = functionsToRun[nextIndex](data);
              setGlobalTypeSync(resultWithValuesPromisesOrFuture[nextIndex]);
              if (currentTypeSync === 'promise') activeFunctions++;
              nextIndex++;
              return run()
            }
          }

          function finalResult() {
            if (globalTypeSync === 'future') {
              return RE.parallel
                (numberOfFunctionsToRunInParallel)
                (resultWithValuesPromisesOrFuture)
            }

            if (globalTypeSync === 'promise') {
              return Promise.all(resultWithValuesPromisesOrFuture)
            }

            return resultWithValuesPromisesOrFuture
          }

          function setGlobalTypeSync(task) {
            currentTypeSync =
              isFuture(task)
                ? 'future'
                : types.isPromise(task)
                  ? 'promise'
                  : 'sync';

            if (globalTypeSync === 'sync')
              globalTypeSync = currentTypeSync;

            if (currentTypeSync !== 'sync' && globalTypeSync !== currentTypeSync)
              throw new CustomError('MIX_PROMISE_AND_FUTURE', `Promises and future cannot be mixed ${globalTypeSync} ${currentTypeSync}`)

          }

        };

  RE.runFunctionsSyncOrParallel = runFunctionsSyncOrParallel;

  //runFunctionsSyncOrParallel(2)([()=>Promise.resolve(3), ()=>4])() //?

  function pickPathsUnc(pickTransformations, obj) {

    if (Array.isArray(pickTransformations) === false) return pickPathsUnc([pickTransformations], obj)

    return pickTransformations.reduce(
      (acum, pickObj) => {
        let pickObjToProcess = pickObj;
        if (typeof pickObj === 'string') pickObjToProcess = { path: pickObj };

        let { path: path$1, name, apply } = pickObjToProcess;

        let paths = path$1.split('.');
        if (name === undefined) name = last(paths);

        let valueAtPath = path(paths, obj);
        acum[name] =
          typeof apply === 'function'
            ? apply(valueAtPath)
            : valueAtPath;

        return acum
      }
      , {}
    )
  }
  const pickPaths = curryN(2, pickPathsUnc);
  RE.pickPaths = pickPaths;
  // pickPaths(
  //   //'a.1.b'
  //   //['a.1.b', 'c.0.d']
  //   //{path:'a.1.b', name:'x'}
  //   //{path:'a.1.b', apply: toFixed(2)}
  //   //{path:'a.1.b', name:'x', apply: toFixed(2)}
  //   [{ path: 'a.1.b', name: 'x', apply: toFixed(2) }, { path: 'c.0.d' }]
  // )
  //   (
  //     {
  //       a: [{},
  //       {
  //         c: 3,
  //         b: 6.32321,
  //         d: 1
  //       }, {}
  //       ],
  //       c: [{ d: 8.54332 }]
  //     }
  //   ) //?


  function mergeArrayOfObjectsRenamingPropsUnc(newValues, propPaths, original) {
    const offset = newValues.length - original.length;

    return original.map(
      (elem, index) =>
      ({
        ...elem,
        ...pickPaths(propPaths, newValues[index + offset])
      })
    )
  }
  const mergeArrayOfObjectsRenamingProps = curryN(3, mergeArrayOfObjectsRenamingPropsUnc);
  RE.mergeArrayOfObjectsRenamingProps = mergeArrayOfObjectsRenamingProps;
  // mergeArrayOfObjectsRenamingProps(
  //   [{ close: 5 }, { close: 6 }, { close: 30 }, { close: 50 }],
  //   [{ path: 'close', name: 'gspc' }, { path: 'close', name: 'anotherCopy' }],
  //   [{ close: 3 }, { close: 2 }]
  // )//?


  function RLog(prefixOrFormatter) {
    return (...obj) => {
      if(typeof prefixOrFormatter === 'function') {
        const cloneObj = cloneDeep(obj);
        console.log(prefixOrFormatter(...cloneObj));
      }else console.log(prefixOrFormatter, ...obj);

      return last(obj)
    }
  }

  // RLog('test')('a','b',[1,2,'test']) //?
  // RLog(
  //   (x,y,z)=> {
  //     // changing values in object doesn't change the return value.
  //     z[2].a=z[2].a.toUpperCase()
  //     return `param1: ${x} param2: ${y} param3[0]: ${z[0]} param3[1]: ${z[1]} param3[2].a: ${z[2].a}`
  //   })
  //   ('a','b',[1,2,{a:'test'}]) //?

  RE.RLog = RLog;
  RE.findSolution = findSolution;
  RE.something = something;
  RE.uncurry = uncurry;

  function Table()
  {
    const VERTICAL_LINE_CHAR = '';
    const TOP_LEFT_CORNNER_CHAR = '';
    const TOP_RIGHT_CORNNER_CHAR = '';
    const TOP_COLUMN_SEPARATOR_CHAR = '';
    const BOTTON_LEFT_CORNNER_CHAR = '';
    const BOTTON_RIGHT_CORNNER_CHAR = '';
    const BOTTON_COLUMN_SEPARATOR_CHAR = '';
    const HORIZONTAL_LINE_CHAR = '';
    const MIDDLE_COLUMN_SEPARATOR_CHAR = '';
    const MIDDLE_LEFT_SEPARATOR = '';
    const MIDDLE_RIGHT_SEPARATOR = '';
    const COLUMN_LEFT_MARGIN_CHARS = ' ';
    const COLUMN_RIGHT_MARGIN_CHARS = ' ';
    const TABLE_LEFT_MARGIN_CHARS = '';

    const listOfColumns = [
    ];

    function getTopLine()
    {
      return listOfColumns.reduce(
        (line, column, index) => 
            line + HORIZONTAL_LINE_CHAR + ''.padEnd(column.getSize(),  HORIZONTAL_LINE_CHAR) + 
            HORIZONTAL_LINE_CHAR + 
            (index < listOfColumns.length -1 ? TOP_COLUMN_SEPARATOR_CHAR : TOP_RIGHT_CORNNER_CHAR)
        , TABLE_LEFT_MARGIN_CHARS  + TOP_LEFT_CORNNER_CHAR
      )
    }

    function getBottonLine()
    {
      return listOfColumns.reduce(
        (line, column, index) => 
            line + HORIZONTAL_LINE_CHAR + ''.padEnd(column.getSize(),  HORIZONTAL_LINE_CHAR) + 
            HORIZONTAL_LINE_CHAR + 
            (index < listOfColumns.length -1 ? BOTTON_COLUMN_SEPARATOR_CHAR : BOTTON_RIGHT_CORNNER_CHAR)
        , TABLE_LEFT_MARGIN_CHARS  + BOTTON_LEFT_CORNNER_CHAR
      )
    }

    function getDownTableLine()
    {
      return listOfColumns.reduce(
        (line, column, index) => 
            line + HORIZONTAL_LINE_CHAR + ''.padEnd(column.getSize(),  HORIZONTAL_LINE_CHAR) + 
            HORIZONTAL_LINE_CHAR + 
            (index < listOfColumns.length -1 ? MIDDLE_COLUMN_SEPARATOR_CHAR : MIDDLE_RIGHT_SEPARATOR )
        , TABLE_LEFT_MARGIN_CHARS  + MIDDLE_LEFT_SEPARATOR
      )  
    }

    function linesOfData(section)
    {
      let allValuesAreDone; 
      let lines = [];
      let isFirstRow = true;
      let values = {};
      // Each iteration is a row in the table.
      // first row is used to initialize the generator function for each column.
      // So then we can extract each row with next()
      do {
        allValuesAreDone = true;

        const aLine = 
          listOfColumns
            .reduce(
              (line, component, index) => {
                if(isFirstRow) {
                  values[index] = component[section].nextValue();
                }
                const {value:columnValue, done} =values[index].next();
                if(done !== true) allValuesAreDone = false;

                return line + 
                      COLUMN_LEFT_MARGIN_CHARS + 
                      ( columnValue ?? component.getUndefinedRepresentation() ) +
                      COLUMN_RIGHT_MARGIN_CHARS + 
                      VERTICAL_LINE_CHAR
              },
              TABLE_LEFT_MARGIN_CHARS + VERTICAL_LINE_CHAR
            );

        if(allValuesAreDone === false) lines.push(aLine);
        isFirstRow = false;
      } while (allValuesAreDone === false);

      return lines
    }

    function draw(loadData)
    {

      listOfColumns.forEach(column => column.load(pluck(column.id)(loadData)));

      const lines = [
        // Top Line
        getTopLine(),
        // Heading line
        ...linesOfData('heading'),
        // Down Line of Heading
        getDownTableLine(),
        // detail lines
        ...linesOfData('row'),
        // botton line of the table
        getBottonLine(),
      ];

      return lines.join('\n')

    }

    function addColumn({type, id, title })
    {
      let column = type.loadParams(id)(title);
      listOfColumns.push(column);
    }

    return {
      addColumn,
      draw
    }
  }

  function center(text, size) {
    let sizeInt = parseInt(size, 10);
    if (typeof text !== 'string' || isNaN(sizeInt)) return text

    const trimText = text.trim();
    if (trimText.length + 1 >= sizeInt) return trimText

    const leftPading = Math.floor((sizeInt - trimText.length) / 2);
    const rightPading = sizeInt - trimText.length - leftPading;

    return ''.padEnd(leftPading) + trimText + ''.padEnd(rightPading)
  }

  function left(text, size) {
    let sizeInt = parseInt(size, 10);
    if (typeof text !== 'string' || isNaN(sizeInt)) return text

    const trimText = text.trim();
    if (trimText.length >= sizeInt) return trimText

    return trimText.padEnd(sizeInt)
  }


  function putCenteredValueAtPosIfFit(line, value, pos, margins)
  {
    let valueStr = ('' + value);
    let rightHalf = Math.floor((valueStr.length - 1)/2);
    let leftHalf = valueStr.length - 1 - rightHalf;
    if(
      line.length < pos + rightHalf + margins ||
      line.substring(pos -leftHalf - margins, pos + rightHalf + margins).split('').some(el => el !== ' ')
    )
      return line
    else {
      return line.substring(0, pos - leftHalf) + valueStr + line.substring(pos + rightHalf + 1)
    }
  }

  //let asas =               'ms 0 2300  112  ' //?
  //putInLineScaleValueAtPos('ms 0 2300       ', 112, 12, 2) //?

  function putValueAtPos(line, value, pos)
  {
    return line.substring(0, pos ) + value + line.substring(pos + value.length)
  }

  function Text({ HEADING_IDENTATION, ROW_IDENTATION } = { HEADING_IDENTATION: center, ROW_IDENTATION: left }) {
    let size;
    let id;
    let title;
    let data;

    return {
      loadParams: paramId => paramTitle => {
        id = paramId;
        title = paramTitle;

        return {
          id,

          load: columnData => {
            data = columnData;
            size = data.reduce(
              (acum, current) =>
                acum < current.length
                  ? current.length
                  : acum
              , 0
            );

            size = Math.max(size, title.length ?? 0);
          },

          getUndefinedRepresentation: () => ''.padEnd(size),
          getSize: () => size,

          heading: {
            nextValue: function* () {
              yield HEADING_IDENTATION(title, size);
            }
          },
          
          row: {
            nextValue: function* () {
              for (let el of data)
                yield ROW_IDENTATION(el, size);
            }
          }
        }
      }
    }
  }

  const LENGTH_IN_CHARS_OF_INI_END_TIMELINE = 80;
  const START_OF_INTERVAL_CHAR = '|';
  const END_OF_INTERVAL_CHAR = '|';
  const INTERVAL_UNIT_CHAR = '-';
  const LAST_SCALE_VALUE_MARGIN = 2;

  //if from the oldest start to the newest end the difference in ms < the limit value then scale will be represented
  // in this unit.
  // The limit is calculated by applying:
  //15% of miliseconds of two units above. ex: ms limit is 15% of one minute
  const timelineScales = [
    //1000*60*(15/100) 15% of 1 minute
    { limit: 9000, label: 'ms', valueInUnits: start => time => time - start }, 
    
    //1000*60*60*(15/100) 15% of 1 hour
    { limit: 540000, label: 'sec', valueInUnits: start => time => Math.floor((time - start)/1000).toString() },
    
    //1000*60*60*24*(15/100)
    { limit: 12960000, label: 'min', valueInUnits: start => time => Math.floor((time - start)/60000).toString() },
    
    //1000*60*60*24*365*(15/100)
    { limit: 4730400000, label: 'hr', valueInUnits: start => time => Math.floor((time - start)/3600000).toString() },
    
    //1000*60*60*24*365*100*(15/100)
    { limit: 473040000000, label: 'day', valueInUnits: start => time => Math.floor((time - start)/86400000).toString() },
    
    //1000*60*60*24*365*100*10*(15/100)
    { limit: 4730400000000, label: 'year',valueInUnits: start => time => Math.floor((time - start)/31536000000).toString() },
    { limit: Infinity, label: 'cen', valueInUnits: start => time => Math.floor((time - start)/3153600000000).toString() },
  ];

  function drawInterval(line, startInterval, endInterval)
  {
    let value = 
      START_OF_INTERVAL_CHAR + 
      ''.padEnd(endInterval - startInterval - 1, INTERVAL_UNIT_CHAR) + 
      END_OF_INTERVAL_CHAR;

    return putValueAtPos(line, value, startInterval)
  }

  function Timeline()
  {
    let size;
    let id;
    let data;
    let scalePoints;
    let resolution;
    let timelineScale;

    function convertToResolution(point)
    {
      return Math.floor((point - scalePoints[0])/resolution)
    }


    return {
      loadParams: paramId => paramTitle => {
        id = paramId;

        return {
          id,
          load: columnData => {
            data = columnData.map(
              intervals =>
                intervals.map( 
                  interval => {
                    const start = new Date(interval.start).valueOf();
                    const end = new Date(interval.end).valueOf();
                    return {
                      start,
                      end
                    }
                  }
                )
            );

            scalePoints = 
              [...new Set(
                data.flatMap(identity).reduce(
                  (scalePoints, point) =>
                    [...scalePoints, point.start, point.end],
                  []
                ).sort(arraySorter())
              )];
            
            resolution = (scalePoints[scalePoints.length - 1] - scalePoints[0])/LENGTH_IN_CHARS_OF_INI_END_TIMELINE;
          
            let timelineScaleIndex = timelineScales.findIndex(el => (scalePoints[scalePoints.length - 1] - scalePoints[0]) < el.limit );
            timelineScale = timelineScales[timelineScaleIndex];

            size = timelineScale.label.length + 1 + LENGTH_IN_CHARS_OF_INI_END_TIMELINE + LAST_SCALE_VALUE_MARGIN;
          },
          getUndefinedRepresentation: ()=>''.padEnd(size),
          getSize: () => size,

          heading: {
            nextValue: function*() {
              yield scalePoints.reduce(
                (line, scalePoint) => {
                  return putCenteredValueAtPosIfFit(
                    line, 
                    timelineScale.valueInUnits(scalePoints[0])(scalePoint),
                    convertToResolution(scalePoint) + 3,
                    1
                  )
                },
                timelineScale.label + ' ' + ''.padEnd(LENGTH_IN_CHARS_OF_INI_END_TIMELINE + LAST_SCALE_VALUE_MARGIN)
              );
            }
          },

          row: {
            nextValue: function*() {
              for (let intervals of data)
              {
                yield intervals.reduce(
                  (line, interval) => 
                  drawInterval(
                    line, 
                    convertToResolution(interval.start) + timelineScale.label.length + 1, 
                    convertToResolution(interval.end) + timelineScale.label.length + 1, 
                  ),
                  ''.padEnd(size)
                );
              }

            }
          }
        }
      }
    }

  }

  function Chrono() {
    let now;
    try {
      now = process.hrtime.bigint; 
    }catch(e)
    {}

    try { 
      if(now === undefined && performance.now) now = ()=> BigInt(performance.now()*1000);
    }catch(e)
    {
      now = ()=> BigInt(Date.now()*1000);
    }

    let historyTimeIntervals = {};

    let chronoEvents = {};
    createTimeEvent('chronoCreation');

    let rangeType = Range({type:'hrtimeBigInt', displayFormat:'ms', referenceHrtime: chronoEvents['chronoCreation'].hrtime});

    function createTimeEvent(eventName) {
      chronoEvents[eventName] = {
        date: new Date(),
        hrtime: now()
      };
    }

    function time(eventNames) {

      let currentHrtime = now();

      let listOfEvents = typeof eventNames === 'string' ? [eventNames] : eventNames;

      listOfEvents.forEach(eventName => {
        historyTimeIntervals[eventName] = historyTimeIntervals[eventName] ?? {};

        historyTimeIntervals[eventName].start = historyTimeIntervals[eventName].start ?? [];
        historyTimeIntervals[eventName].start.push(currentHrtime);
      });
    }


    function timeEnd(eventNames) {
      let currentHrtime = now();

      let listOfEvents = typeof eventNames === 'string' ? [eventNames] : eventNames;

      listOfEvents.forEach(eventName => {
        if (historyTimeIntervals[eventName] === undefined) {
          console.log(`No such Label '${eventName}' for .timeEnd(...)`, 'CustomWarning', 'WARN002');
          return
        }

        let start = historyTimeIntervals[eventName].start.pop();

        if (start === undefined) {
          console.log(`Label '${eventName}' was already consumed by a previous call to .timeEnd(...)`, 'CustomWarning', 'WARN003');
          return
        }

        historyTimeIntervals[eventName].ranges = historyTimeIntervals[eventName].ranges ?? [];
        historyTimeIntervals[eventName].ranges.push(
          rangeType(
            start,
            currentHrtime
          )
        );

      });
    }

    function eventsReport(events)
    {
      const entriesEvents = Object.entries(events);
      entriesEvents.reduce(
        (acum, [eventName, eventObject]) => {
          eventObject.ranges.forEach(
            range => {
              if(acum[0] > range.start) acum[0] = range.start;
              if(acum[1] <range.end) acum[1] = range.end;
            });
         return acum
        },
        [Infinity,0]
      ); //?
      
       
    //   console.log(`
    //  -------------------------------------------------------------------------------------------
    // | events              | ms  0     80        200   500        900     1100                   |
    // |---------------------|---------------------------------------------------------------------|          
    // | loadConfig          |     |----------------------|          |--------|                    |
    // | getCards            |     |-----------|          |---------------|                        |
    // | getAccounts         |     |------|                                                        |
    // | compeseFinalOutput  |                       |--------------|         |---------------|    |
    //  -------------------------------------------------------------------------------------------
    //   `)
      //plot(entriesEvents, minHrtime, maxHrtime)
      return events
    }

    function totalEventsElapseTimeReport(events)
    {
      let totalElapse = 0;
      const toLog = events.reduce(
        (acum, current) => {
          let found = acum.find(el => el.name === current.name);

          const currentElapseMs = hrtimeBigIntToMs(current.range.end - current.range.start);
          totalElapse = totalElapse + currentElapseMs;
          if(found) found.elapse = found.elapse + currentElapseMs;
          else acum.push({name: current.name, elapse: currentElapseMs});

          return acum
        },
        []
      ).map(nameRange => {
        nameRange.percentage = Number(Number(100 * nameRange.elapse / totalElapse).toFixed(2));
        return nameRange
      });

      console.log('');
      console.log('Total elapse Time of each event: ');
      console.table(toLog);

      return events
    }

    function coincidingEventsReport(elapseTable)
    {

      pipe$1(
        groupByWithCalc(
          (row) => JSON.stringify(row.runningEvents.sort(arraySorter())),
          { percentage: (l, r) => (l??0) + r, elapseMs: (l, r) => (l??0) + r }
        ),
        map$1( row => ({...row, percentage: Number(row.percentage.toFixed(2))}) ),
        (coincidingEvents) => {
          console.log('');
          console.log('Coinciding Events timeline: ');
          console.table(coincidingEvents);
        }
      )(elapseTable);

      return elapseTable
    }

    function timelineReport(data)
    {
      const timeline = Table();

      timeline.addColumn({ type: Text(), id: 'event', title: 'Events' });
      timeline.addColumn({ type: Timeline(), id: 'ranges' });

      console.log('');
      console.log('Timeline of events:');
      console.log(timeline.draw(data));

      return data
    }

    function formatReportAndReturnInputParam(data)
    {
      let toReport = Object.entries(data).map(
        ([eventName, event]) => (
          {
            event: eventName, 
            ranges: event.ranges.map(
              ({start, end} ) => ({start: hrtimeBigIntToMs(start), end: hrtimeBigIntToMs(end)})
            )
          }));
      timelineReport(toReport);

      return data
    }
    
    function chronoReport()
    {
      console.log('');
      Object.entries(chronoEvents).forEach(
        ([key, value]) => console.log(key, ': ', value.date)
      );
    }

    function report() {
      createTimeEvent('report');
      chronoReport();
        pipe$1(
          //RE.RLog('-1-->: '),
          formatReportAndReturnInputParam,
          eventsReport,
          historyToListOfNameRanges,
          //RE.RLog('0-->: '),
          totalEventsElapseTimeReport,
          compactListOfNameRanges,
          //RE.RLog('1-->: '),
          sort(sorterByPaths('range')),
          reportListOfNameRanges,
          //RE.RLog('3-->: '),
          coincidingEventsReport
        )(historyTimeIntervals);
    }

    function historyToListOfNameRanges(historyTimeIntervals) {
      return Object.entries(historyTimeIntervals)
        .reduce(
          (acum, [key, value]) => {
            acum.push(
              ...(value.ranges?.map(
                range => ({ name: key, range })
              ))??[]
            );

            return acum
          },
          []
        )
    }

    function compactListOfNameRanges(ListOfRangeNames) {
      return ListOfRangeNames.reduce(
        (acum, { name, range }) => {
          acum.push({ name, isLeft: true, edge: range.start, edgeEnd: range.end });
          acum.push({ name, isLeft: false, edge: range.end });
          return acum
        },
        []
      )
        .sort(sorterByPaths('edge'))
        .reduce(
          (acum, { name, isLeft, edge, edgeEnd }, index, table) => {
            if (isLeft) {
              let i = index;
              do {
                pushUniqueKeyOrChange(
                  { runningEvents: [name], range: rangeType(table[i].edge, table[i + 1].edge) }
                  , acum
                  , ['range']
                  , (newRow, existingRow) => {
                    pushUniqueKey(name, existingRow.runningEvents);
                    return existingRow
                  }
                );
                i++;
              } while (!(table[i].name === name && table[i].isLeft === false && table[i].edge === edgeEnd))
            }

            return acum
          },
          []
        ).filter(
          elem => elem.range.start !== elem.range.end
        )
    }

    function reportListOfNameRanges(listOfNameRanges) {
      let totalElapse = 0;
      return listOfNameRanges.map(
        ({ runningEvents, range }) => {
          let elapseMs = hrtimeBigIntRangeToElapseMs(range);
          totalElapse = totalElapse + elapseMs;
          return {
            runningEvents,
            elapseMs
          }
        }
      ).map(nameRange => {
        nameRange.percentage = 100 * nameRange.elapseMs / totalElapse;
        return nameRange
      })
    }

    return { time, timeEnd, report }
  }


  function hrtimeBigIntRangeToElapseMs({start, end}) {
    return Number((end - start) / BigInt(1000000))
  }
  //hrtimeBigIntRangeToElapseMs(Range(BigInt(1953997827221605), BigInt(1953997981407671) )) //?
  //hrtimeBigIntRangeToElapseMs({ start:BigInt(1953997827221605), end:BigInt(1953997981407671) }) //?

  function hrtimeBigIntToMs(hrtime) {
    return Number(hrtime / BigInt(1000000))
  }

  function Range(...params) {
    let type;
    let displayFormat;
    let referenceHrtime;

    if(params.length === 2 ) {
      return range(params[0], params[1])
    }
    else {
      ({ type, displayFormat, referenceHrtime} = params[0]);
      return range
    }

    function range(start, end)
    {
      if (start > end) throw new Error('range(start, end) start cannot be > than end')

      function toString() 
      {
        if(type === 'hrtimeBigInt' && displayFormat === 'ms' && referenceHrtime !== undefined) {
          const startMs = hrtimeBigIntRangeToElapseMs({start:referenceHrtime, end:start});
          const endMs = hrtimeBigIntRangeToElapseMs({start:referenceHrtime, end});
          return `{ start:${startMs} <-${endMs - startMs}-> end:${endMs} }`
        }

        return `{ start:${start}, end:${end} }`
      }

      function intersect(rangeB) {
        let newStart = start > rangeB.start ? start : rangeB.start;
        let newEnd = end < rangeB.end ? end : rangeB.end;

        if (newStart === undefined || newEnd === undefined) return range(undefined, undefined)
        if (newStart > newEnd) return range(undefined, undefined)

        return range(newStart, newEnd)
      }

      return {
        [Symbol.for('nodejs.util.inspect.custom')]: toString,
        toString,
        intersect,
        start,
        end
      }
    }
  }


  let chrono = Chrono();

  chrono.time('step1');
  tasks().then(()=>{
    chrono.timeEnd('step1');
    chrono.report();
  });

  async function tasks()
  {

    await sleepWithFunction(
      650,
      () => {
        chrono.timeEnd('step1');
      }
    );

    await sleepWithFunction(
      20,
      () => {
        chrono.time('step2');
      }
    );

    await sleepWithFunction(
      12,
      () => {
        chrono.time('step3');
      }
    );

    await sleepWithFunction(
      500,
      () => {
        chrono.timeEnd('step3');
      }
    ),
    await sleepWithFunction(
      100,
      () => {
        chrono.timeEnd('step2');
      }
    ),
    await sleepWithFunction(
      15,
      () => {
        chrono.time('step1');
      }
    );
  }

  /**
   * Returns a `Buffer` instance from the given data URI `uri`.
   *
   * @param {String} uri Data URI to turn into a Buffer instance
   * @returns {Buffer} Buffer instance from Data URI
   * @api public
   */
  function dataUriToBuffer(uri) {
      if (!/^data:/i.test(uri)) {
          throw new TypeError('`uri` does not appear to be a Data URI (must begin with "data:")');
      }
      // strip newlines
      uri = uri.replace(/\r?\n/g, '');
      // split the URI up into the "metadata" and the "data" portions
      const firstComma = uri.indexOf(',');
      if (firstComma === -1 || firstComma <= 4) {
          throw new TypeError('malformed data: URI');
      }
      // remove the "data:" scheme and parse the metadata
      const meta = uri.substring(5, firstComma).split(';');
      let charset = '';
      let base64 = false;
      const type = meta[0] || 'text/plain';
      let typeFull = type;
      for (let i = 1; i < meta.length; i++) {
          if (meta[i] === 'base64') {
              base64 = true;
          }
          else {
              typeFull += `;${meta[i]}`;
              if (meta[i].indexOf('charset=') === 0) {
                  charset = meta[i].substring(8);
              }
          }
      }
      // defaults to US-ASCII only if type is not provided
      if (!meta[0] && !charset.length) {
          typeFull += ';charset=US-ASCII';
          charset = 'US-ASCII';
      }
      // get the encoded data portion and decode URI-encoded chars
      const encoding = base64 ? 'base64' : 'ascii';
      const data = unescape(uri.substring(firstComma + 1));
      const buffer = Buffer.from(data, encoding);
      // set `.type` and `.typeFull` properties to MIME type
      buffer.type = type;
      buffer.typeFull = typeFull;
      // set the `.charset` property
      buffer.charset = charset;
      return buffer;
  }

  var ponyfill_es2018 = {exports: {}};

  /**
   * web-streams-polyfill v3.2.1
   */

  var hasRequiredPonyfill_es2018;

  function requirePonyfill_es2018 () {
  	if (hasRequiredPonyfill_es2018) return ponyfill_es2018.exports;
  	hasRequiredPonyfill_es2018 = 1;
  	(function (module, exports) {
  		(function (global, factory) {
  		    factory(exports) ;
  		}(commonjsGlobal, (function (exports) {
  		    /// <reference lib="es2015.symbol" />
  		    const SymbolPolyfill = typeof Symbol === 'function' && typeof Symbol.iterator === 'symbol' ?
  		        Symbol :
  		        description => `Symbol(${description})`;

  		    /// <reference lib="dom" />
  		    function noop() {
  		        return undefined;
  		    }
  		    function getGlobals() {
  		        if (typeof self !== 'undefined') {
  		            return self;
  		        }
  		        else if (typeof window !== 'undefined') {
  		            return window;
  		        }
  		        else if (typeof commonjsGlobal !== 'undefined') {
  		            return commonjsGlobal;
  		        }
  		        return undefined;
  		    }
  		    const globals = getGlobals();

  		    function typeIsObject(x) {
  		        return (typeof x === 'object' && x !== null) || typeof x === 'function';
  		    }
  		    const rethrowAssertionErrorRejection = noop;

  		    const originalPromise = Promise;
  		    const originalPromiseThen = Promise.prototype.then;
  		    const originalPromiseResolve = Promise.resolve.bind(originalPromise);
  		    const originalPromiseReject = Promise.reject.bind(originalPromise);
  		    function newPromise(executor) {
  		        return new originalPromise(executor);
  		    }
  		    function promiseResolvedWith(value) {
  		        return originalPromiseResolve(value);
  		    }
  		    function promiseRejectedWith(reason) {
  		        return originalPromiseReject(reason);
  		    }
  		    function PerformPromiseThen(promise, onFulfilled, onRejected) {
  		        // There doesn't appear to be any way to correctly emulate the behaviour from JavaScript, so this is just an
  		        // approximation.
  		        return originalPromiseThen.call(promise, onFulfilled, onRejected);
  		    }
  		    function uponPromise(promise, onFulfilled, onRejected) {
  		        PerformPromiseThen(PerformPromiseThen(promise, onFulfilled, onRejected), undefined, rethrowAssertionErrorRejection);
  		    }
  		    function uponFulfillment(promise, onFulfilled) {
  		        uponPromise(promise, onFulfilled);
  		    }
  		    function uponRejection(promise, onRejected) {
  		        uponPromise(promise, undefined, onRejected);
  		    }
  		    function transformPromiseWith(promise, fulfillmentHandler, rejectionHandler) {
  		        return PerformPromiseThen(promise, fulfillmentHandler, rejectionHandler);
  		    }
  		    function setPromiseIsHandledToTrue(promise) {
  		        PerformPromiseThen(promise, undefined, rethrowAssertionErrorRejection);
  		    }
  		    const queueMicrotask = (() => {
  		        const globalQueueMicrotask = globals && globals.queueMicrotask;
  		        if (typeof globalQueueMicrotask === 'function') {
  		            return globalQueueMicrotask;
  		        }
  		        const resolvedPromise = promiseResolvedWith(undefined);
  		        return (fn) => PerformPromiseThen(resolvedPromise, fn);
  		    })();
  		    function reflectCall(F, V, args) {
  		        if (typeof F !== 'function') {
  		            throw new TypeError('Argument is not a function');
  		        }
  		        return Function.prototype.apply.call(F, V, args);
  		    }
  		    function promiseCall(F, V, args) {
  		        try {
  		            return promiseResolvedWith(reflectCall(F, V, args));
  		        }
  		        catch (value) {
  		            return promiseRejectedWith(value);
  		        }
  		    }

  		    // Original from Chromium
  		    // https://chromium.googlesource.com/chromium/src/+/0aee4434a4dba42a42abaea9bfbc0cd196a63bc1/third_party/blink/renderer/core/streams/SimpleQueue.js
  		    const QUEUE_MAX_ARRAY_SIZE = 16384;
  		    /**
  		     * Simple queue structure.
  		     *
  		     * Avoids scalability issues with using a packed array directly by using
  		     * multiple arrays in a linked list and keeping the array size bounded.
  		     */
  		    class SimpleQueue {
  		        constructor() {
  		            this._cursor = 0;
  		            this._size = 0;
  		            // _front and _back are always defined.
  		            this._front = {
  		                _elements: [],
  		                _next: undefined
  		            };
  		            this._back = this._front;
  		            // The cursor is used to avoid calling Array.shift().
  		            // It contains the index of the front element of the array inside the
  		            // front-most node. It is always in the range [0, QUEUE_MAX_ARRAY_SIZE).
  		            this._cursor = 0;
  		            // When there is only one node, size === elements.length - cursor.
  		            this._size = 0;
  		        }
  		        get length() {
  		            return this._size;
  		        }
  		        // For exception safety, this method is structured in order:
  		        // 1. Read state
  		        // 2. Calculate required state mutations
  		        // 3. Perform state mutations
  		        push(element) {
  		            const oldBack = this._back;
  		            let newBack = oldBack;
  		            if (oldBack._elements.length === QUEUE_MAX_ARRAY_SIZE - 1) {
  		                newBack = {
  		                    _elements: [],
  		                    _next: undefined
  		                };
  		            }
  		            // push() is the mutation most likely to throw an exception, so it
  		            // goes first.
  		            oldBack._elements.push(element);
  		            if (newBack !== oldBack) {
  		                this._back = newBack;
  		                oldBack._next = newBack;
  		            }
  		            ++this._size;
  		        }
  		        // Like push(), shift() follows the read -> calculate -> mutate pattern for
  		        // exception safety.
  		        shift() { // must not be called on an empty queue
  		            const oldFront = this._front;
  		            let newFront = oldFront;
  		            const oldCursor = this._cursor;
  		            let newCursor = oldCursor + 1;
  		            const elements = oldFront._elements;
  		            const element = elements[oldCursor];
  		            if (newCursor === QUEUE_MAX_ARRAY_SIZE) {
  		                newFront = oldFront._next;
  		                newCursor = 0;
  		            }
  		            // No mutations before this point.
  		            --this._size;
  		            this._cursor = newCursor;
  		            if (oldFront !== newFront) {
  		                this._front = newFront;
  		            }
  		            // Permit shifted element to be garbage collected.
  		            elements[oldCursor] = undefined;
  		            return element;
  		        }
  		        // The tricky thing about forEach() is that it can be called
  		        // re-entrantly. The queue may be mutated inside the callback. It is easy to
  		        // see that push() within the callback has no negative effects since the end
  		        // of the queue is checked for on every iteration. If shift() is called
  		        // repeatedly within the callback then the next iteration may return an
  		        // element that has been removed. In this case the callback will be called
  		        // with undefined values until we either "catch up" with elements that still
  		        // exist or reach the back of the queue.
  		        forEach(callback) {
  		            let i = this._cursor;
  		            let node = this._front;
  		            let elements = node._elements;
  		            while (i !== elements.length || node._next !== undefined) {
  		                if (i === elements.length) {
  		                    node = node._next;
  		                    elements = node._elements;
  		                    i = 0;
  		                    if (elements.length === 0) {
  		                        break;
  		                    }
  		                }
  		                callback(elements[i]);
  		                ++i;
  		            }
  		        }
  		        // Return the element that would be returned if shift() was called now,
  		        // without modifying the queue.
  		        peek() { // must not be called on an empty queue
  		            const front = this._front;
  		            const cursor = this._cursor;
  		            return front._elements[cursor];
  		        }
  		    }

  		    function ReadableStreamReaderGenericInitialize(reader, stream) {
  		        reader._ownerReadableStream = stream;
  		        stream._reader = reader;
  		        if (stream._state === 'readable') {
  		            defaultReaderClosedPromiseInitialize(reader);
  		        }
  		        else if (stream._state === 'closed') {
  		            defaultReaderClosedPromiseInitializeAsResolved(reader);
  		        }
  		        else {
  		            defaultReaderClosedPromiseInitializeAsRejected(reader, stream._storedError);
  		        }
  		    }
  		    // A client of ReadableStreamDefaultReader and ReadableStreamBYOBReader may use these functions directly to bypass state
  		    // check.
  		    function ReadableStreamReaderGenericCancel(reader, reason) {
  		        const stream = reader._ownerReadableStream;
  		        return ReadableStreamCancel(stream, reason);
  		    }
  		    function ReadableStreamReaderGenericRelease(reader) {
  		        if (reader._ownerReadableStream._state === 'readable') {
  		            defaultReaderClosedPromiseReject(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
  		        }
  		        else {
  		            defaultReaderClosedPromiseResetToRejected(reader, new TypeError(`Reader was released and can no longer be used to monitor the stream's closedness`));
  		        }
  		        reader._ownerReadableStream._reader = undefined;
  		        reader._ownerReadableStream = undefined;
  		    }
  		    // Helper functions for the readers.
  		    function readerLockException(name) {
  		        return new TypeError('Cannot ' + name + ' a stream using a released reader');
  		    }
  		    // Helper functions for the ReadableStreamDefaultReader.
  		    function defaultReaderClosedPromiseInitialize(reader) {
  		        reader._closedPromise = newPromise((resolve, reject) => {
  		            reader._closedPromise_resolve = resolve;
  		            reader._closedPromise_reject = reject;
  		        });
  		    }
  		    function defaultReaderClosedPromiseInitializeAsRejected(reader, reason) {
  		        defaultReaderClosedPromiseInitialize(reader);
  		        defaultReaderClosedPromiseReject(reader, reason);
  		    }
  		    function defaultReaderClosedPromiseInitializeAsResolved(reader) {
  		        defaultReaderClosedPromiseInitialize(reader);
  		        defaultReaderClosedPromiseResolve(reader);
  		    }
  		    function defaultReaderClosedPromiseReject(reader, reason) {
  		        if (reader._closedPromise_reject === undefined) {
  		            return;
  		        }
  		        setPromiseIsHandledToTrue(reader._closedPromise);
  		        reader._closedPromise_reject(reason);
  		        reader._closedPromise_resolve = undefined;
  		        reader._closedPromise_reject = undefined;
  		    }
  		    function defaultReaderClosedPromiseResetToRejected(reader, reason) {
  		        defaultReaderClosedPromiseInitializeAsRejected(reader, reason);
  		    }
  		    function defaultReaderClosedPromiseResolve(reader) {
  		        if (reader._closedPromise_resolve === undefined) {
  		            return;
  		        }
  		        reader._closedPromise_resolve(undefined);
  		        reader._closedPromise_resolve = undefined;
  		        reader._closedPromise_reject = undefined;
  		    }

  		    const AbortSteps = SymbolPolyfill('[[AbortSteps]]');
  		    const ErrorSteps = SymbolPolyfill('[[ErrorSteps]]');
  		    const CancelSteps = SymbolPolyfill('[[CancelSteps]]');
  		    const PullSteps = SymbolPolyfill('[[PullSteps]]');

  		    /// <reference lib="es2015.core" />
  		    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isFinite#Polyfill
  		    const NumberIsFinite = Number.isFinite || function (x) {
  		        return typeof x === 'number' && isFinite(x);
  		    };

  		    /// <reference lib="es2015.core" />
  		    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Math/trunc#Polyfill
  		    const MathTrunc = Math.trunc || function (v) {
  		        return v < 0 ? Math.ceil(v) : Math.floor(v);
  		    };

  		    // https://heycam.github.io/webidl/#idl-dictionaries
  		    function isDictionary(x) {
  		        return typeof x === 'object' || typeof x === 'function';
  		    }
  		    function assertDictionary(obj, context) {
  		        if (obj !== undefined && !isDictionary(obj)) {
  		            throw new TypeError(`${context} is not an object.`);
  		        }
  		    }
  		    // https://heycam.github.io/webidl/#idl-callback-functions
  		    function assertFunction(x, context) {
  		        if (typeof x !== 'function') {
  		            throw new TypeError(`${context} is not a function.`);
  		        }
  		    }
  		    // https://heycam.github.io/webidl/#idl-object
  		    function isObject(x) {
  		        return (typeof x === 'object' && x !== null) || typeof x === 'function';
  		    }
  		    function assertObject(x, context) {
  		        if (!isObject(x)) {
  		            throw new TypeError(`${context} is not an object.`);
  		        }
  		    }
  		    function assertRequiredArgument(x, position, context) {
  		        if (x === undefined) {
  		            throw new TypeError(`Parameter ${position} is required in '${context}'.`);
  		        }
  		    }
  		    function assertRequiredField(x, field, context) {
  		        if (x === undefined) {
  		            throw new TypeError(`${field} is required in '${context}'.`);
  		        }
  		    }
  		    // https://heycam.github.io/webidl/#idl-unrestricted-double
  		    function convertUnrestrictedDouble(value) {
  		        return Number(value);
  		    }
  		    function censorNegativeZero(x) {
  		        return x === 0 ? 0 : x;
  		    }
  		    function integerPart(x) {
  		        return censorNegativeZero(MathTrunc(x));
  		    }
  		    // https://heycam.github.io/webidl/#idl-unsigned-long-long
  		    function convertUnsignedLongLongWithEnforceRange(value, context) {
  		        const lowerBound = 0;
  		        const upperBound = Number.MAX_SAFE_INTEGER;
  		        let x = Number(value);
  		        x = censorNegativeZero(x);
  		        if (!NumberIsFinite(x)) {
  		            throw new TypeError(`${context} is not a finite number`);
  		        }
  		        x = integerPart(x);
  		        if (x < lowerBound || x > upperBound) {
  		            throw new TypeError(`${context} is outside the accepted range of ${lowerBound} to ${upperBound}, inclusive`);
  		        }
  		        if (!NumberIsFinite(x) || x === 0) {
  		            return 0;
  		        }
  		        // TODO Use BigInt if supported?
  		        // let xBigInt = BigInt(integerPart(x));
  		        // xBigInt = BigInt.asUintN(64, xBigInt);
  		        // return Number(xBigInt);
  		        return x;
  		    }

  		    function assertReadableStream(x, context) {
  		        if (!IsReadableStream(x)) {
  		            throw new TypeError(`${context} is not a ReadableStream.`);
  		        }
  		    }

  		    // Abstract operations for the ReadableStream.
  		    function AcquireReadableStreamDefaultReader(stream) {
  		        return new ReadableStreamDefaultReader(stream);
  		    }
  		    // ReadableStream API exposed for controllers.
  		    function ReadableStreamAddReadRequest(stream, readRequest) {
  		        stream._reader._readRequests.push(readRequest);
  		    }
  		    function ReadableStreamFulfillReadRequest(stream, chunk, done) {
  		        const reader = stream._reader;
  		        const readRequest = reader._readRequests.shift();
  		        if (done) {
  		            readRequest._closeSteps();
  		        }
  		        else {
  		            readRequest._chunkSteps(chunk);
  		        }
  		    }
  		    function ReadableStreamGetNumReadRequests(stream) {
  		        return stream._reader._readRequests.length;
  		    }
  		    function ReadableStreamHasDefaultReader(stream) {
  		        const reader = stream._reader;
  		        if (reader === undefined) {
  		            return false;
  		        }
  		        if (!IsReadableStreamDefaultReader(reader)) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    /**
  		     * A default reader vended by a {@link ReadableStream}.
  		     *
  		     * @public
  		     */
  		    class ReadableStreamDefaultReader {
  		        constructor(stream) {
  		            assertRequiredArgument(stream, 1, 'ReadableStreamDefaultReader');
  		            assertReadableStream(stream, 'First parameter');
  		            if (IsReadableStreamLocked(stream)) {
  		                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
  		            }
  		            ReadableStreamReaderGenericInitialize(this, stream);
  		            this._readRequests = new SimpleQueue();
  		        }
  		        /**
  		         * Returns a promise that will be fulfilled when the stream becomes closed,
  		         * or rejected if the stream ever errors or the reader's lock is released before the stream finishes closing.
  		         */
  		        get closed() {
  		            if (!IsReadableStreamDefaultReader(this)) {
  		                return promiseRejectedWith(defaultReaderBrandCheckException('closed'));
  		            }
  		            return this._closedPromise;
  		        }
  		        /**
  		         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
  		         */
  		        cancel(reason = undefined) {
  		            if (!IsReadableStreamDefaultReader(this)) {
  		                return promiseRejectedWith(defaultReaderBrandCheckException('cancel'));
  		            }
  		            if (this._ownerReadableStream === undefined) {
  		                return promiseRejectedWith(readerLockException('cancel'));
  		            }
  		            return ReadableStreamReaderGenericCancel(this, reason);
  		        }
  		        /**
  		         * Returns a promise that allows access to the next chunk from the stream's internal queue, if available.
  		         *
  		         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
  		         */
  		        read() {
  		            if (!IsReadableStreamDefaultReader(this)) {
  		                return promiseRejectedWith(defaultReaderBrandCheckException('read'));
  		            }
  		            if (this._ownerReadableStream === undefined) {
  		                return promiseRejectedWith(readerLockException('read from'));
  		            }
  		            let resolvePromise;
  		            let rejectPromise;
  		            const promise = newPromise((resolve, reject) => {
  		                resolvePromise = resolve;
  		                rejectPromise = reject;
  		            });
  		            const readRequest = {
  		                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
  		                _closeSteps: () => resolvePromise({ value: undefined, done: true }),
  		                _errorSteps: e => rejectPromise(e)
  		            };
  		            ReadableStreamDefaultReaderRead(this, readRequest);
  		            return promise;
  		        }
  		        /**
  		         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
  		         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
  		         * from now on; otherwise, the reader will appear closed.
  		         *
  		         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
  		         * the reader's {@link ReadableStreamDefaultReader.read | read()} method has not yet been settled. Attempting to
  		         * do so will throw a `TypeError` and leave the reader locked to the stream.
  		         */
  		        releaseLock() {
  		            if (!IsReadableStreamDefaultReader(this)) {
  		                throw defaultReaderBrandCheckException('releaseLock');
  		            }
  		            if (this._ownerReadableStream === undefined) {
  		                return;
  		            }
  		            if (this._readRequests.length > 0) {
  		                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
  		            }
  		            ReadableStreamReaderGenericRelease(this);
  		        }
  		    }
  		    Object.defineProperties(ReadableStreamDefaultReader.prototype, {
  		        cancel: { enumerable: true },
  		        read: { enumerable: true },
  		        releaseLock: { enumerable: true },
  		        closed: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ReadableStreamDefaultReader.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ReadableStreamDefaultReader',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the readers.
  		    function IsReadableStreamDefaultReader(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_readRequests')) {
  		            return false;
  		        }
  		        return x instanceof ReadableStreamDefaultReader;
  		    }
  		    function ReadableStreamDefaultReaderRead(reader, readRequest) {
  		        const stream = reader._ownerReadableStream;
  		        stream._disturbed = true;
  		        if (stream._state === 'closed') {
  		            readRequest._closeSteps();
  		        }
  		        else if (stream._state === 'errored') {
  		            readRequest._errorSteps(stream._storedError);
  		        }
  		        else {
  		            stream._readableStreamController[PullSteps](readRequest);
  		        }
  		    }
  		    // Helper functions for the ReadableStreamDefaultReader.
  		    function defaultReaderBrandCheckException(name) {
  		        return new TypeError(`ReadableStreamDefaultReader.prototype.${name} can only be used on a ReadableStreamDefaultReader`);
  		    }

  		    /// <reference lib="es2018.asynciterable" />
  		    /* eslint-disable @typescript-eslint/no-empty-function */
  		    const AsyncIteratorPrototype = Object.getPrototypeOf(Object.getPrototypeOf(async function* () { }).prototype);

  		    /// <reference lib="es2018.asynciterable" />
  		    class ReadableStreamAsyncIteratorImpl {
  		        constructor(reader, preventCancel) {
  		            this._ongoingPromise = undefined;
  		            this._isFinished = false;
  		            this._reader = reader;
  		            this._preventCancel = preventCancel;
  		        }
  		        next() {
  		            const nextSteps = () => this._nextSteps();
  		            this._ongoingPromise = this._ongoingPromise ?
  		                transformPromiseWith(this._ongoingPromise, nextSteps, nextSteps) :
  		                nextSteps();
  		            return this._ongoingPromise;
  		        }
  		        return(value) {
  		            const returnSteps = () => this._returnSteps(value);
  		            return this._ongoingPromise ?
  		                transformPromiseWith(this._ongoingPromise, returnSteps, returnSteps) :
  		                returnSteps();
  		        }
  		        _nextSteps() {
  		            if (this._isFinished) {
  		                return Promise.resolve({ value: undefined, done: true });
  		            }
  		            const reader = this._reader;
  		            if (reader._ownerReadableStream === undefined) {
  		                return promiseRejectedWith(readerLockException('iterate'));
  		            }
  		            let resolvePromise;
  		            let rejectPromise;
  		            const promise = newPromise((resolve, reject) => {
  		                resolvePromise = resolve;
  		                rejectPromise = reject;
  		            });
  		            const readRequest = {
  		                _chunkSteps: chunk => {
  		                    this._ongoingPromise = undefined;
  		                    // This needs to be delayed by one microtask, otherwise we stop pulling too early which breaks a test.
  		                    // FIXME Is this a bug in the specification, or in the test?
  		                    queueMicrotask(() => resolvePromise({ value: chunk, done: false }));
  		                },
  		                _closeSteps: () => {
  		                    this._ongoingPromise = undefined;
  		                    this._isFinished = true;
  		                    ReadableStreamReaderGenericRelease(reader);
  		                    resolvePromise({ value: undefined, done: true });
  		                },
  		                _errorSteps: reason => {
  		                    this._ongoingPromise = undefined;
  		                    this._isFinished = true;
  		                    ReadableStreamReaderGenericRelease(reader);
  		                    rejectPromise(reason);
  		                }
  		            };
  		            ReadableStreamDefaultReaderRead(reader, readRequest);
  		            return promise;
  		        }
  		        _returnSteps(value) {
  		            if (this._isFinished) {
  		                return Promise.resolve({ value, done: true });
  		            }
  		            this._isFinished = true;
  		            const reader = this._reader;
  		            if (reader._ownerReadableStream === undefined) {
  		                return promiseRejectedWith(readerLockException('finish iterating'));
  		            }
  		            if (!this._preventCancel) {
  		                const result = ReadableStreamReaderGenericCancel(reader, value);
  		                ReadableStreamReaderGenericRelease(reader);
  		                return transformPromiseWith(result, () => ({ value, done: true }));
  		            }
  		            ReadableStreamReaderGenericRelease(reader);
  		            return promiseResolvedWith({ value, done: true });
  		        }
  		    }
  		    const ReadableStreamAsyncIteratorPrototype = {
  		        next() {
  		            if (!IsReadableStreamAsyncIterator(this)) {
  		                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('next'));
  		            }
  		            return this._asyncIteratorImpl.next();
  		        },
  		        return(value) {
  		            if (!IsReadableStreamAsyncIterator(this)) {
  		                return promiseRejectedWith(streamAsyncIteratorBrandCheckException('return'));
  		            }
  		            return this._asyncIteratorImpl.return(value);
  		        }
  		    };
  		    if (AsyncIteratorPrototype !== undefined) {
  		        Object.setPrototypeOf(ReadableStreamAsyncIteratorPrototype, AsyncIteratorPrototype);
  		    }
  		    // Abstract operations for the ReadableStream.
  		    function AcquireReadableStreamAsyncIterator(stream, preventCancel) {
  		        const reader = AcquireReadableStreamDefaultReader(stream);
  		        const impl = new ReadableStreamAsyncIteratorImpl(reader, preventCancel);
  		        const iterator = Object.create(ReadableStreamAsyncIteratorPrototype);
  		        iterator._asyncIteratorImpl = impl;
  		        return iterator;
  		    }
  		    function IsReadableStreamAsyncIterator(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_asyncIteratorImpl')) {
  		            return false;
  		        }
  		        try {
  		            // noinspection SuspiciousTypeOfGuard
  		            return x._asyncIteratorImpl instanceof
  		                ReadableStreamAsyncIteratorImpl;
  		        }
  		        catch (_a) {
  		            return false;
  		        }
  		    }
  		    // Helper functions for the ReadableStream.
  		    function streamAsyncIteratorBrandCheckException(name) {
  		        return new TypeError(`ReadableStreamAsyncIterator.${name} can only be used on a ReadableSteamAsyncIterator`);
  		    }

  		    /// <reference lib="es2015.core" />
  		    // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Number/isNaN#Polyfill
  		    const NumberIsNaN = Number.isNaN || function (x) {
  		        // eslint-disable-next-line no-self-compare
  		        return x !== x;
  		    };

  		    function CreateArrayFromList(elements) {
  		        // We use arrays to represent lists, so this is basically a no-op.
  		        // Do a slice though just in case we happen to depend on the unique-ness.
  		        return elements.slice();
  		    }
  		    function CopyDataBlockBytes(dest, destOffset, src, srcOffset, n) {
  		        new Uint8Array(dest).set(new Uint8Array(src, srcOffset, n), destOffset);
  		    }
  		    // Not implemented correctly
  		    function TransferArrayBuffer(O) {
  		        return O;
  		    }
  		    // Not implemented correctly
  		    // eslint-disable-next-line @typescript-eslint/no-unused-vars
  		    function IsDetachedBuffer(O) {
  		        return false;
  		    }
  		    function ArrayBufferSlice(buffer, begin, end) {
  		        // ArrayBuffer.prototype.slice is not available on IE10
  		        // https://www.caniuse.com/mdn-javascript_builtins_arraybuffer_slice
  		        if (buffer.slice) {
  		            return buffer.slice(begin, end);
  		        }
  		        const length = end - begin;
  		        const slice = new ArrayBuffer(length);
  		        CopyDataBlockBytes(slice, 0, buffer, begin, length);
  		        return slice;
  		    }

  		    function IsNonNegativeNumber(v) {
  		        if (typeof v !== 'number') {
  		            return false;
  		        }
  		        if (NumberIsNaN(v)) {
  		            return false;
  		        }
  		        if (v < 0) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    function CloneAsUint8Array(O) {
  		        const buffer = ArrayBufferSlice(O.buffer, O.byteOffset, O.byteOffset + O.byteLength);
  		        return new Uint8Array(buffer);
  		    }

  		    function DequeueValue(container) {
  		        const pair = container._queue.shift();
  		        container._queueTotalSize -= pair.size;
  		        if (container._queueTotalSize < 0) {
  		            container._queueTotalSize = 0;
  		        }
  		        return pair.value;
  		    }
  		    function EnqueueValueWithSize(container, value, size) {
  		        if (!IsNonNegativeNumber(size) || size === Infinity) {
  		            throw new RangeError('Size must be a finite, non-NaN, non-negative number.');
  		        }
  		        container._queue.push({ value, size });
  		        container._queueTotalSize += size;
  		    }
  		    function PeekQueueValue(container) {
  		        const pair = container._queue.peek();
  		        return pair.value;
  		    }
  		    function ResetQueue(container) {
  		        container._queue = new SimpleQueue();
  		        container._queueTotalSize = 0;
  		    }

  		    /**
  		     * A pull-into request in a {@link ReadableByteStreamController}.
  		     *
  		     * @public
  		     */
  		    class ReadableStreamBYOBRequest {
  		        constructor() {
  		            throw new TypeError('Illegal constructor');
  		        }
  		        /**
  		         * Returns the view for writing in to, or `null` if the BYOB request has already been responded to.
  		         */
  		        get view() {
  		            if (!IsReadableStreamBYOBRequest(this)) {
  		                throw byobRequestBrandCheckException('view');
  		            }
  		            return this._view;
  		        }
  		        respond(bytesWritten) {
  		            if (!IsReadableStreamBYOBRequest(this)) {
  		                throw byobRequestBrandCheckException('respond');
  		            }
  		            assertRequiredArgument(bytesWritten, 1, 'respond');
  		            bytesWritten = convertUnsignedLongLongWithEnforceRange(bytesWritten, 'First parameter');
  		            if (this._associatedReadableByteStreamController === undefined) {
  		                throw new TypeError('This BYOB request has been invalidated');
  		            }
  		            if (IsDetachedBuffer(this._view.buffer)) ;
  		            ReadableByteStreamControllerRespond(this._associatedReadableByteStreamController, bytesWritten);
  		        }
  		        respondWithNewView(view) {
  		            if (!IsReadableStreamBYOBRequest(this)) {
  		                throw byobRequestBrandCheckException('respondWithNewView');
  		            }
  		            assertRequiredArgument(view, 1, 'respondWithNewView');
  		            if (!ArrayBuffer.isView(view)) {
  		                throw new TypeError('You can only respond with array buffer views');
  		            }
  		            if (this._associatedReadableByteStreamController === undefined) {
  		                throw new TypeError('This BYOB request has been invalidated');
  		            }
  		            if (IsDetachedBuffer(view.buffer)) ;
  		            ReadableByteStreamControllerRespondWithNewView(this._associatedReadableByteStreamController, view);
  		        }
  		    }
  		    Object.defineProperties(ReadableStreamBYOBRequest.prototype, {
  		        respond: { enumerable: true },
  		        respondWithNewView: { enumerable: true },
  		        view: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ReadableStreamBYOBRequest.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ReadableStreamBYOBRequest',
  		            configurable: true
  		        });
  		    }
  		    /**
  		     * Allows control of a {@link ReadableStream | readable byte stream}'s state and internal queue.
  		     *
  		     * @public
  		     */
  		    class ReadableByteStreamController {
  		        constructor() {
  		            throw new TypeError('Illegal constructor');
  		        }
  		        /**
  		         * Returns the current BYOB pull request, or `null` if there isn't one.
  		         */
  		        get byobRequest() {
  		            if (!IsReadableByteStreamController(this)) {
  		                throw byteStreamControllerBrandCheckException('byobRequest');
  		            }
  		            return ReadableByteStreamControllerGetBYOBRequest(this);
  		        }
  		        /**
  		         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
  		         * over-full. An underlying byte source ought to use this information to determine when and how to apply backpressure.
  		         */
  		        get desiredSize() {
  		            if (!IsReadableByteStreamController(this)) {
  		                throw byteStreamControllerBrandCheckException('desiredSize');
  		            }
  		            return ReadableByteStreamControllerGetDesiredSize(this);
  		        }
  		        /**
  		         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
  		         * the stream, but once those are read, the stream will become closed.
  		         */
  		        close() {
  		            if (!IsReadableByteStreamController(this)) {
  		                throw byteStreamControllerBrandCheckException('close');
  		            }
  		            if (this._closeRequested) {
  		                throw new TypeError('The stream has already been closed; do not close it again!');
  		            }
  		            const state = this._controlledReadableByteStream._state;
  		            if (state !== 'readable') {
  		                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be closed`);
  		            }
  		            ReadableByteStreamControllerClose(this);
  		        }
  		        enqueue(chunk) {
  		            if (!IsReadableByteStreamController(this)) {
  		                throw byteStreamControllerBrandCheckException('enqueue');
  		            }
  		            assertRequiredArgument(chunk, 1, 'enqueue');
  		            if (!ArrayBuffer.isView(chunk)) {
  		                throw new TypeError('chunk must be an array buffer view');
  		            }
  		            if (chunk.byteLength === 0) {
  		                throw new TypeError('chunk must have non-zero byteLength');
  		            }
  		            if (chunk.buffer.byteLength === 0) {
  		                throw new TypeError(`chunk's buffer must have non-zero byteLength`);
  		            }
  		            if (this._closeRequested) {
  		                throw new TypeError('stream is closed or draining');
  		            }
  		            const state = this._controlledReadableByteStream._state;
  		            if (state !== 'readable') {
  		                throw new TypeError(`The stream (in ${state} state) is not in the readable state and cannot be enqueued to`);
  		            }
  		            ReadableByteStreamControllerEnqueue(this, chunk);
  		        }
  		        /**
  		         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
  		         */
  		        error(e = undefined) {
  		            if (!IsReadableByteStreamController(this)) {
  		                throw byteStreamControllerBrandCheckException('error');
  		            }
  		            ReadableByteStreamControllerError(this, e);
  		        }
  		        /** @internal */
  		        [CancelSteps](reason) {
  		            ReadableByteStreamControllerClearPendingPullIntos(this);
  		            ResetQueue(this);
  		            const result = this._cancelAlgorithm(reason);
  		            ReadableByteStreamControllerClearAlgorithms(this);
  		            return result;
  		        }
  		        /** @internal */
  		        [PullSteps](readRequest) {
  		            const stream = this._controlledReadableByteStream;
  		            if (this._queueTotalSize > 0) {
  		                const entry = this._queue.shift();
  		                this._queueTotalSize -= entry.byteLength;
  		                ReadableByteStreamControllerHandleQueueDrain(this);
  		                const view = new Uint8Array(entry.buffer, entry.byteOffset, entry.byteLength);
  		                readRequest._chunkSteps(view);
  		                return;
  		            }
  		            const autoAllocateChunkSize = this._autoAllocateChunkSize;
  		            if (autoAllocateChunkSize !== undefined) {
  		                let buffer;
  		                try {
  		                    buffer = new ArrayBuffer(autoAllocateChunkSize);
  		                }
  		                catch (bufferE) {
  		                    readRequest._errorSteps(bufferE);
  		                    return;
  		                }
  		                const pullIntoDescriptor = {
  		                    buffer,
  		                    bufferByteLength: autoAllocateChunkSize,
  		                    byteOffset: 0,
  		                    byteLength: autoAllocateChunkSize,
  		                    bytesFilled: 0,
  		                    elementSize: 1,
  		                    viewConstructor: Uint8Array,
  		                    readerType: 'default'
  		                };
  		                this._pendingPullIntos.push(pullIntoDescriptor);
  		            }
  		            ReadableStreamAddReadRequest(stream, readRequest);
  		            ReadableByteStreamControllerCallPullIfNeeded(this);
  		        }
  		    }
  		    Object.defineProperties(ReadableByteStreamController.prototype, {
  		        close: { enumerable: true },
  		        enqueue: { enumerable: true },
  		        error: { enumerable: true },
  		        byobRequest: { enumerable: true },
  		        desiredSize: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ReadableByteStreamController.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ReadableByteStreamController',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the ReadableByteStreamController.
  		    function IsReadableByteStreamController(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableByteStream')) {
  		            return false;
  		        }
  		        return x instanceof ReadableByteStreamController;
  		    }
  		    function IsReadableStreamBYOBRequest(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_associatedReadableByteStreamController')) {
  		            return false;
  		        }
  		        return x instanceof ReadableStreamBYOBRequest;
  		    }
  		    function ReadableByteStreamControllerCallPullIfNeeded(controller) {
  		        const shouldPull = ReadableByteStreamControllerShouldCallPull(controller);
  		        if (!shouldPull) {
  		            return;
  		        }
  		        if (controller._pulling) {
  		            controller._pullAgain = true;
  		            return;
  		        }
  		        controller._pulling = true;
  		        // TODO: Test controller argument
  		        const pullPromise = controller._pullAlgorithm();
  		        uponPromise(pullPromise, () => {
  		            controller._pulling = false;
  		            if (controller._pullAgain) {
  		                controller._pullAgain = false;
  		                ReadableByteStreamControllerCallPullIfNeeded(controller);
  		            }
  		        }, e => {
  		            ReadableByteStreamControllerError(controller, e);
  		        });
  		    }
  		    function ReadableByteStreamControllerClearPendingPullIntos(controller) {
  		        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  		        controller._pendingPullIntos = new SimpleQueue();
  		    }
  		    function ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor) {
  		        let done = false;
  		        if (stream._state === 'closed') {
  		            done = true;
  		        }
  		        const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
  		        if (pullIntoDescriptor.readerType === 'default') {
  		            ReadableStreamFulfillReadRequest(stream, filledView, done);
  		        }
  		        else {
  		            ReadableStreamFulfillReadIntoRequest(stream, filledView, done);
  		        }
  		    }
  		    function ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor) {
  		        const bytesFilled = pullIntoDescriptor.bytesFilled;
  		        const elementSize = pullIntoDescriptor.elementSize;
  		        return new pullIntoDescriptor.viewConstructor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, bytesFilled / elementSize);
  		    }
  		    function ReadableByteStreamControllerEnqueueChunkToQueue(controller, buffer, byteOffset, byteLength) {
  		        controller._queue.push({ buffer, byteOffset, byteLength });
  		        controller._queueTotalSize += byteLength;
  		    }
  		    function ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor) {
  		        const elementSize = pullIntoDescriptor.elementSize;
  		        const currentAlignedBytes = pullIntoDescriptor.bytesFilled - pullIntoDescriptor.bytesFilled % elementSize;
  		        const maxBytesToCopy = Math.min(controller._queueTotalSize, pullIntoDescriptor.byteLength - pullIntoDescriptor.bytesFilled);
  		        const maxBytesFilled = pullIntoDescriptor.bytesFilled + maxBytesToCopy;
  		        const maxAlignedBytes = maxBytesFilled - maxBytesFilled % elementSize;
  		        let totalBytesToCopyRemaining = maxBytesToCopy;
  		        let ready = false;
  		        if (maxAlignedBytes > currentAlignedBytes) {
  		            totalBytesToCopyRemaining = maxAlignedBytes - pullIntoDescriptor.bytesFilled;
  		            ready = true;
  		        }
  		        const queue = controller._queue;
  		        while (totalBytesToCopyRemaining > 0) {
  		            const headOfQueue = queue.peek();
  		            const bytesToCopy = Math.min(totalBytesToCopyRemaining, headOfQueue.byteLength);
  		            const destStart = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
  		            CopyDataBlockBytes(pullIntoDescriptor.buffer, destStart, headOfQueue.buffer, headOfQueue.byteOffset, bytesToCopy);
  		            if (headOfQueue.byteLength === bytesToCopy) {
  		                queue.shift();
  		            }
  		            else {
  		                headOfQueue.byteOffset += bytesToCopy;
  		                headOfQueue.byteLength -= bytesToCopy;
  		            }
  		            controller._queueTotalSize -= bytesToCopy;
  		            ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesToCopy, pullIntoDescriptor);
  		            totalBytesToCopyRemaining -= bytesToCopy;
  		        }
  		        return ready;
  		    }
  		    function ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, size, pullIntoDescriptor) {
  		        pullIntoDescriptor.bytesFilled += size;
  		    }
  		    function ReadableByteStreamControllerHandleQueueDrain(controller) {
  		        if (controller._queueTotalSize === 0 && controller._closeRequested) {
  		            ReadableByteStreamControllerClearAlgorithms(controller);
  		            ReadableStreamClose(controller._controlledReadableByteStream);
  		        }
  		        else {
  		            ReadableByteStreamControllerCallPullIfNeeded(controller);
  		        }
  		    }
  		    function ReadableByteStreamControllerInvalidateBYOBRequest(controller) {
  		        if (controller._byobRequest === null) {
  		            return;
  		        }
  		        controller._byobRequest._associatedReadableByteStreamController = undefined;
  		        controller._byobRequest._view = null;
  		        controller._byobRequest = null;
  		    }
  		    function ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller) {
  		        while (controller._pendingPullIntos.length > 0) {
  		            if (controller._queueTotalSize === 0) {
  		                return;
  		            }
  		            const pullIntoDescriptor = controller._pendingPullIntos.peek();
  		            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
  		                ReadableByteStreamControllerShiftPendingPullInto(controller);
  		                ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
  		            }
  		        }
  		    }
  		    function ReadableByteStreamControllerPullInto(controller, view, readIntoRequest) {
  		        const stream = controller._controlledReadableByteStream;
  		        let elementSize = 1;
  		        if (view.constructor !== DataView) {
  		            elementSize = view.constructor.BYTES_PER_ELEMENT;
  		        }
  		        const ctor = view.constructor;
  		        // try {
  		        const buffer = TransferArrayBuffer(view.buffer);
  		        // } catch (e) {
  		        //   readIntoRequest._errorSteps(e);
  		        //   return;
  		        // }
  		        const pullIntoDescriptor = {
  		            buffer,
  		            bufferByteLength: buffer.byteLength,
  		            byteOffset: view.byteOffset,
  		            byteLength: view.byteLength,
  		            bytesFilled: 0,
  		            elementSize,
  		            viewConstructor: ctor,
  		            readerType: 'byob'
  		        };
  		        if (controller._pendingPullIntos.length > 0) {
  		            controller._pendingPullIntos.push(pullIntoDescriptor);
  		            // No ReadableByteStreamControllerCallPullIfNeeded() call since:
  		            // - No change happens on desiredSize
  		            // - The source has already been notified of that there's at least 1 pending read(view)
  		            ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
  		            return;
  		        }
  		        if (stream._state === 'closed') {
  		            const emptyView = new ctor(pullIntoDescriptor.buffer, pullIntoDescriptor.byteOffset, 0);
  		            readIntoRequest._closeSteps(emptyView);
  		            return;
  		        }
  		        if (controller._queueTotalSize > 0) {
  		            if (ReadableByteStreamControllerFillPullIntoDescriptorFromQueue(controller, pullIntoDescriptor)) {
  		                const filledView = ReadableByteStreamControllerConvertPullIntoDescriptor(pullIntoDescriptor);
  		                ReadableByteStreamControllerHandleQueueDrain(controller);
  		                readIntoRequest._chunkSteps(filledView);
  		                return;
  		            }
  		            if (controller._closeRequested) {
  		                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
  		                ReadableByteStreamControllerError(controller, e);
  		                readIntoRequest._errorSteps(e);
  		                return;
  		            }
  		        }
  		        controller._pendingPullIntos.push(pullIntoDescriptor);
  		        ReadableStreamAddReadIntoRequest(stream, readIntoRequest);
  		        ReadableByteStreamControllerCallPullIfNeeded(controller);
  		    }
  		    function ReadableByteStreamControllerRespondInClosedState(controller, firstDescriptor) {
  		        const stream = controller._controlledReadableByteStream;
  		        if (ReadableStreamHasBYOBReader(stream)) {
  		            while (ReadableStreamGetNumReadIntoRequests(stream) > 0) {
  		                const pullIntoDescriptor = ReadableByteStreamControllerShiftPendingPullInto(controller);
  		                ReadableByteStreamControllerCommitPullIntoDescriptor(stream, pullIntoDescriptor);
  		            }
  		        }
  		    }
  		    function ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, pullIntoDescriptor) {
  		        ReadableByteStreamControllerFillHeadPullIntoDescriptor(controller, bytesWritten, pullIntoDescriptor);
  		        if (pullIntoDescriptor.bytesFilled < pullIntoDescriptor.elementSize) {
  		            return;
  		        }
  		        ReadableByteStreamControllerShiftPendingPullInto(controller);
  		        const remainderSize = pullIntoDescriptor.bytesFilled % pullIntoDescriptor.elementSize;
  		        if (remainderSize > 0) {
  		            const end = pullIntoDescriptor.byteOffset + pullIntoDescriptor.bytesFilled;
  		            const remainder = ArrayBufferSlice(pullIntoDescriptor.buffer, end - remainderSize, end);
  		            ReadableByteStreamControllerEnqueueChunkToQueue(controller, remainder, 0, remainder.byteLength);
  		        }
  		        pullIntoDescriptor.bytesFilled -= remainderSize;
  		        ReadableByteStreamControllerCommitPullIntoDescriptor(controller._controlledReadableByteStream, pullIntoDescriptor);
  		        ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  		    }
  		    function ReadableByteStreamControllerRespondInternal(controller, bytesWritten) {
  		        const firstDescriptor = controller._pendingPullIntos.peek();
  		        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  		        const state = controller._controlledReadableByteStream._state;
  		        if (state === 'closed') {
  		            ReadableByteStreamControllerRespondInClosedState(controller);
  		        }
  		        else {
  		            ReadableByteStreamControllerRespondInReadableState(controller, bytesWritten, firstDescriptor);
  		        }
  		        ReadableByteStreamControllerCallPullIfNeeded(controller);
  		    }
  		    function ReadableByteStreamControllerShiftPendingPullInto(controller) {
  		        const descriptor = controller._pendingPullIntos.shift();
  		        return descriptor;
  		    }
  		    function ReadableByteStreamControllerShouldCallPull(controller) {
  		        const stream = controller._controlledReadableByteStream;
  		        if (stream._state !== 'readable') {
  		            return false;
  		        }
  		        if (controller._closeRequested) {
  		            return false;
  		        }
  		        if (!controller._started) {
  		            return false;
  		        }
  		        if (ReadableStreamHasDefaultReader(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
  		            return true;
  		        }
  		        if (ReadableStreamHasBYOBReader(stream) && ReadableStreamGetNumReadIntoRequests(stream) > 0) {
  		            return true;
  		        }
  		        const desiredSize = ReadableByteStreamControllerGetDesiredSize(controller);
  		        if (desiredSize > 0) {
  		            return true;
  		        }
  		        return false;
  		    }
  		    function ReadableByteStreamControllerClearAlgorithms(controller) {
  		        controller._pullAlgorithm = undefined;
  		        controller._cancelAlgorithm = undefined;
  		    }
  		    // A client of ReadableByteStreamController may use these functions directly to bypass state check.
  		    function ReadableByteStreamControllerClose(controller) {
  		        const stream = controller._controlledReadableByteStream;
  		        if (controller._closeRequested || stream._state !== 'readable') {
  		            return;
  		        }
  		        if (controller._queueTotalSize > 0) {
  		            controller._closeRequested = true;
  		            return;
  		        }
  		        if (controller._pendingPullIntos.length > 0) {
  		            const firstPendingPullInto = controller._pendingPullIntos.peek();
  		            if (firstPendingPullInto.bytesFilled > 0) {
  		                const e = new TypeError('Insufficient bytes to fill elements in the given buffer');
  		                ReadableByteStreamControllerError(controller, e);
  		                throw e;
  		            }
  		        }
  		        ReadableByteStreamControllerClearAlgorithms(controller);
  		        ReadableStreamClose(stream);
  		    }
  		    function ReadableByteStreamControllerEnqueue(controller, chunk) {
  		        const stream = controller._controlledReadableByteStream;
  		        if (controller._closeRequested || stream._state !== 'readable') {
  		            return;
  		        }
  		        const buffer = chunk.buffer;
  		        const byteOffset = chunk.byteOffset;
  		        const byteLength = chunk.byteLength;
  		        const transferredBuffer = TransferArrayBuffer(buffer);
  		        if (controller._pendingPullIntos.length > 0) {
  		            const firstPendingPullInto = controller._pendingPullIntos.peek();
  		            if (IsDetachedBuffer(firstPendingPullInto.buffer)) ;
  		            firstPendingPullInto.buffer = TransferArrayBuffer(firstPendingPullInto.buffer);
  		        }
  		        ReadableByteStreamControllerInvalidateBYOBRequest(controller);
  		        if (ReadableStreamHasDefaultReader(stream)) {
  		            if (ReadableStreamGetNumReadRequests(stream) === 0) {
  		                ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  		            }
  		            else {
  		                if (controller._pendingPullIntos.length > 0) {
  		                    ReadableByteStreamControllerShiftPendingPullInto(controller);
  		                }
  		                const transferredView = new Uint8Array(transferredBuffer, byteOffset, byteLength);
  		                ReadableStreamFulfillReadRequest(stream, transferredView, false);
  		            }
  		        }
  		        else if (ReadableStreamHasBYOBReader(stream)) {
  		            // TODO: Ideally in this branch detaching should happen only if the buffer is not consumed fully.
  		            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  		            ReadableByteStreamControllerProcessPullIntoDescriptorsUsingQueue(controller);
  		        }
  		        else {
  		            ReadableByteStreamControllerEnqueueChunkToQueue(controller, transferredBuffer, byteOffset, byteLength);
  		        }
  		        ReadableByteStreamControllerCallPullIfNeeded(controller);
  		    }
  		    function ReadableByteStreamControllerError(controller, e) {
  		        const stream = controller._controlledReadableByteStream;
  		        if (stream._state !== 'readable') {
  		            return;
  		        }
  		        ReadableByteStreamControllerClearPendingPullIntos(controller);
  		        ResetQueue(controller);
  		        ReadableByteStreamControllerClearAlgorithms(controller);
  		        ReadableStreamError(stream, e);
  		    }
  		    function ReadableByteStreamControllerGetBYOBRequest(controller) {
  		        if (controller._byobRequest === null && controller._pendingPullIntos.length > 0) {
  		            const firstDescriptor = controller._pendingPullIntos.peek();
  		            const view = new Uint8Array(firstDescriptor.buffer, firstDescriptor.byteOffset + firstDescriptor.bytesFilled, firstDescriptor.byteLength - firstDescriptor.bytesFilled);
  		            const byobRequest = Object.create(ReadableStreamBYOBRequest.prototype);
  		            SetUpReadableStreamBYOBRequest(byobRequest, controller, view);
  		            controller._byobRequest = byobRequest;
  		        }
  		        return controller._byobRequest;
  		    }
  		    function ReadableByteStreamControllerGetDesiredSize(controller) {
  		        const state = controller._controlledReadableByteStream._state;
  		        if (state === 'errored') {
  		            return null;
  		        }
  		        if (state === 'closed') {
  		            return 0;
  		        }
  		        return controller._strategyHWM - controller._queueTotalSize;
  		    }
  		    function ReadableByteStreamControllerRespond(controller, bytesWritten) {
  		        const firstDescriptor = controller._pendingPullIntos.peek();
  		        const state = controller._controlledReadableByteStream._state;
  		        if (state === 'closed') {
  		            if (bytesWritten !== 0) {
  		                throw new TypeError('bytesWritten must be 0 when calling respond() on a closed stream');
  		            }
  		        }
  		        else {
  		            if (bytesWritten === 0) {
  		                throw new TypeError('bytesWritten must be greater than 0 when calling respond() on a readable stream');
  		            }
  		            if (firstDescriptor.bytesFilled + bytesWritten > firstDescriptor.byteLength) {
  		                throw new RangeError('bytesWritten out of range');
  		            }
  		        }
  		        firstDescriptor.buffer = TransferArrayBuffer(firstDescriptor.buffer);
  		        ReadableByteStreamControllerRespondInternal(controller, bytesWritten);
  		    }
  		    function ReadableByteStreamControllerRespondWithNewView(controller, view) {
  		        const firstDescriptor = controller._pendingPullIntos.peek();
  		        const state = controller._controlledReadableByteStream._state;
  		        if (state === 'closed') {
  		            if (view.byteLength !== 0) {
  		                throw new TypeError('The view\'s length must be 0 when calling respondWithNewView() on a closed stream');
  		            }
  		        }
  		        else {
  		            if (view.byteLength === 0) {
  		                throw new TypeError('The view\'s length must be greater than 0 when calling respondWithNewView() on a readable stream');
  		            }
  		        }
  		        if (firstDescriptor.byteOffset + firstDescriptor.bytesFilled !== view.byteOffset) {
  		            throw new RangeError('The region specified by view does not match byobRequest');
  		        }
  		        if (firstDescriptor.bufferByteLength !== view.buffer.byteLength) {
  		            throw new RangeError('The buffer of view has different capacity than byobRequest');
  		        }
  		        if (firstDescriptor.bytesFilled + view.byteLength > firstDescriptor.byteLength) {
  		            throw new RangeError('The region specified by view is larger than byobRequest');
  		        }
  		        const viewByteLength = view.byteLength;
  		        firstDescriptor.buffer = TransferArrayBuffer(view.buffer);
  		        ReadableByteStreamControllerRespondInternal(controller, viewByteLength);
  		    }
  		    function SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize) {
  		        controller._controlledReadableByteStream = stream;
  		        controller._pullAgain = false;
  		        controller._pulling = false;
  		        controller._byobRequest = null;
  		        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
  		        controller._queue = controller._queueTotalSize = undefined;
  		        ResetQueue(controller);
  		        controller._closeRequested = false;
  		        controller._started = false;
  		        controller._strategyHWM = highWaterMark;
  		        controller._pullAlgorithm = pullAlgorithm;
  		        controller._cancelAlgorithm = cancelAlgorithm;
  		        controller._autoAllocateChunkSize = autoAllocateChunkSize;
  		        controller._pendingPullIntos = new SimpleQueue();
  		        stream._readableStreamController = controller;
  		        const startResult = startAlgorithm();
  		        uponPromise(promiseResolvedWith(startResult), () => {
  		            controller._started = true;
  		            ReadableByteStreamControllerCallPullIfNeeded(controller);
  		        }, r => {
  		            ReadableByteStreamControllerError(controller, r);
  		        });
  		    }
  		    function SetUpReadableByteStreamControllerFromUnderlyingSource(stream, underlyingByteSource, highWaterMark) {
  		        const controller = Object.create(ReadableByteStreamController.prototype);
  		        let startAlgorithm = () => undefined;
  		        let pullAlgorithm = () => promiseResolvedWith(undefined);
  		        let cancelAlgorithm = () => promiseResolvedWith(undefined);
  		        if (underlyingByteSource.start !== undefined) {
  		            startAlgorithm = () => underlyingByteSource.start(controller);
  		        }
  		        if (underlyingByteSource.pull !== undefined) {
  		            pullAlgorithm = () => underlyingByteSource.pull(controller);
  		        }
  		        if (underlyingByteSource.cancel !== undefined) {
  		            cancelAlgorithm = reason => underlyingByteSource.cancel(reason);
  		        }
  		        const autoAllocateChunkSize = underlyingByteSource.autoAllocateChunkSize;
  		        if (autoAllocateChunkSize === 0) {
  		            throw new TypeError('autoAllocateChunkSize must be greater than 0');
  		        }
  		        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, autoAllocateChunkSize);
  		    }
  		    function SetUpReadableStreamBYOBRequest(request, controller, view) {
  		        request._associatedReadableByteStreamController = controller;
  		        request._view = view;
  		    }
  		    // Helper functions for the ReadableStreamBYOBRequest.
  		    function byobRequestBrandCheckException(name) {
  		        return new TypeError(`ReadableStreamBYOBRequest.prototype.${name} can only be used on a ReadableStreamBYOBRequest`);
  		    }
  		    // Helper functions for the ReadableByteStreamController.
  		    function byteStreamControllerBrandCheckException(name) {
  		        return new TypeError(`ReadableByteStreamController.prototype.${name} can only be used on a ReadableByteStreamController`);
  		    }

  		    // Abstract operations for the ReadableStream.
  		    function AcquireReadableStreamBYOBReader(stream) {
  		        return new ReadableStreamBYOBReader(stream);
  		    }
  		    // ReadableStream API exposed for controllers.
  		    function ReadableStreamAddReadIntoRequest(stream, readIntoRequest) {
  		        stream._reader._readIntoRequests.push(readIntoRequest);
  		    }
  		    function ReadableStreamFulfillReadIntoRequest(stream, chunk, done) {
  		        const reader = stream._reader;
  		        const readIntoRequest = reader._readIntoRequests.shift();
  		        if (done) {
  		            readIntoRequest._closeSteps(chunk);
  		        }
  		        else {
  		            readIntoRequest._chunkSteps(chunk);
  		        }
  		    }
  		    function ReadableStreamGetNumReadIntoRequests(stream) {
  		        return stream._reader._readIntoRequests.length;
  		    }
  		    function ReadableStreamHasBYOBReader(stream) {
  		        const reader = stream._reader;
  		        if (reader === undefined) {
  		            return false;
  		        }
  		        if (!IsReadableStreamBYOBReader(reader)) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    /**
  		     * A BYOB reader vended by a {@link ReadableStream}.
  		     *
  		     * @public
  		     */
  		    class ReadableStreamBYOBReader {
  		        constructor(stream) {
  		            assertRequiredArgument(stream, 1, 'ReadableStreamBYOBReader');
  		            assertReadableStream(stream, 'First parameter');
  		            if (IsReadableStreamLocked(stream)) {
  		                throw new TypeError('This stream has already been locked for exclusive reading by another reader');
  		            }
  		            if (!IsReadableByteStreamController(stream._readableStreamController)) {
  		                throw new TypeError('Cannot construct a ReadableStreamBYOBReader for a stream not constructed with a byte ' +
  		                    'source');
  		            }
  		            ReadableStreamReaderGenericInitialize(this, stream);
  		            this._readIntoRequests = new SimpleQueue();
  		        }
  		        /**
  		         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
  		         * the reader's lock is released before the stream finishes closing.
  		         */
  		        get closed() {
  		            if (!IsReadableStreamBYOBReader(this)) {
  		                return promiseRejectedWith(byobReaderBrandCheckException('closed'));
  		            }
  		            return this._closedPromise;
  		        }
  		        /**
  		         * If the reader is active, behaves the same as {@link ReadableStream.cancel | stream.cancel(reason)}.
  		         */
  		        cancel(reason = undefined) {
  		            if (!IsReadableStreamBYOBReader(this)) {
  		                return promiseRejectedWith(byobReaderBrandCheckException('cancel'));
  		            }
  		            if (this._ownerReadableStream === undefined) {
  		                return promiseRejectedWith(readerLockException('cancel'));
  		            }
  		            return ReadableStreamReaderGenericCancel(this, reason);
  		        }
  		        /**
  		         * Attempts to reads bytes into view, and returns a promise resolved with the result.
  		         *
  		         * If reading a chunk causes the queue to become empty, more data will be pulled from the underlying source.
  		         */
  		        read(view) {
  		            if (!IsReadableStreamBYOBReader(this)) {
  		                return promiseRejectedWith(byobReaderBrandCheckException('read'));
  		            }
  		            if (!ArrayBuffer.isView(view)) {
  		                return promiseRejectedWith(new TypeError('view must be an array buffer view'));
  		            }
  		            if (view.byteLength === 0) {
  		                return promiseRejectedWith(new TypeError('view must have non-zero byteLength'));
  		            }
  		            if (view.buffer.byteLength === 0) {
  		                return promiseRejectedWith(new TypeError(`view's buffer must have non-zero byteLength`));
  		            }
  		            if (IsDetachedBuffer(view.buffer)) ;
  		            if (this._ownerReadableStream === undefined) {
  		                return promiseRejectedWith(readerLockException('read from'));
  		            }
  		            let resolvePromise;
  		            let rejectPromise;
  		            const promise = newPromise((resolve, reject) => {
  		                resolvePromise = resolve;
  		                rejectPromise = reject;
  		            });
  		            const readIntoRequest = {
  		                _chunkSteps: chunk => resolvePromise({ value: chunk, done: false }),
  		                _closeSteps: chunk => resolvePromise({ value: chunk, done: true }),
  		                _errorSteps: e => rejectPromise(e)
  		            };
  		            ReadableStreamBYOBReaderRead(this, view, readIntoRequest);
  		            return promise;
  		        }
  		        /**
  		         * Releases the reader's lock on the corresponding stream. After the lock is released, the reader is no longer active.
  		         * If the associated stream is errored when the lock is released, the reader will appear errored in the same way
  		         * from now on; otherwise, the reader will appear closed.
  		         *
  		         * A reader's lock cannot be released while it still has a pending read request, i.e., if a promise returned by
  		         * the reader's {@link ReadableStreamBYOBReader.read | read()} method has not yet been settled. Attempting to
  		         * do so will throw a `TypeError` and leave the reader locked to the stream.
  		         */
  		        releaseLock() {
  		            if (!IsReadableStreamBYOBReader(this)) {
  		                throw byobReaderBrandCheckException('releaseLock');
  		            }
  		            if (this._ownerReadableStream === undefined) {
  		                return;
  		            }
  		            if (this._readIntoRequests.length > 0) {
  		                throw new TypeError('Tried to release a reader lock when that reader has pending read() calls un-settled');
  		            }
  		            ReadableStreamReaderGenericRelease(this);
  		        }
  		    }
  		    Object.defineProperties(ReadableStreamBYOBReader.prototype, {
  		        cancel: { enumerable: true },
  		        read: { enumerable: true },
  		        releaseLock: { enumerable: true },
  		        closed: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ReadableStreamBYOBReader.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ReadableStreamBYOBReader',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the readers.
  		    function IsReadableStreamBYOBReader(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_readIntoRequests')) {
  		            return false;
  		        }
  		        return x instanceof ReadableStreamBYOBReader;
  		    }
  		    function ReadableStreamBYOBReaderRead(reader, view, readIntoRequest) {
  		        const stream = reader._ownerReadableStream;
  		        stream._disturbed = true;
  		        if (stream._state === 'errored') {
  		            readIntoRequest._errorSteps(stream._storedError);
  		        }
  		        else {
  		            ReadableByteStreamControllerPullInto(stream._readableStreamController, view, readIntoRequest);
  		        }
  		    }
  		    // Helper functions for the ReadableStreamBYOBReader.
  		    function byobReaderBrandCheckException(name) {
  		        return new TypeError(`ReadableStreamBYOBReader.prototype.${name} can only be used on a ReadableStreamBYOBReader`);
  		    }

  		    function ExtractHighWaterMark(strategy, defaultHWM) {
  		        const { highWaterMark } = strategy;
  		        if (highWaterMark === undefined) {
  		            return defaultHWM;
  		        }
  		        if (NumberIsNaN(highWaterMark) || highWaterMark < 0) {
  		            throw new RangeError('Invalid highWaterMark');
  		        }
  		        return highWaterMark;
  		    }
  		    function ExtractSizeAlgorithm(strategy) {
  		        const { size } = strategy;
  		        if (!size) {
  		            return () => 1;
  		        }
  		        return size;
  		    }

  		    function convertQueuingStrategy(init, context) {
  		        assertDictionary(init, context);
  		        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  		        const size = init === null || init === void 0 ? void 0 : init.size;
  		        return {
  		            highWaterMark: highWaterMark === undefined ? undefined : convertUnrestrictedDouble(highWaterMark),
  		            size: size === undefined ? undefined : convertQueuingStrategySize(size, `${context} has member 'size' that`)
  		        };
  		    }
  		    function convertQueuingStrategySize(fn, context) {
  		        assertFunction(fn, context);
  		        return chunk => convertUnrestrictedDouble(fn(chunk));
  		    }

  		    function convertUnderlyingSink(original, context) {
  		        assertDictionary(original, context);
  		        const abort = original === null || original === void 0 ? void 0 : original.abort;
  		        const close = original === null || original === void 0 ? void 0 : original.close;
  		        const start = original === null || original === void 0 ? void 0 : original.start;
  		        const type = original === null || original === void 0 ? void 0 : original.type;
  		        const write = original === null || original === void 0 ? void 0 : original.write;
  		        return {
  		            abort: abort === undefined ?
  		                undefined :
  		                convertUnderlyingSinkAbortCallback(abort, original, `${context} has member 'abort' that`),
  		            close: close === undefined ?
  		                undefined :
  		                convertUnderlyingSinkCloseCallback(close, original, `${context} has member 'close' that`),
  		            start: start === undefined ?
  		                undefined :
  		                convertUnderlyingSinkStartCallback(start, original, `${context} has member 'start' that`),
  		            write: write === undefined ?
  		                undefined :
  		                convertUnderlyingSinkWriteCallback(write, original, `${context} has member 'write' that`),
  		            type
  		        };
  		    }
  		    function convertUnderlyingSinkAbortCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (reason) => promiseCall(fn, original, [reason]);
  		    }
  		    function convertUnderlyingSinkCloseCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return () => promiseCall(fn, original, []);
  		    }
  		    function convertUnderlyingSinkStartCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (controller) => reflectCall(fn, original, [controller]);
  		    }
  		    function convertUnderlyingSinkWriteCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
  		    }

  		    function assertWritableStream(x, context) {
  		        if (!IsWritableStream(x)) {
  		            throw new TypeError(`${context} is not a WritableStream.`);
  		        }
  		    }

  		    function isAbortSignal(value) {
  		        if (typeof value !== 'object' || value === null) {
  		            return false;
  		        }
  		        try {
  		            return typeof value.aborted === 'boolean';
  		        }
  		        catch (_a) {
  		            // AbortSignal.prototype.aborted throws if its brand check fails
  		            return false;
  		        }
  		    }
  		    const supportsAbortController = typeof AbortController === 'function';
  		    /**
  		     * Construct a new AbortController, if supported by the platform.
  		     *
  		     * @internal
  		     */
  		    function createAbortController() {
  		        if (supportsAbortController) {
  		            return new AbortController();
  		        }
  		        return undefined;
  		    }

  		    /**
  		     * A writable stream represents a destination for data, into which you can write.
  		     *
  		     * @public
  		     */
  		    class WritableStream {
  		        constructor(rawUnderlyingSink = {}, rawStrategy = {}) {
  		            if (rawUnderlyingSink === undefined) {
  		                rawUnderlyingSink = null;
  		            }
  		            else {
  		                assertObject(rawUnderlyingSink, 'First parameter');
  		            }
  		            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
  		            const underlyingSink = convertUnderlyingSink(rawUnderlyingSink, 'First parameter');
  		            InitializeWritableStream(this);
  		            const type = underlyingSink.type;
  		            if (type !== undefined) {
  		                throw new RangeError('Invalid type is specified');
  		            }
  		            const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
  		            const highWaterMark = ExtractHighWaterMark(strategy, 1);
  		            SetUpWritableStreamDefaultControllerFromUnderlyingSink(this, underlyingSink, highWaterMark, sizeAlgorithm);
  		        }
  		        /**
  		         * Returns whether or not the writable stream is locked to a writer.
  		         */
  		        get locked() {
  		            if (!IsWritableStream(this)) {
  		                throw streamBrandCheckException$2('locked');
  		            }
  		            return IsWritableStreamLocked(this);
  		        }
  		        /**
  		         * Aborts the stream, signaling that the producer can no longer successfully write to the stream and it is to be
  		         * immediately moved to an errored state, with any queued-up writes discarded. This will also execute any abort
  		         * mechanism of the underlying sink.
  		         *
  		         * The returned promise will fulfill if the stream shuts down successfully, or reject if the underlying sink signaled
  		         * that there was an error doing so. Additionally, it will reject with a `TypeError` (without attempting to cancel
  		         * the stream) if the stream is currently locked.
  		         */
  		        abort(reason = undefined) {
  		            if (!IsWritableStream(this)) {
  		                return promiseRejectedWith(streamBrandCheckException$2('abort'));
  		            }
  		            if (IsWritableStreamLocked(this)) {
  		                return promiseRejectedWith(new TypeError('Cannot abort a stream that already has a writer'));
  		            }
  		            return WritableStreamAbort(this, reason);
  		        }
  		        /**
  		         * Closes the stream. The underlying sink will finish processing any previously-written chunks, before invoking its
  		         * close behavior. During this time any further attempts to write will fail (without erroring the stream).
  		         *
  		         * The method returns a promise that will fulfill if all remaining chunks are successfully written and the stream
  		         * successfully closes, or rejects if an error is encountered during this process. Additionally, it will reject with
  		         * a `TypeError` (without attempting to cancel the stream) if the stream is currently locked.
  		         */
  		        close() {
  		            if (!IsWritableStream(this)) {
  		                return promiseRejectedWith(streamBrandCheckException$2('close'));
  		            }
  		            if (IsWritableStreamLocked(this)) {
  		                return promiseRejectedWith(new TypeError('Cannot close a stream that already has a writer'));
  		            }
  		            if (WritableStreamCloseQueuedOrInFlight(this)) {
  		                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
  		            }
  		            return WritableStreamClose(this);
  		        }
  		        /**
  		         * Creates a {@link WritableStreamDefaultWriter | writer} and locks the stream to the new writer. While the stream
  		         * is locked, no other writer can be acquired until this one is released.
  		         *
  		         * This functionality is especially useful for creating abstractions that desire the ability to write to a stream
  		         * without interruption or interleaving. By getting a writer for the stream, you can ensure nobody else can write at
  		         * the same time, which would cause the resulting written data to be unpredictable and probably useless.
  		         */
  		        getWriter() {
  		            if (!IsWritableStream(this)) {
  		                throw streamBrandCheckException$2('getWriter');
  		            }
  		            return AcquireWritableStreamDefaultWriter(this);
  		        }
  		    }
  		    Object.defineProperties(WritableStream.prototype, {
  		        abort: { enumerable: true },
  		        close: { enumerable: true },
  		        getWriter: { enumerable: true },
  		        locked: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(WritableStream.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'WritableStream',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the WritableStream.
  		    function AcquireWritableStreamDefaultWriter(stream) {
  		        return new WritableStreamDefaultWriter(stream);
  		    }
  		    // Throws if and only if startAlgorithm throws.
  		    function CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
  		        const stream = Object.create(WritableStream.prototype);
  		        InitializeWritableStream(stream);
  		        const controller = Object.create(WritableStreamDefaultController.prototype);
  		        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  		        return stream;
  		    }
  		    function InitializeWritableStream(stream) {
  		        stream._state = 'writable';
  		        // The error that will be reported by new method calls once the state becomes errored. Only set when [[state]] is
  		        // 'erroring' or 'errored'. May be set to an undefined value.
  		        stream._storedError = undefined;
  		        stream._writer = undefined;
  		        // Initialize to undefined first because the constructor of the controller checks this
  		        // variable to validate the caller.
  		        stream._writableStreamController = undefined;
  		        // This queue is placed here instead of the writer class in order to allow for passing a writer to the next data
  		        // producer without waiting for the queued writes to finish.
  		        stream._writeRequests = new SimpleQueue();
  		        // Write requests are removed from _writeRequests when write() is called on the underlying sink. This prevents
  		        // them from being erroneously rejected on error. If a write() call is in-flight, the request is stored here.
  		        stream._inFlightWriteRequest = undefined;
  		        // The promise that was returned from writer.close(). Stored here because it may be fulfilled after the writer
  		        // has been detached.
  		        stream._closeRequest = undefined;
  		        // Close request is removed from _closeRequest when close() is called on the underlying sink. This prevents it
  		        // from being erroneously rejected on error. If a close() call is in-flight, the request is stored here.
  		        stream._inFlightCloseRequest = undefined;
  		        // The promise that was returned from writer.abort(). This may also be fulfilled after the writer has detached.
  		        stream._pendingAbortRequest = undefined;
  		        // The backpressure signal set by the controller.
  		        stream._backpressure = false;
  		    }
  		    function IsWritableStream(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_writableStreamController')) {
  		            return false;
  		        }
  		        return x instanceof WritableStream;
  		    }
  		    function IsWritableStreamLocked(stream) {
  		        if (stream._writer === undefined) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    function WritableStreamAbort(stream, reason) {
  		        var _a;
  		        if (stream._state === 'closed' || stream._state === 'errored') {
  		            return promiseResolvedWith(undefined);
  		        }
  		        stream._writableStreamController._abortReason = reason;
  		        (_a = stream._writableStreamController._abortController) === null || _a === void 0 ? void 0 : _a.abort();
  		        // TypeScript narrows the type of `stream._state` down to 'writable' | 'erroring',
  		        // but it doesn't know that signaling abort runs author code that might have changed the state.
  		        // Widen the type again by casting to WritableStreamState.
  		        const state = stream._state;
  		        if (state === 'closed' || state === 'errored') {
  		            return promiseResolvedWith(undefined);
  		        }
  		        if (stream._pendingAbortRequest !== undefined) {
  		            return stream._pendingAbortRequest._promise;
  		        }
  		        let wasAlreadyErroring = false;
  		        if (state === 'erroring') {
  		            wasAlreadyErroring = true;
  		            // reason will not be used, so don't keep a reference to it.
  		            reason = undefined;
  		        }
  		        const promise = newPromise((resolve, reject) => {
  		            stream._pendingAbortRequest = {
  		                _promise: undefined,
  		                _resolve: resolve,
  		                _reject: reject,
  		                _reason: reason,
  		                _wasAlreadyErroring: wasAlreadyErroring
  		            };
  		        });
  		        stream._pendingAbortRequest._promise = promise;
  		        if (!wasAlreadyErroring) {
  		            WritableStreamStartErroring(stream, reason);
  		        }
  		        return promise;
  		    }
  		    function WritableStreamClose(stream) {
  		        const state = stream._state;
  		        if (state === 'closed' || state === 'errored') {
  		            return promiseRejectedWith(new TypeError(`The stream (in ${state} state) is not in the writable state and cannot be closed`));
  		        }
  		        const promise = newPromise((resolve, reject) => {
  		            const closeRequest = {
  		                _resolve: resolve,
  		                _reject: reject
  		            };
  		            stream._closeRequest = closeRequest;
  		        });
  		        const writer = stream._writer;
  		        if (writer !== undefined && stream._backpressure && state === 'writable') {
  		            defaultWriterReadyPromiseResolve(writer);
  		        }
  		        WritableStreamDefaultControllerClose(stream._writableStreamController);
  		        return promise;
  		    }
  		    // WritableStream API exposed for controllers.
  		    function WritableStreamAddWriteRequest(stream) {
  		        const promise = newPromise((resolve, reject) => {
  		            const writeRequest = {
  		                _resolve: resolve,
  		                _reject: reject
  		            };
  		            stream._writeRequests.push(writeRequest);
  		        });
  		        return promise;
  		    }
  		    function WritableStreamDealWithRejection(stream, error) {
  		        const state = stream._state;
  		        if (state === 'writable') {
  		            WritableStreamStartErroring(stream, error);
  		            return;
  		        }
  		        WritableStreamFinishErroring(stream);
  		    }
  		    function WritableStreamStartErroring(stream, reason) {
  		        const controller = stream._writableStreamController;
  		        stream._state = 'erroring';
  		        stream._storedError = reason;
  		        const writer = stream._writer;
  		        if (writer !== undefined) {
  		            WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, reason);
  		        }
  		        if (!WritableStreamHasOperationMarkedInFlight(stream) && controller._started) {
  		            WritableStreamFinishErroring(stream);
  		        }
  		    }
  		    function WritableStreamFinishErroring(stream) {
  		        stream._state = 'errored';
  		        stream._writableStreamController[ErrorSteps]();
  		        const storedError = stream._storedError;
  		        stream._writeRequests.forEach(writeRequest => {
  		            writeRequest._reject(storedError);
  		        });
  		        stream._writeRequests = new SimpleQueue();
  		        if (stream._pendingAbortRequest === undefined) {
  		            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  		            return;
  		        }
  		        const abortRequest = stream._pendingAbortRequest;
  		        stream._pendingAbortRequest = undefined;
  		        if (abortRequest._wasAlreadyErroring) {
  		            abortRequest._reject(storedError);
  		            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  		            return;
  		        }
  		        const promise = stream._writableStreamController[AbortSteps](abortRequest._reason);
  		        uponPromise(promise, () => {
  		            abortRequest._resolve();
  		            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  		        }, (reason) => {
  		            abortRequest._reject(reason);
  		            WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream);
  		        });
  		    }
  		    function WritableStreamFinishInFlightWrite(stream) {
  		        stream._inFlightWriteRequest._resolve(undefined);
  		        stream._inFlightWriteRequest = undefined;
  		    }
  		    function WritableStreamFinishInFlightWriteWithError(stream, error) {
  		        stream._inFlightWriteRequest._reject(error);
  		        stream._inFlightWriteRequest = undefined;
  		        WritableStreamDealWithRejection(stream, error);
  		    }
  		    function WritableStreamFinishInFlightClose(stream) {
  		        stream._inFlightCloseRequest._resolve(undefined);
  		        stream._inFlightCloseRequest = undefined;
  		        const state = stream._state;
  		        if (state === 'erroring') {
  		            // The error was too late to do anything, so it is ignored.
  		            stream._storedError = undefined;
  		            if (stream._pendingAbortRequest !== undefined) {
  		                stream._pendingAbortRequest._resolve();
  		                stream._pendingAbortRequest = undefined;
  		            }
  		        }
  		        stream._state = 'closed';
  		        const writer = stream._writer;
  		        if (writer !== undefined) {
  		            defaultWriterClosedPromiseResolve(writer);
  		        }
  		    }
  		    function WritableStreamFinishInFlightCloseWithError(stream, error) {
  		        stream._inFlightCloseRequest._reject(error);
  		        stream._inFlightCloseRequest = undefined;
  		        // Never execute sink abort() after sink close().
  		        if (stream._pendingAbortRequest !== undefined) {
  		            stream._pendingAbortRequest._reject(error);
  		            stream._pendingAbortRequest = undefined;
  		        }
  		        WritableStreamDealWithRejection(stream, error);
  		    }
  		    // TODO(ricea): Fix alphabetical order.
  		    function WritableStreamCloseQueuedOrInFlight(stream) {
  		        if (stream._closeRequest === undefined && stream._inFlightCloseRequest === undefined) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    function WritableStreamHasOperationMarkedInFlight(stream) {
  		        if (stream._inFlightWriteRequest === undefined && stream._inFlightCloseRequest === undefined) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    function WritableStreamMarkCloseRequestInFlight(stream) {
  		        stream._inFlightCloseRequest = stream._closeRequest;
  		        stream._closeRequest = undefined;
  		    }
  		    function WritableStreamMarkFirstWriteRequestInFlight(stream) {
  		        stream._inFlightWriteRequest = stream._writeRequests.shift();
  		    }
  		    function WritableStreamRejectCloseAndClosedPromiseIfNeeded(stream) {
  		        if (stream._closeRequest !== undefined) {
  		            stream._closeRequest._reject(stream._storedError);
  		            stream._closeRequest = undefined;
  		        }
  		        const writer = stream._writer;
  		        if (writer !== undefined) {
  		            defaultWriterClosedPromiseReject(writer, stream._storedError);
  		        }
  		    }
  		    function WritableStreamUpdateBackpressure(stream, backpressure) {
  		        const writer = stream._writer;
  		        if (writer !== undefined && backpressure !== stream._backpressure) {
  		            if (backpressure) {
  		                defaultWriterReadyPromiseReset(writer);
  		            }
  		            else {
  		                defaultWriterReadyPromiseResolve(writer);
  		            }
  		        }
  		        stream._backpressure = backpressure;
  		    }
  		    /**
  		     * A default writer vended by a {@link WritableStream}.
  		     *
  		     * @public
  		     */
  		    class WritableStreamDefaultWriter {
  		        constructor(stream) {
  		            assertRequiredArgument(stream, 1, 'WritableStreamDefaultWriter');
  		            assertWritableStream(stream, 'First parameter');
  		            if (IsWritableStreamLocked(stream)) {
  		                throw new TypeError('This stream has already been locked for exclusive writing by another writer');
  		            }
  		            this._ownerWritableStream = stream;
  		            stream._writer = this;
  		            const state = stream._state;
  		            if (state === 'writable') {
  		                if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._backpressure) {
  		                    defaultWriterReadyPromiseInitialize(this);
  		                }
  		                else {
  		                    defaultWriterReadyPromiseInitializeAsResolved(this);
  		                }
  		                defaultWriterClosedPromiseInitialize(this);
  		            }
  		            else if (state === 'erroring') {
  		                defaultWriterReadyPromiseInitializeAsRejected(this, stream._storedError);
  		                defaultWriterClosedPromiseInitialize(this);
  		            }
  		            else if (state === 'closed') {
  		                defaultWriterReadyPromiseInitializeAsResolved(this);
  		                defaultWriterClosedPromiseInitializeAsResolved(this);
  		            }
  		            else {
  		                const storedError = stream._storedError;
  		                defaultWriterReadyPromiseInitializeAsRejected(this, storedError);
  		                defaultWriterClosedPromiseInitializeAsRejected(this, storedError);
  		            }
  		        }
  		        /**
  		         * Returns a promise that will be fulfilled when the stream becomes closed, or rejected if the stream ever errors or
  		         * the writers lock is released before the stream finishes closing.
  		         */
  		        get closed() {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                return promiseRejectedWith(defaultWriterBrandCheckException('closed'));
  		            }
  		            return this._closedPromise;
  		        }
  		        /**
  		         * Returns the desired size to fill the streams internal queue. It can be negative, if the queue is over-full.
  		         * A producer can use this information to determine the right amount of data to write.
  		         *
  		         * It will be `null` if the stream cannot be successfully written to (due to either being errored, or having an abort
  		         * queued up). It will return zero if the stream is closed. And the getter will throw an exception if invoked when
  		         * the writers lock is released.
  		         */
  		        get desiredSize() {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                throw defaultWriterBrandCheckException('desiredSize');
  		            }
  		            if (this._ownerWritableStream === undefined) {
  		                throw defaultWriterLockException('desiredSize');
  		            }
  		            return WritableStreamDefaultWriterGetDesiredSize(this);
  		        }
  		        /**
  		         * Returns a promise that will be fulfilled when the desired size to fill the streams internal queue transitions
  		         * from non-positive to positive, signaling that it is no longer applying backpressure. Once the desired size dips
  		         * back to zero or below, the getter will return a new promise that stays pending until the next transition.
  		         *
  		         * If the stream becomes errored or aborted, or the writers lock is released, the returned promise will become
  		         * rejected.
  		         */
  		        get ready() {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                return promiseRejectedWith(defaultWriterBrandCheckException('ready'));
  		            }
  		            return this._readyPromise;
  		        }
  		        /**
  		         * If the reader is active, behaves the same as {@link WritableStream.abort | stream.abort(reason)}.
  		         */
  		        abort(reason = undefined) {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                return promiseRejectedWith(defaultWriterBrandCheckException('abort'));
  		            }
  		            if (this._ownerWritableStream === undefined) {
  		                return promiseRejectedWith(defaultWriterLockException('abort'));
  		            }
  		            return WritableStreamDefaultWriterAbort(this, reason);
  		        }
  		        /**
  		         * If the reader is active, behaves the same as {@link WritableStream.close | stream.close()}.
  		         */
  		        close() {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                return promiseRejectedWith(defaultWriterBrandCheckException('close'));
  		            }
  		            const stream = this._ownerWritableStream;
  		            if (stream === undefined) {
  		                return promiseRejectedWith(defaultWriterLockException('close'));
  		            }
  		            if (WritableStreamCloseQueuedOrInFlight(stream)) {
  		                return promiseRejectedWith(new TypeError('Cannot close an already-closing stream'));
  		            }
  		            return WritableStreamDefaultWriterClose(this);
  		        }
  		        /**
  		         * Releases the writers lock on the corresponding stream. After the lock is released, the writer is no longer active.
  		         * If the associated stream is errored when the lock is released, the writer will appear errored in the same way from
  		         * now on; otherwise, the writer will appear closed.
  		         *
  		         * Note that the lock can still be released even if some ongoing writes have not yet finished (i.e. even if the
  		         * promises returned from previous calls to {@link WritableStreamDefaultWriter.write | write()} have not yet settled).
  		         * Its not necessary to hold the lock on the writer for the duration of the write; the lock instead simply prevents
  		         * other producers from writing in an interleaved manner.
  		         */
  		        releaseLock() {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                throw defaultWriterBrandCheckException('releaseLock');
  		            }
  		            const stream = this._ownerWritableStream;
  		            if (stream === undefined) {
  		                return;
  		            }
  		            WritableStreamDefaultWriterRelease(this);
  		        }
  		        write(chunk = undefined) {
  		            if (!IsWritableStreamDefaultWriter(this)) {
  		                return promiseRejectedWith(defaultWriterBrandCheckException('write'));
  		            }
  		            if (this._ownerWritableStream === undefined) {
  		                return promiseRejectedWith(defaultWriterLockException('write to'));
  		            }
  		            return WritableStreamDefaultWriterWrite(this, chunk);
  		        }
  		    }
  		    Object.defineProperties(WritableStreamDefaultWriter.prototype, {
  		        abort: { enumerable: true },
  		        close: { enumerable: true },
  		        releaseLock: { enumerable: true },
  		        write: { enumerable: true },
  		        closed: { enumerable: true },
  		        desiredSize: { enumerable: true },
  		        ready: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(WritableStreamDefaultWriter.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'WritableStreamDefaultWriter',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the WritableStreamDefaultWriter.
  		    function IsWritableStreamDefaultWriter(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_ownerWritableStream')) {
  		            return false;
  		        }
  		        return x instanceof WritableStreamDefaultWriter;
  		    }
  		    // A client of WritableStreamDefaultWriter may use these functions directly to bypass state check.
  		    function WritableStreamDefaultWriterAbort(writer, reason) {
  		        const stream = writer._ownerWritableStream;
  		        return WritableStreamAbort(stream, reason);
  		    }
  		    function WritableStreamDefaultWriterClose(writer) {
  		        const stream = writer._ownerWritableStream;
  		        return WritableStreamClose(stream);
  		    }
  		    function WritableStreamDefaultWriterCloseWithErrorPropagation(writer) {
  		        const stream = writer._ownerWritableStream;
  		        const state = stream._state;
  		        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
  		            return promiseResolvedWith(undefined);
  		        }
  		        if (state === 'errored') {
  		            return promiseRejectedWith(stream._storedError);
  		        }
  		        return WritableStreamDefaultWriterClose(writer);
  		    }
  		    function WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, error) {
  		        if (writer._closedPromiseState === 'pending') {
  		            defaultWriterClosedPromiseReject(writer, error);
  		        }
  		        else {
  		            defaultWriterClosedPromiseResetToRejected(writer, error);
  		        }
  		    }
  		    function WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, error) {
  		        if (writer._readyPromiseState === 'pending') {
  		            defaultWriterReadyPromiseReject(writer, error);
  		        }
  		        else {
  		            defaultWriterReadyPromiseResetToRejected(writer, error);
  		        }
  		    }
  		    function WritableStreamDefaultWriterGetDesiredSize(writer) {
  		        const stream = writer._ownerWritableStream;
  		        const state = stream._state;
  		        if (state === 'errored' || state === 'erroring') {
  		            return null;
  		        }
  		        if (state === 'closed') {
  		            return 0;
  		        }
  		        return WritableStreamDefaultControllerGetDesiredSize(stream._writableStreamController);
  		    }
  		    function WritableStreamDefaultWriterRelease(writer) {
  		        const stream = writer._ownerWritableStream;
  		        const releasedError = new TypeError(`Writer was released and can no longer be used to monitor the stream's closedness`);
  		        WritableStreamDefaultWriterEnsureReadyPromiseRejected(writer, releasedError);
  		        // The state transitions to "errored" before the sink abort() method runs, but the writer.closed promise is not
  		        // rejected until afterwards. This means that simply testing state will not work.
  		        WritableStreamDefaultWriterEnsureClosedPromiseRejected(writer, releasedError);
  		        stream._writer = undefined;
  		        writer._ownerWritableStream = undefined;
  		    }
  		    function WritableStreamDefaultWriterWrite(writer, chunk) {
  		        const stream = writer._ownerWritableStream;
  		        const controller = stream._writableStreamController;
  		        const chunkSize = WritableStreamDefaultControllerGetChunkSize(controller, chunk);
  		        if (stream !== writer._ownerWritableStream) {
  		            return promiseRejectedWith(defaultWriterLockException('write to'));
  		        }
  		        const state = stream._state;
  		        if (state === 'errored') {
  		            return promiseRejectedWith(stream._storedError);
  		        }
  		        if (WritableStreamCloseQueuedOrInFlight(stream) || state === 'closed') {
  		            return promiseRejectedWith(new TypeError('The stream is closing or closed and cannot be written to'));
  		        }
  		        if (state === 'erroring') {
  		            return promiseRejectedWith(stream._storedError);
  		        }
  		        const promise = WritableStreamAddWriteRequest(stream);
  		        WritableStreamDefaultControllerWrite(controller, chunk, chunkSize);
  		        return promise;
  		    }
  		    const closeSentinel = {};
  		    /**
  		     * Allows control of a {@link WritableStream | writable stream}'s state and internal queue.
  		     *
  		     * @public
  		     */
  		    class WritableStreamDefaultController {
  		        constructor() {
  		            throw new TypeError('Illegal constructor');
  		        }
  		        /**
  		         * The reason which was passed to `WritableStream.abort(reason)` when the stream was aborted.
  		         *
  		         * @deprecated
  		         *  This property has been removed from the specification, see https://github.com/whatwg/streams/pull/1177.
  		         *  Use {@link WritableStreamDefaultController.signal}'s `reason` instead.
  		         */
  		        get abortReason() {
  		            if (!IsWritableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$2('abortReason');
  		            }
  		            return this._abortReason;
  		        }
  		        /**
  		         * An `AbortSignal` that can be used to abort the pending write or close operation when the stream is aborted.
  		         */
  		        get signal() {
  		            if (!IsWritableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$2('signal');
  		            }
  		            if (this._abortController === undefined) {
  		                // Older browsers or older Node versions may not support `AbortController` or `AbortSignal`.
  		                // We don't want to bundle and ship an `AbortController` polyfill together with our polyfill,
  		                // so instead we only implement support for `signal` if we find a global `AbortController` constructor.
  		                throw new TypeError('WritableStreamDefaultController.prototype.signal is not supported');
  		            }
  		            return this._abortController.signal;
  		        }
  		        /**
  		         * Closes the controlled writable stream, making all future interactions with it fail with the given error `e`.
  		         *
  		         * This method is rarely used, since usually it suffices to return a rejected promise from one of the underlying
  		         * sink's methods. However, it can be useful for suddenly shutting down a stream in response to an event outside the
  		         * normal lifecycle of interactions with the underlying sink.
  		         */
  		        error(e = undefined) {
  		            if (!IsWritableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$2('error');
  		            }
  		            const state = this._controlledWritableStream._state;
  		            if (state !== 'writable') {
  		                // The stream is closed, errored or will be soon. The sink can't do anything useful if it gets an error here, so
  		                // just treat it as a no-op.
  		                return;
  		            }
  		            WritableStreamDefaultControllerError(this, e);
  		        }
  		        /** @internal */
  		        [AbortSteps](reason) {
  		            const result = this._abortAlgorithm(reason);
  		            WritableStreamDefaultControllerClearAlgorithms(this);
  		            return result;
  		        }
  		        /** @internal */
  		        [ErrorSteps]() {
  		            ResetQueue(this);
  		        }
  		    }
  		    Object.defineProperties(WritableStreamDefaultController.prototype, {
  		        abortReason: { enumerable: true },
  		        signal: { enumerable: true },
  		        error: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(WritableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'WritableStreamDefaultController',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations implementing interface required by the WritableStream.
  		    function IsWritableStreamDefaultController(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_controlledWritableStream')) {
  		            return false;
  		        }
  		        return x instanceof WritableStreamDefaultController;
  		    }
  		    function SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm) {
  		        controller._controlledWritableStream = stream;
  		        stream._writableStreamController = controller;
  		        // Need to set the slots so that the assert doesn't fire. In the spec the slots already exist implicitly.
  		        controller._queue = undefined;
  		        controller._queueTotalSize = undefined;
  		        ResetQueue(controller);
  		        controller._abortReason = undefined;
  		        controller._abortController = createAbortController();
  		        controller._started = false;
  		        controller._strategySizeAlgorithm = sizeAlgorithm;
  		        controller._strategyHWM = highWaterMark;
  		        controller._writeAlgorithm = writeAlgorithm;
  		        controller._closeAlgorithm = closeAlgorithm;
  		        controller._abortAlgorithm = abortAlgorithm;
  		        const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  		        WritableStreamUpdateBackpressure(stream, backpressure);
  		        const startResult = startAlgorithm();
  		        const startPromise = promiseResolvedWith(startResult);
  		        uponPromise(startPromise, () => {
  		            controller._started = true;
  		            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  		        }, r => {
  		            controller._started = true;
  		            WritableStreamDealWithRejection(stream, r);
  		        });
  		    }
  		    function SetUpWritableStreamDefaultControllerFromUnderlyingSink(stream, underlyingSink, highWaterMark, sizeAlgorithm) {
  		        const controller = Object.create(WritableStreamDefaultController.prototype);
  		        let startAlgorithm = () => undefined;
  		        let writeAlgorithm = () => promiseResolvedWith(undefined);
  		        let closeAlgorithm = () => promiseResolvedWith(undefined);
  		        let abortAlgorithm = () => promiseResolvedWith(undefined);
  		        if (underlyingSink.start !== undefined) {
  		            startAlgorithm = () => underlyingSink.start(controller);
  		        }
  		        if (underlyingSink.write !== undefined) {
  		            writeAlgorithm = chunk => underlyingSink.write(chunk, controller);
  		        }
  		        if (underlyingSink.close !== undefined) {
  		            closeAlgorithm = () => underlyingSink.close();
  		        }
  		        if (underlyingSink.abort !== undefined) {
  		            abortAlgorithm = reason => underlyingSink.abort(reason);
  		        }
  		        SetUpWritableStreamDefaultController(stream, controller, startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, highWaterMark, sizeAlgorithm);
  		    }
  		    // ClearAlgorithms may be called twice. Erroring the same stream in multiple ways will often result in redundant calls.
  		    function WritableStreamDefaultControllerClearAlgorithms(controller) {
  		        controller._writeAlgorithm = undefined;
  		        controller._closeAlgorithm = undefined;
  		        controller._abortAlgorithm = undefined;
  		        controller._strategySizeAlgorithm = undefined;
  		    }
  		    function WritableStreamDefaultControllerClose(controller) {
  		        EnqueueValueWithSize(controller, closeSentinel, 0);
  		        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  		    }
  		    function WritableStreamDefaultControllerGetChunkSize(controller, chunk) {
  		        try {
  		            return controller._strategySizeAlgorithm(chunk);
  		        }
  		        catch (chunkSizeE) {
  		            WritableStreamDefaultControllerErrorIfNeeded(controller, chunkSizeE);
  		            return 1;
  		        }
  		    }
  		    function WritableStreamDefaultControllerGetDesiredSize(controller) {
  		        return controller._strategyHWM - controller._queueTotalSize;
  		    }
  		    function WritableStreamDefaultControllerWrite(controller, chunk, chunkSize) {
  		        try {
  		            EnqueueValueWithSize(controller, chunk, chunkSize);
  		        }
  		        catch (enqueueE) {
  		            WritableStreamDefaultControllerErrorIfNeeded(controller, enqueueE);
  		            return;
  		        }
  		        const stream = controller._controlledWritableStream;
  		        if (!WritableStreamCloseQueuedOrInFlight(stream) && stream._state === 'writable') {
  		            const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  		            WritableStreamUpdateBackpressure(stream, backpressure);
  		        }
  		        WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  		    }
  		    // Abstract operations for the WritableStreamDefaultController.
  		    function WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller) {
  		        const stream = controller._controlledWritableStream;
  		        if (!controller._started) {
  		            return;
  		        }
  		        if (stream._inFlightWriteRequest !== undefined) {
  		            return;
  		        }
  		        const state = stream._state;
  		        if (state === 'erroring') {
  		            WritableStreamFinishErroring(stream);
  		            return;
  		        }
  		        if (controller._queue.length === 0) {
  		            return;
  		        }
  		        const value = PeekQueueValue(controller);
  		        if (value === closeSentinel) {
  		            WritableStreamDefaultControllerProcessClose(controller);
  		        }
  		        else {
  		            WritableStreamDefaultControllerProcessWrite(controller, value);
  		        }
  		    }
  		    function WritableStreamDefaultControllerErrorIfNeeded(controller, error) {
  		        if (controller._controlledWritableStream._state === 'writable') {
  		            WritableStreamDefaultControllerError(controller, error);
  		        }
  		    }
  		    function WritableStreamDefaultControllerProcessClose(controller) {
  		        const stream = controller._controlledWritableStream;
  		        WritableStreamMarkCloseRequestInFlight(stream);
  		        DequeueValue(controller);
  		        const sinkClosePromise = controller._closeAlgorithm();
  		        WritableStreamDefaultControllerClearAlgorithms(controller);
  		        uponPromise(sinkClosePromise, () => {
  		            WritableStreamFinishInFlightClose(stream);
  		        }, reason => {
  		            WritableStreamFinishInFlightCloseWithError(stream, reason);
  		        });
  		    }
  		    function WritableStreamDefaultControllerProcessWrite(controller, chunk) {
  		        const stream = controller._controlledWritableStream;
  		        WritableStreamMarkFirstWriteRequestInFlight(stream);
  		        const sinkWritePromise = controller._writeAlgorithm(chunk);
  		        uponPromise(sinkWritePromise, () => {
  		            WritableStreamFinishInFlightWrite(stream);
  		            const state = stream._state;
  		            DequeueValue(controller);
  		            if (!WritableStreamCloseQueuedOrInFlight(stream) && state === 'writable') {
  		                const backpressure = WritableStreamDefaultControllerGetBackpressure(controller);
  		                WritableStreamUpdateBackpressure(stream, backpressure);
  		            }
  		            WritableStreamDefaultControllerAdvanceQueueIfNeeded(controller);
  		        }, reason => {
  		            if (stream._state === 'writable') {
  		                WritableStreamDefaultControllerClearAlgorithms(controller);
  		            }
  		            WritableStreamFinishInFlightWriteWithError(stream, reason);
  		        });
  		    }
  		    function WritableStreamDefaultControllerGetBackpressure(controller) {
  		        const desiredSize = WritableStreamDefaultControllerGetDesiredSize(controller);
  		        return desiredSize <= 0;
  		    }
  		    // A client of WritableStreamDefaultController may use these functions directly to bypass state check.
  		    function WritableStreamDefaultControllerError(controller, error) {
  		        const stream = controller._controlledWritableStream;
  		        WritableStreamDefaultControllerClearAlgorithms(controller);
  		        WritableStreamStartErroring(stream, error);
  		    }
  		    // Helper functions for the WritableStream.
  		    function streamBrandCheckException$2(name) {
  		        return new TypeError(`WritableStream.prototype.${name} can only be used on a WritableStream`);
  		    }
  		    // Helper functions for the WritableStreamDefaultController.
  		    function defaultControllerBrandCheckException$2(name) {
  		        return new TypeError(`WritableStreamDefaultController.prototype.${name} can only be used on a WritableStreamDefaultController`);
  		    }
  		    // Helper functions for the WritableStreamDefaultWriter.
  		    function defaultWriterBrandCheckException(name) {
  		        return new TypeError(`WritableStreamDefaultWriter.prototype.${name} can only be used on a WritableStreamDefaultWriter`);
  		    }
  		    function defaultWriterLockException(name) {
  		        return new TypeError('Cannot ' + name + ' a stream using a released writer');
  		    }
  		    function defaultWriterClosedPromiseInitialize(writer) {
  		        writer._closedPromise = newPromise((resolve, reject) => {
  		            writer._closedPromise_resolve = resolve;
  		            writer._closedPromise_reject = reject;
  		            writer._closedPromiseState = 'pending';
  		        });
  		    }
  		    function defaultWriterClosedPromiseInitializeAsRejected(writer, reason) {
  		        defaultWriterClosedPromiseInitialize(writer);
  		        defaultWriterClosedPromiseReject(writer, reason);
  		    }
  		    function defaultWriterClosedPromiseInitializeAsResolved(writer) {
  		        defaultWriterClosedPromiseInitialize(writer);
  		        defaultWriterClosedPromiseResolve(writer);
  		    }
  		    function defaultWriterClosedPromiseReject(writer, reason) {
  		        if (writer._closedPromise_reject === undefined) {
  		            return;
  		        }
  		        setPromiseIsHandledToTrue(writer._closedPromise);
  		        writer._closedPromise_reject(reason);
  		        writer._closedPromise_resolve = undefined;
  		        writer._closedPromise_reject = undefined;
  		        writer._closedPromiseState = 'rejected';
  		    }
  		    function defaultWriterClosedPromiseResetToRejected(writer, reason) {
  		        defaultWriterClosedPromiseInitializeAsRejected(writer, reason);
  		    }
  		    function defaultWriterClosedPromiseResolve(writer) {
  		        if (writer._closedPromise_resolve === undefined) {
  		            return;
  		        }
  		        writer._closedPromise_resolve(undefined);
  		        writer._closedPromise_resolve = undefined;
  		        writer._closedPromise_reject = undefined;
  		        writer._closedPromiseState = 'resolved';
  		    }
  		    function defaultWriterReadyPromiseInitialize(writer) {
  		        writer._readyPromise = newPromise((resolve, reject) => {
  		            writer._readyPromise_resolve = resolve;
  		            writer._readyPromise_reject = reject;
  		        });
  		        writer._readyPromiseState = 'pending';
  		    }
  		    function defaultWriterReadyPromiseInitializeAsRejected(writer, reason) {
  		        defaultWriterReadyPromiseInitialize(writer);
  		        defaultWriterReadyPromiseReject(writer, reason);
  		    }
  		    function defaultWriterReadyPromiseInitializeAsResolved(writer) {
  		        defaultWriterReadyPromiseInitialize(writer);
  		        defaultWriterReadyPromiseResolve(writer);
  		    }
  		    function defaultWriterReadyPromiseReject(writer, reason) {
  		        if (writer._readyPromise_reject === undefined) {
  		            return;
  		        }
  		        setPromiseIsHandledToTrue(writer._readyPromise);
  		        writer._readyPromise_reject(reason);
  		        writer._readyPromise_resolve = undefined;
  		        writer._readyPromise_reject = undefined;
  		        writer._readyPromiseState = 'rejected';
  		    }
  		    function defaultWriterReadyPromiseReset(writer) {
  		        defaultWriterReadyPromiseInitialize(writer);
  		    }
  		    function defaultWriterReadyPromiseResetToRejected(writer, reason) {
  		        defaultWriterReadyPromiseInitializeAsRejected(writer, reason);
  		    }
  		    function defaultWriterReadyPromiseResolve(writer) {
  		        if (writer._readyPromise_resolve === undefined) {
  		            return;
  		        }
  		        writer._readyPromise_resolve(undefined);
  		        writer._readyPromise_resolve = undefined;
  		        writer._readyPromise_reject = undefined;
  		        writer._readyPromiseState = 'fulfilled';
  		    }

  		    /// <reference lib="dom" />
  		    const NativeDOMException = typeof DOMException !== 'undefined' ? DOMException : undefined;

  		    /// <reference types="node" />
  		    function isDOMExceptionConstructor(ctor) {
  		        if (!(typeof ctor === 'function' || typeof ctor === 'object')) {
  		            return false;
  		        }
  		        try {
  		            new ctor();
  		            return true;
  		        }
  		        catch (_a) {
  		            return false;
  		        }
  		    }
  		    function createDOMExceptionPolyfill() {
  		        // eslint-disable-next-line no-shadow
  		        const ctor = function DOMException(message, name) {
  		            this.message = message || '';
  		            this.name = name || 'Error';
  		            if (Error.captureStackTrace) {
  		                Error.captureStackTrace(this, this.constructor);
  		            }
  		        };
  		        ctor.prototype = Object.create(Error.prototype);
  		        Object.defineProperty(ctor.prototype, 'constructor', { value: ctor, writable: true, configurable: true });
  		        return ctor;
  		    }
  		    // eslint-disable-next-line no-redeclare
  		    const DOMException$1 = isDOMExceptionConstructor(NativeDOMException) ? NativeDOMException : createDOMExceptionPolyfill();

  		    function ReadableStreamPipeTo(source, dest, preventClose, preventAbort, preventCancel, signal) {
  		        const reader = AcquireReadableStreamDefaultReader(source);
  		        const writer = AcquireWritableStreamDefaultWriter(dest);
  		        source._disturbed = true;
  		        let shuttingDown = false;
  		        // This is used to keep track of the spec's requirement that we wait for ongoing writes during shutdown.
  		        let currentWrite = promiseResolvedWith(undefined);
  		        return newPromise((resolve, reject) => {
  		            let abortAlgorithm;
  		            if (signal !== undefined) {
  		                abortAlgorithm = () => {
  		                    const error = new DOMException$1('Aborted', 'AbortError');
  		                    const actions = [];
  		                    if (!preventAbort) {
  		                        actions.push(() => {
  		                            if (dest._state === 'writable') {
  		                                return WritableStreamAbort(dest, error);
  		                            }
  		                            return promiseResolvedWith(undefined);
  		                        });
  		                    }
  		                    if (!preventCancel) {
  		                        actions.push(() => {
  		                            if (source._state === 'readable') {
  		                                return ReadableStreamCancel(source, error);
  		                            }
  		                            return promiseResolvedWith(undefined);
  		                        });
  		                    }
  		                    shutdownWithAction(() => Promise.all(actions.map(action => action())), true, error);
  		                };
  		                if (signal.aborted) {
  		                    abortAlgorithm();
  		                    return;
  		                }
  		                signal.addEventListener('abort', abortAlgorithm);
  		            }
  		            // Using reader and writer, read all chunks from this and write them to dest
  		            // - Backpressure must be enforced
  		            // - Shutdown must stop all activity
  		            function pipeLoop() {
  		                return newPromise((resolveLoop, rejectLoop) => {
  		                    function next(done) {
  		                        if (done) {
  		                            resolveLoop();
  		                        }
  		                        else {
  		                            // Use `PerformPromiseThen` instead of `uponPromise` to avoid
  		                            // adding unnecessary `.catch(rethrowAssertionErrorRejection)` handlers
  		                            PerformPromiseThen(pipeStep(), next, rejectLoop);
  		                        }
  		                    }
  		                    next(false);
  		                });
  		            }
  		            function pipeStep() {
  		                if (shuttingDown) {
  		                    return promiseResolvedWith(true);
  		                }
  		                return PerformPromiseThen(writer._readyPromise, () => {
  		                    return newPromise((resolveRead, rejectRead) => {
  		                        ReadableStreamDefaultReaderRead(reader, {
  		                            _chunkSteps: chunk => {
  		                                currentWrite = PerformPromiseThen(WritableStreamDefaultWriterWrite(writer, chunk), undefined, noop);
  		                                resolveRead(false);
  		                            },
  		                            _closeSteps: () => resolveRead(true),
  		                            _errorSteps: rejectRead
  		                        });
  		                    });
  		                });
  		            }
  		            // Errors must be propagated forward
  		            isOrBecomesErrored(source, reader._closedPromise, storedError => {
  		                if (!preventAbort) {
  		                    shutdownWithAction(() => WritableStreamAbort(dest, storedError), true, storedError);
  		                }
  		                else {
  		                    shutdown(true, storedError);
  		                }
  		            });
  		            // Errors must be propagated backward
  		            isOrBecomesErrored(dest, writer._closedPromise, storedError => {
  		                if (!preventCancel) {
  		                    shutdownWithAction(() => ReadableStreamCancel(source, storedError), true, storedError);
  		                }
  		                else {
  		                    shutdown(true, storedError);
  		                }
  		            });
  		            // Closing must be propagated forward
  		            isOrBecomesClosed(source, reader._closedPromise, () => {
  		                if (!preventClose) {
  		                    shutdownWithAction(() => WritableStreamDefaultWriterCloseWithErrorPropagation(writer));
  		                }
  		                else {
  		                    shutdown();
  		                }
  		            });
  		            // Closing must be propagated backward
  		            if (WritableStreamCloseQueuedOrInFlight(dest) || dest._state === 'closed') {
  		                const destClosed = new TypeError('the destination writable stream closed before all data could be piped to it');
  		                if (!preventCancel) {
  		                    shutdownWithAction(() => ReadableStreamCancel(source, destClosed), true, destClosed);
  		                }
  		                else {
  		                    shutdown(true, destClosed);
  		                }
  		            }
  		            setPromiseIsHandledToTrue(pipeLoop());
  		            function waitForWritesToFinish() {
  		                // Another write may have started while we were waiting on this currentWrite, so we have to be sure to wait
  		                // for that too.
  		                const oldCurrentWrite = currentWrite;
  		                return PerformPromiseThen(currentWrite, () => oldCurrentWrite !== currentWrite ? waitForWritesToFinish() : undefined);
  		            }
  		            function isOrBecomesErrored(stream, promise, action) {
  		                if (stream._state === 'errored') {
  		                    action(stream._storedError);
  		                }
  		                else {
  		                    uponRejection(promise, action);
  		                }
  		            }
  		            function isOrBecomesClosed(stream, promise, action) {
  		                if (stream._state === 'closed') {
  		                    action();
  		                }
  		                else {
  		                    uponFulfillment(promise, action);
  		                }
  		            }
  		            function shutdownWithAction(action, originalIsError, originalError) {
  		                if (shuttingDown) {
  		                    return;
  		                }
  		                shuttingDown = true;
  		                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
  		                    uponFulfillment(waitForWritesToFinish(), doTheRest);
  		                }
  		                else {
  		                    doTheRest();
  		                }
  		                function doTheRest() {
  		                    uponPromise(action(), () => finalize(originalIsError, originalError), newError => finalize(true, newError));
  		                }
  		            }
  		            function shutdown(isError, error) {
  		                if (shuttingDown) {
  		                    return;
  		                }
  		                shuttingDown = true;
  		                if (dest._state === 'writable' && !WritableStreamCloseQueuedOrInFlight(dest)) {
  		                    uponFulfillment(waitForWritesToFinish(), () => finalize(isError, error));
  		                }
  		                else {
  		                    finalize(isError, error);
  		                }
  		            }
  		            function finalize(isError, error) {
  		                WritableStreamDefaultWriterRelease(writer);
  		                ReadableStreamReaderGenericRelease(reader);
  		                if (signal !== undefined) {
  		                    signal.removeEventListener('abort', abortAlgorithm);
  		                }
  		                if (isError) {
  		                    reject(error);
  		                }
  		                else {
  		                    resolve(undefined);
  		                }
  		            }
  		        });
  		    }

  		    /**
  		     * Allows control of a {@link ReadableStream | readable stream}'s state and internal queue.
  		     *
  		     * @public
  		     */
  		    class ReadableStreamDefaultController {
  		        constructor() {
  		            throw new TypeError('Illegal constructor');
  		        }
  		        /**
  		         * Returns the desired size to fill the controlled stream's internal queue. It can be negative, if the queue is
  		         * over-full. An underlying source ought to use this information to determine when and how to apply backpressure.
  		         */
  		        get desiredSize() {
  		            if (!IsReadableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$1('desiredSize');
  		            }
  		            return ReadableStreamDefaultControllerGetDesiredSize(this);
  		        }
  		        /**
  		         * Closes the controlled readable stream. Consumers will still be able to read any previously-enqueued chunks from
  		         * the stream, but once those are read, the stream will become closed.
  		         */
  		        close() {
  		            if (!IsReadableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$1('close');
  		            }
  		            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
  		                throw new TypeError('The stream is not in a state that permits close');
  		            }
  		            ReadableStreamDefaultControllerClose(this);
  		        }
  		        enqueue(chunk = undefined) {
  		            if (!IsReadableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$1('enqueue');
  		            }
  		            if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(this)) {
  		                throw new TypeError('The stream is not in a state that permits enqueue');
  		            }
  		            return ReadableStreamDefaultControllerEnqueue(this, chunk);
  		        }
  		        /**
  		         * Errors the controlled readable stream, making all future interactions with it fail with the given error `e`.
  		         */
  		        error(e = undefined) {
  		            if (!IsReadableStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException$1('error');
  		            }
  		            ReadableStreamDefaultControllerError(this, e);
  		        }
  		        /** @internal */
  		        [CancelSteps](reason) {
  		            ResetQueue(this);
  		            const result = this._cancelAlgorithm(reason);
  		            ReadableStreamDefaultControllerClearAlgorithms(this);
  		            return result;
  		        }
  		        /** @internal */
  		        [PullSteps](readRequest) {
  		            const stream = this._controlledReadableStream;
  		            if (this._queue.length > 0) {
  		                const chunk = DequeueValue(this);
  		                if (this._closeRequested && this._queue.length === 0) {
  		                    ReadableStreamDefaultControllerClearAlgorithms(this);
  		                    ReadableStreamClose(stream);
  		                }
  		                else {
  		                    ReadableStreamDefaultControllerCallPullIfNeeded(this);
  		                }
  		                readRequest._chunkSteps(chunk);
  		            }
  		            else {
  		                ReadableStreamAddReadRequest(stream, readRequest);
  		                ReadableStreamDefaultControllerCallPullIfNeeded(this);
  		            }
  		        }
  		    }
  		    Object.defineProperties(ReadableStreamDefaultController.prototype, {
  		        close: { enumerable: true },
  		        enqueue: { enumerable: true },
  		        error: { enumerable: true },
  		        desiredSize: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ReadableStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ReadableStreamDefaultController',
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the ReadableStreamDefaultController.
  		    function IsReadableStreamDefaultController(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_controlledReadableStream')) {
  		            return false;
  		        }
  		        return x instanceof ReadableStreamDefaultController;
  		    }
  		    function ReadableStreamDefaultControllerCallPullIfNeeded(controller) {
  		        const shouldPull = ReadableStreamDefaultControllerShouldCallPull(controller);
  		        if (!shouldPull) {
  		            return;
  		        }
  		        if (controller._pulling) {
  		            controller._pullAgain = true;
  		            return;
  		        }
  		        controller._pulling = true;
  		        const pullPromise = controller._pullAlgorithm();
  		        uponPromise(pullPromise, () => {
  		            controller._pulling = false;
  		            if (controller._pullAgain) {
  		                controller._pullAgain = false;
  		                ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  		            }
  		        }, e => {
  		            ReadableStreamDefaultControllerError(controller, e);
  		        });
  		    }
  		    function ReadableStreamDefaultControllerShouldCallPull(controller) {
  		        const stream = controller._controlledReadableStream;
  		        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
  		            return false;
  		        }
  		        if (!controller._started) {
  		            return false;
  		        }
  		        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
  		            return true;
  		        }
  		        const desiredSize = ReadableStreamDefaultControllerGetDesiredSize(controller);
  		        if (desiredSize > 0) {
  		            return true;
  		        }
  		        return false;
  		    }
  		    function ReadableStreamDefaultControllerClearAlgorithms(controller) {
  		        controller._pullAlgorithm = undefined;
  		        controller._cancelAlgorithm = undefined;
  		        controller._strategySizeAlgorithm = undefined;
  		    }
  		    // A client of ReadableStreamDefaultController may use these functions directly to bypass state check.
  		    function ReadableStreamDefaultControllerClose(controller) {
  		        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
  		            return;
  		        }
  		        const stream = controller._controlledReadableStream;
  		        controller._closeRequested = true;
  		        if (controller._queue.length === 0) {
  		            ReadableStreamDefaultControllerClearAlgorithms(controller);
  		            ReadableStreamClose(stream);
  		        }
  		    }
  		    function ReadableStreamDefaultControllerEnqueue(controller, chunk) {
  		        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(controller)) {
  		            return;
  		        }
  		        const stream = controller._controlledReadableStream;
  		        if (IsReadableStreamLocked(stream) && ReadableStreamGetNumReadRequests(stream) > 0) {
  		            ReadableStreamFulfillReadRequest(stream, chunk, false);
  		        }
  		        else {
  		            let chunkSize;
  		            try {
  		                chunkSize = controller._strategySizeAlgorithm(chunk);
  		            }
  		            catch (chunkSizeE) {
  		                ReadableStreamDefaultControllerError(controller, chunkSizeE);
  		                throw chunkSizeE;
  		            }
  		            try {
  		                EnqueueValueWithSize(controller, chunk, chunkSize);
  		            }
  		            catch (enqueueE) {
  		                ReadableStreamDefaultControllerError(controller, enqueueE);
  		                throw enqueueE;
  		            }
  		        }
  		        ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  		    }
  		    function ReadableStreamDefaultControllerError(controller, e) {
  		        const stream = controller._controlledReadableStream;
  		        if (stream._state !== 'readable') {
  		            return;
  		        }
  		        ResetQueue(controller);
  		        ReadableStreamDefaultControllerClearAlgorithms(controller);
  		        ReadableStreamError(stream, e);
  		    }
  		    function ReadableStreamDefaultControllerGetDesiredSize(controller) {
  		        const state = controller._controlledReadableStream._state;
  		        if (state === 'errored') {
  		            return null;
  		        }
  		        if (state === 'closed') {
  		            return 0;
  		        }
  		        return controller._strategyHWM - controller._queueTotalSize;
  		    }
  		    // This is used in the implementation of TransformStream.
  		    function ReadableStreamDefaultControllerHasBackpressure(controller) {
  		        if (ReadableStreamDefaultControllerShouldCallPull(controller)) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    function ReadableStreamDefaultControllerCanCloseOrEnqueue(controller) {
  		        const state = controller._controlledReadableStream._state;
  		        if (!controller._closeRequested && state === 'readable') {
  		            return true;
  		        }
  		        return false;
  		    }
  		    function SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm) {
  		        controller._controlledReadableStream = stream;
  		        controller._queue = undefined;
  		        controller._queueTotalSize = undefined;
  		        ResetQueue(controller);
  		        controller._started = false;
  		        controller._closeRequested = false;
  		        controller._pullAgain = false;
  		        controller._pulling = false;
  		        controller._strategySizeAlgorithm = sizeAlgorithm;
  		        controller._strategyHWM = highWaterMark;
  		        controller._pullAlgorithm = pullAlgorithm;
  		        controller._cancelAlgorithm = cancelAlgorithm;
  		        stream._readableStreamController = controller;
  		        const startResult = startAlgorithm();
  		        uponPromise(promiseResolvedWith(startResult), () => {
  		            controller._started = true;
  		            ReadableStreamDefaultControllerCallPullIfNeeded(controller);
  		        }, r => {
  		            ReadableStreamDefaultControllerError(controller, r);
  		        });
  		    }
  		    function SetUpReadableStreamDefaultControllerFromUnderlyingSource(stream, underlyingSource, highWaterMark, sizeAlgorithm) {
  		        const controller = Object.create(ReadableStreamDefaultController.prototype);
  		        let startAlgorithm = () => undefined;
  		        let pullAlgorithm = () => promiseResolvedWith(undefined);
  		        let cancelAlgorithm = () => promiseResolvedWith(undefined);
  		        if (underlyingSource.start !== undefined) {
  		            startAlgorithm = () => underlyingSource.start(controller);
  		        }
  		        if (underlyingSource.pull !== undefined) {
  		            pullAlgorithm = () => underlyingSource.pull(controller);
  		        }
  		        if (underlyingSource.cancel !== undefined) {
  		            cancelAlgorithm = reason => underlyingSource.cancel(reason);
  		        }
  		        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  		    }
  		    // Helper functions for the ReadableStreamDefaultController.
  		    function defaultControllerBrandCheckException$1(name) {
  		        return new TypeError(`ReadableStreamDefaultController.prototype.${name} can only be used on a ReadableStreamDefaultController`);
  		    }

  		    function ReadableStreamTee(stream, cloneForBranch2) {
  		        if (IsReadableByteStreamController(stream._readableStreamController)) {
  		            return ReadableByteStreamTee(stream);
  		        }
  		        return ReadableStreamDefaultTee(stream);
  		    }
  		    function ReadableStreamDefaultTee(stream, cloneForBranch2) {
  		        const reader = AcquireReadableStreamDefaultReader(stream);
  		        let reading = false;
  		        let readAgain = false;
  		        let canceled1 = false;
  		        let canceled2 = false;
  		        let reason1;
  		        let reason2;
  		        let branch1;
  		        let branch2;
  		        let resolveCancelPromise;
  		        const cancelPromise = newPromise(resolve => {
  		            resolveCancelPromise = resolve;
  		        });
  		        function pullAlgorithm() {
  		            if (reading) {
  		                readAgain = true;
  		                return promiseResolvedWith(undefined);
  		            }
  		            reading = true;
  		            const readRequest = {
  		                _chunkSteps: chunk => {
  		                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
  		                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
  		                    // successful synchronously-available reads get ahead of asynchronously-available errors.
  		                    queueMicrotask(() => {
  		                        readAgain = false;
  		                        const chunk1 = chunk;
  		                        const chunk2 = chunk;
  		                        // There is no way to access the cloning code right now in the reference implementation.
  		                        // If we add one then we'll need an implementation for serializable objects.
  		                        // if (!canceled2 && cloneForBranch2) {
  		                        //   chunk2 = StructuredDeserialize(StructuredSerialize(chunk2));
  		                        // }
  		                        if (!canceled1) {
  		                            ReadableStreamDefaultControllerEnqueue(branch1._readableStreamController, chunk1);
  		                        }
  		                        if (!canceled2) {
  		                            ReadableStreamDefaultControllerEnqueue(branch2._readableStreamController, chunk2);
  		                        }
  		                        reading = false;
  		                        if (readAgain) {
  		                            pullAlgorithm();
  		                        }
  		                    });
  		                },
  		                _closeSteps: () => {
  		                    reading = false;
  		                    if (!canceled1) {
  		                        ReadableStreamDefaultControllerClose(branch1._readableStreamController);
  		                    }
  		                    if (!canceled2) {
  		                        ReadableStreamDefaultControllerClose(branch2._readableStreamController);
  		                    }
  		                    if (!canceled1 || !canceled2) {
  		                        resolveCancelPromise(undefined);
  		                    }
  		                },
  		                _errorSteps: () => {
  		                    reading = false;
  		                }
  		            };
  		            ReadableStreamDefaultReaderRead(reader, readRequest);
  		            return promiseResolvedWith(undefined);
  		        }
  		        function cancel1Algorithm(reason) {
  		            canceled1 = true;
  		            reason1 = reason;
  		            if (canceled2) {
  		                const compositeReason = CreateArrayFromList([reason1, reason2]);
  		                const cancelResult = ReadableStreamCancel(stream, compositeReason);
  		                resolveCancelPromise(cancelResult);
  		            }
  		            return cancelPromise;
  		        }
  		        function cancel2Algorithm(reason) {
  		            canceled2 = true;
  		            reason2 = reason;
  		            if (canceled1) {
  		                const compositeReason = CreateArrayFromList([reason1, reason2]);
  		                const cancelResult = ReadableStreamCancel(stream, compositeReason);
  		                resolveCancelPromise(cancelResult);
  		            }
  		            return cancelPromise;
  		        }
  		        function startAlgorithm() {
  		            // do nothing
  		        }
  		        branch1 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel1Algorithm);
  		        branch2 = CreateReadableStream(startAlgorithm, pullAlgorithm, cancel2Algorithm);
  		        uponRejection(reader._closedPromise, (r) => {
  		            ReadableStreamDefaultControllerError(branch1._readableStreamController, r);
  		            ReadableStreamDefaultControllerError(branch2._readableStreamController, r);
  		            if (!canceled1 || !canceled2) {
  		                resolveCancelPromise(undefined);
  		            }
  		        });
  		        return [branch1, branch2];
  		    }
  		    function ReadableByteStreamTee(stream) {
  		        let reader = AcquireReadableStreamDefaultReader(stream);
  		        let reading = false;
  		        let readAgainForBranch1 = false;
  		        let readAgainForBranch2 = false;
  		        let canceled1 = false;
  		        let canceled2 = false;
  		        let reason1;
  		        let reason2;
  		        let branch1;
  		        let branch2;
  		        let resolveCancelPromise;
  		        const cancelPromise = newPromise(resolve => {
  		            resolveCancelPromise = resolve;
  		        });
  		        function forwardReaderError(thisReader) {
  		            uponRejection(thisReader._closedPromise, r => {
  		                if (thisReader !== reader) {
  		                    return;
  		                }
  		                ReadableByteStreamControllerError(branch1._readableStreamController, r);
  		                ReadableByteStreamControllerError(branch2._readableStreamController, r);
  		                if (!canceled1 || !canceled2) {
  		                    resolveCancelPromise(undefined);
  		                }
  		            });
  		        }
  		        function pullWithDefaultReader() {
  		            if (IsReadableStreamBYOBReader(reader)) {
  		                ReadableStreamReaderGenericRelease(reader);
  		                reader = AcquireReadableStreamDefaultReader(stream);
  		                forwardReaderError(reader);
  		            }
  		            const readRequest = {
  		                _chunkSteps: chunk => {
  		                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
  		                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
  		                    // successful synchronously-available reads get ahead of asynchronously-available errors.
  		                    queueMicrotask(() => {
  		                        readAgainForBranch1 = false;
  		                        readAgainForBranch2 = false;
  		                        const chunk1 = chunk;
  		                        let chunk2 = chunk;
  		                        if (!canceled1 && !canceled2) {
  		                            try {
  		                                chunk2 = CloneAsUint8Array(chunk);
  		                            }
  		                            catch (cloneE) {
  		                                ReadableByteStreamControllerError(branch1._readableStreamController, cloneE);
  		                                ReadableByteStreamControllerError(branch2._readableStreamController, cloneE);
  		                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
  		                                return;
  		                            }
  		                        }
  		                        if (!canceled1) {
  		                            ReadableByteStreamControllerEnqueue(branch1._readableStreamController, chunk1);
  		                        }
  		                        if (!canceled2) {
  		                            ReadableByteStreamControllerEnqueue(branch2._readableStreamController, chunk2);
  		                        }
  		                        reading = false;
  		                        if (readAgainForBranch1) {
  		                            pull1Algorithm();
  		                        }
  		                        else if (readAgainForBranch2) {
  		                            pull2Algorithm();
  		                        }
  		                    });
  		                },
  		                _closeSteps: () => {
  		                    reading = false;
  		                    if (!canceled1) {
  		                        ReadableByteStreamControllerClose(branch1._readableStreamController);
  		                    }
  		                    if (!canceled2) {
  		                        ReadableByteStreamControllerClose(branch2._readableStreamController);
  		                    }
  		                    if (branch1._readableStreamController._pendingPullIntos.length > 0) {
  		                        ReadableByteStreamControllerRespond(branch1._readableStreamController, 0);
  		                    }
  		                    if (branch2._readableStreamController._pendingPullIntos.length > 0) {
  		                        ReadableByteStreamControllerRespond(branch2._readableStreamController, 0);
  		                    }
  		                    if (!canceled1 || !canceled2) {
  		                        resolveCancelPromise(undefined);
  		                    }
  		                },
  		                _errorSteps: () => {
  		                    reading = false;
  		                }
  		            };
  		            ReadableStreamDefaultReaderRead(reader, readRequest);
  		        }
  		        function pullWithBYOBReader(view, forBranch2) {
  		            if (IsReadableStreamDefaultReader(reader)) {
  		                ReadableStreamReaderGenericRelease(reader);
  		                reader = AcquireReadableStreamBYOBReader(stream);
  		                forwardReaderError(reader);
  		            }
  		            const byobBranch = forBranch2 ? branch2 : branch1;
  		            const otherBranch = forBranch2 ? branch1 : branch2;
  		            const readIntoRequest = {
  		                _chunkSteps: chunk => {
  		                    // This needs to be delayed a microtask because it takes at least a microtask to detect errors (using
  		                    // reader._closedPromise below), and we want errors in stream to error both branches immediately. We cannot let
  		                    // successful synchronously-available reads get ahead of asynchronously-available errors.
  		                    queueMicrotask(() => {
  		                        readAgainForBranch1 = false;
  		                        readAgainForBranch2 = false;
  		                        const byobCanceled = forBranch2 ? canceled2 : canceled1;
  		                        const otherCanceled = forBranch2 ? canceled1 : canceled2;
  		                        if (!otherCanceled) {
  		                            let clonedChunk;
  		                            try {
  		                                clonedChunk = CloneAsUint8Array(chunk);
  		                            }
  		                            catch (cloneE) {
  		                                ReadableByteStreamControllerError(byobBranch._readableStreamController, cloneE);
  		                                ReadableByteStreamControllerError(otherBranch._readableStreamController, cloneE);
  		                                resolveCancelPromise(ReadableStreamCancel(stream, cloneE));
  		                                return;
  		                            }
  		                            if (!byobCanceled) {
  		                                ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
  		                            }
  		                            ReadableByteStreamControllerEnqueue(otherBranch._readableStreamController, clonedChunk);
  		                        }
  		                        else if (!byobCanceled) {
  		                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
  		                        }
  		                        reading = false;
  		                        if (readAgainForBranch1) {
  		                            pull1Algorithm();
  		                        }
  		                        else if (readAgainForBranch2) {
  		                            pull2Algorithm();
  		                        }
  		                    });
  		                },
  		                _closeSteps: chunk => {
  		                    reading = false;
  		                    const byobCanceled = forBranch2 ? canceled2 : canceled1;
  		                    const otherCanceled = forBranch2 ? canceled1 : canceled2;
  		                    if (!byobCanceled) {
  		                        ReadableByteStreamControllerClose(byobBranch._readableStreamController);
  		                    }
  		                    if (!otherCanceled) {
  		                        ReadableByteStreamControllerClose(otherBranch._readableStreamController);
  		                    }
  		                    if (chunk !== undefined) {
  		                        if (!byobCanceled) {
  		                            ReadableByteStreamControllerRespondWithNewView(byobBranch._readableStreamController, chunk);
  		                        }
  		                        if (!otherCanceled && otherBranch._readableStreamController._pendingPullIntos.length > 0) {
  		                            ReadableByteStreamControllerRespond(otherBranch._readableStreamController, 0);
  		                        }
  		                    }
  		                    if (!byobCanceled || !otherCanceled) {
  		                        resolveCancelPromise(undefined);
  		                    }
  		                },
  		                _errorSteps: () => {
  		                    reading = false;
  		                }
  		            };
  		            ReadableStreamBYOBReaderRead(reader, view, readIntoRequest);
  		        }
  		        function pull1Algorithm() {
  		            if (reading) {
  		                readAgainForBranch1 = true;
  		                return promiseResolvedWith(undefined);
  		            }
  		            reading = true;
  		            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch1._readableStreamController);
  		            if (byobRequest === null) {
  		                pullWithDefaultReader();
  		            }
  		            else {
  		                pullWithBYOBReader(byobRequest._view, false);
  		            }
  		            return promiseResolvedWith(undefined);
  		        }
  		        function pull2Algorithm() {
  		            if (reading) {
  		                readAgainForBranch2 = true;
  		                return promiseResolvedWith(undefined);
  		            }
  		            reading = true;
  		            const byobRequest = ReadableByteStreamControllerGetBYOBRequest(branch2._readableStreamController);
  		            if (byobRequest === null) {
  		                pullWithDefaultReader();
  		            }
  		            else {
  		                pullWithBYOBReader(byobRequest._view, true);
  		            }
  		            return promiseResolvedWith(undefined);
  		        }
  		        function cancel1Algorithm(reason) {
  		            canceled1 = true;
  		            reason1 = reason;
  		            if (canceled2) {
  		                const compositeReason = CreateArrayFromList([reason1, reason2]);
  		                const cancelResult = ReadableStreamCancel(stream, compositeReason);
  		                resolveCancelPromise(cancelResult);
  		            }
  		            return cancelPromise;
  		        }
  		        function cancel2Algorithm(reason) {
  		            canceled2 = true;
  		            reason2 = reason;
  		            if (canceled1) {
  		                const compositeReason = CreateArrayFromList([reason1, reason2]);
  		                const cancelResult = ReadableStreamCancel(stream, compositeReason);
  		                resolveCancelPromise(cancelResult);
  		            }
  		            return cancelPromise;
  		        }
  		        function startAlgorithm() {
  		            return;
  		        }
  		        branch1 = CreateReadableByteStream(startAlgorithm, pull1Algorithm, cancel1Algorithm);
  		        branch2 = CreateReadableByteStream(startAlgorithm, pull2Algorithm, cancel2Algorithm);
  		        forwardReaderError(reader);
  		        return [branch1, branch2];
  		    }

  		    function convertUnderlyingDefaultOrByteSource(source, context) {
  		        assertDictionary(source, context);
  		        const original = source;
  		        const autoAllocateChunkSize = original === null || original === void 0 ? void 0 : original.autoAllocateChunkSize;
  		        const cancel = original === null || original === void 0 ? void 0 : original.cancel;
  		        const pull = original === null || original === void 0 ? void 0 : original.pull;
  		        const start = original === null || original === void 0 ? void 0 : original.start;
  		        const type = original === null || original === void 0 ? void 0 : original.type;
  		        return {
  		            autoAllocateChunkSize: autoAllocateChunkSize === undefined ?
  		                undefined :
  		                convertUnsignedLongLongWithEnforceRange(autoAllocateChunkSize, `${context} has member 'autoAllocateChunkSize' that`),
  		            cancel: cancel === undefined ?
  		                undefined :
  		                convertUnderlyingSourceCancelCallback(cancel, original, `${context} has member 'cancel' that`),
  		            pull: pull === undefined ?
  		                undefined :
  		                convertUnderlyingSourcePullCallback(pull, original, `${context} has member 'pull' that`),
  		            start: start === undefined ?
  		                undefined :
  		                convertUnderlyingSourceStartCallback(start, original, `${context} has member 'start' that`),
  		            type: type === undefined ? undefined : convertReadableStreamType(type, `${context} has member 'type' that`)
  		        };
  		    }
  		    function convertUnderlyingSourceCancelCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (reason) => promiseCall(fn, original, [reason]);
  		    }
  		    function convertUnderlyingSourcePullCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (controller) => promiseCall(fn, original, [controller]);
  		    }
  		    function convertUnderlyingSourceStartCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (controller) => reflectCall(fn, original, [controller]);
  		    }
  		    function convertReadableStreamType(type, context) {
  		        type = `${type}`;
  		        if (type !== 'bytes') {
  		            throw new TypeError(`${context} '${type}' is not a valid enumeration value for ReadableStreamType`);
  		        }
  		        return type;
  		    }

  		    function convertReaderOptions(options, context) {
  		        assertDictionary(options, context);
  		        const mode = options === null || options === void 0 ? void 0 : options.mode;
  		        return {
  		            mode: mode === undefined ? undefined : convertReadableStreamReaderMode(mode, `${context} has member 'mode' that`)
  		        };
  		    }
  		    function convertReadableStreamReaderMode(mode, context) {
  		        mode = `${mode}`;
  		        if (mode !== 'byob') {
  		            throw new TypeError(`${context} '${mode}' is not a valid enumeration value for ReadableStreamReaderMode`);
  		        }
  		        return mode;
  		    }

  		    function convertIteratorOptions(options, context) {
  		        assertDictionary(options, context);
  		        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  		        return { preventCancel: Boolean(preventCancel) };
  		    }

  		    function convertPipeOptions(options, context) {
  		        assertDictionary(options, context);
  		        const preventAbort = options === null || options === void 0 ? void 0 : options.preventAbort;
  		        const preventCancel = options === null || options === void 0 ? void 0 : options.preventCancel;
  		        const preventClose = options === null || options === void 0 ? void 0 : options.preventClose;
  		        const signal = options === null || options === void 0 ? void 0 : options.signal;
  		        if (signal !== undefined) {
  		            assertAbortSignal(signal, `${context} has member 'signal' that`);
  		        }
  		        return {
  		            preventAbort: Boolean(preventAbort),
  		            preventCancel: Boolean(preventCancel),
  		            preventClose: Boolean(preventClose),
  		            signal
  		        };
  		    }
  		    function assertAbortSignal(signal, context) {
  		        if (!isAbortSignal(signal)) {
  		            throw new TypeError(`${context} is not an AbortSignal.`);
  		        }
  		    }

  		    function convertReadableWritablePair(pair, context) {
  		        assertDictionary(pair, context);
  		        const readable = pair === null || pair === void 0 ? void 0 : pair.readable;
  		        assertRequiredField(readable, 'readable', 'ReadableWritablePair');
  		        assertReadableStream(readable, `${context} has member 'readable' that`);
  		        const writable = pair === null || pair === void 0 ? void 0 : pair.writable;
  		        assertRequiredField(writable, 'writable', 'ReadableWritablePair');
  		        assertWritableStream(writable, `${context} has member 'writable' that`);
  		        return { readable, writable };
  		    }

  		    /**
  		     * A readable stream represents a source of data, from which you can read.
  		     *
  		     * @public
  		     */
  		    class ReadableStream {
  		        constructor(rawUnderlyingSource = {}, rawStrategy = {}) {
  		            if (rawUnderlyingSource === undefined) {
  		                rawUnderlyingSource = null;
  		            }
  		            else {
  		                assertObject(rawUnderlyingSource, 'First parameter');
  		            }
  		            const strategy = convertQueuingStrategy(rawStrategy, 'Second parameter');
  		            const underlyingSource = convertUnderlyingDefaultOrByteSource(rawUnderlyingSource, 'First parameter');
  		            InitializeReadableStream(this);
  		            if (underlyingSource.type === 'bytes') {
  		                if (strategy.size !== undefined) {
  		                    throw new RangeError('The strategy for a byte stream cannot have a size function');
  		                }
  		                const highWaterMark = ExtractHighWaterMark(strategy, 0);
  		                SetUpReadableByteStreamControllerFromUnderlyingSource(this, underlyingSource, highWaterMark);
  		            }
  		            else {
  		                const sizeAlgorithm = ExtractSizeAlgorithm(strategy);
  		                const highWaterMark = ExtractHighWaterMark(strategy, 1);
  		                SetUpReadableStreamDefaultControllerFromUnderlyingSource(this, underlyingSource, highWaterMark, sizeAlgorithm);
  		            }
  		        }
  		        /**
  		         * Whether or not the readable stream is locked to a {@link ReadableStreamDefaultReader | reader}.
  		         */
  		        get locked() {
  		            if (!IsReadableStream(this)) {
  		                throw streamBrandCheckException$1('locked');
  		            }
  		            return IsReadableStreamLocked(this);
  		        }
  		        /**
  		         * Cancels the stream, signaling a loss of interest in the stream by a consumer.
  		         *
  		         * The supplied `reason` argument will be given to the underlying source's {@link UnderlyingSource.cancel | cancel()}
  		         * method, which might or might not use it.
  		         */
  		        cancel(reason = undefined) {
  		            if (!IsReadableStream(this)) {
  		                return promiseRejectedWith(streamBrandCheckException$1('cancel'));
  		            }
  		            if (IsReadableStreamLocked(this)) {
  		                return promiseRejectedWith(new TypeError('Cannot cancel a stream that already has a reader'));
  		            }
  		            return ReadableStreamCancel(this, reason);
  		        }
  		        getReader(rawOptions = undefined) {
  		            if (!IsReadableStream(this)) {
  		                throw streamBrandCheckException$1('getReader');
  		            }
  		            const options = convertReaderOptions(rawOptions, 'First parameter');
  		            if (options.mode === undefined) {
  		                return AcquireReadableStreamDefaultReader(this);
  		            }
  		            return AcquireReadableStreamBYOBReader(this);
  		        }
  		        pipeThrough(rawTransform, rawOptions = {}) {
  		            if (!IsReadableStream(this)) {
  		                throw streamBrandCheckException$1('pipeThrough');
  		            }
  		            assertRequiredArgument(rawTransform, 1, 'pipeThrough');
  		            const transform = convertReadableWritablePair(rawTransform, 'First parameter');
  		            const options = convertPipeOptions(rawOptions, 'Second parameter');
  		            if (IsReadableStreamLocked(this)) {
  		                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked ReadableStream');
  		            }
  		            if (IsWritableStreamLocked(transform.writable)) {
  		                throw new TypeError('ReadableStream.prototype.pipeThrough cannot be used on a locked WritableStream');
  		            }
  		            const promise = ReadableStreamPipeTo(this, transform.writable, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
  		            setPromiseIsHandledToTrue(promise);
  		            return transform.readable;
  		        }
  		        pipeTo(destination, rawOptions = {}) {
  		            if (!IsReadableStream(this)) {
  		                return promiseRejectedWith(streamBrandCheckException$1('pipeTo'));
  		            }
  		            if (destination === undefined) {
  		                return promiseRejectedWith(`Parameter 1 is required in 'pipeTo'.`);
  		            }
  		            if (!IsWritableStream(destination)) {
  		                return promiseRejectedWith(new TypeError(`ReadableStream.prototype.pipeTo's first argument must be a WritableStream`));
  		            }
  		            let options;
  		            try {
  		                options = convertPipeOptions(rawOptions, 'Second parameter');
  		            }
  		            catch (e) {
  		                return promiseRejectedWith(e);
  		            }
  		            if (IsReadableStreamLocked(this)) {
  		                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked ReadableStream'));
  		            }
  		            if (IsWritableStreamLocked(destination)) {
  		                return promiseRejectedWith(new TypeError('ReadableStream.prototype.pipeTo cannot be used on a locked WritableStream'));
  		            }
  		            return ReadableStreamPipeTo(this, destination, options.preventClose, options.preventAbort, options.preventCancel, options.signal);
  		        }
  		        /**
  		         * Tees this readable stream, returning a two-element array containing the two resulting branches as
  		         * new {@link ReadableStream} instances.
  		         *
  		         * Teeing a stream will lock it, preventing any other consumer from acquiring a reader.
  		         * To cancel the stream, cancel both of the resulting branches; a composite cancellation reason will then be
  		         * propagated to the stream's underlying source.
  		         *
  		         * Note that the chunks seen in each branch will be the same object. If the chunks are not immutable,
  		         * this could allow interference between the two branches.
  		         */
  		        tee() {
  		            if (!IsReadableStream(this)) {
  		                throw streamBrandCheckException$1('tee');
  		            }
  		            const branches = ReadableStreamTee(this);
  		            return CreateArrayFromList(branches);
  		        }
  		        values(rawOptions = undefined) {
  		            if (!IsReadableStream(this)) {
  		                throw streamBrandCheckException$1('values');
  		            }
  		            const options = convertIteratorOptions(rawOptions, 'First parameter');
  		            return AcquireReadableStreamAsyncIterator(this, options.preventCancel);
  		        }
  		    }
  		    Object.defineProperties(ReadableStream.prototype, {
  		        cancel: { enumerable: true },
  		        getReader: { enumerable: true },
  		        pipeThrough: { enumerable: true },
  		        pipeTo: { enumerable: true },
  		        tee: { enumerable: true },
  		        values: { enumerable: true },
  		        locked: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ReadableStream',
  		            configurable: true
  		        });
  		    }
  		    if (typeof SymbolPolyfill.asyncIterator === 'symbol') {
  		        Object.defineProperty(ReadableStream.prototype, SymbolPolyfill.asyncIterator, {
  		            value: ReadableStream.prototype.values,
  		            writable: true,
  		            configurable: true
  		        });
  		    }
  		    // Abstract operations for the ReadableStream.
  		    // Throws if and only if startAlgorithm throws.
  		    function CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark = 1, sizeAlgorithm = () => 1) {
  		        const stream = Object.create(ReadableStream.prototype);
  		        InitializeReadableStream(stream);
  		        const controller = Object.create(ReadableStreamDefaultController.prototype);
  		        SetUpReadableStreamDefaultController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, highWaterMark, sizeAlgorithm);
  		        return stream;
  		    }
  		    // Throws if and only if startAlgorithm throws.
  		    function CreateReadableByteStream(startAlgorithm, pullAlgorithm, cancelAlgorithm) {
  		        const stream = Object.create(ReadableStream.prototype);
  		        InitializeReadableStream(stream);
  		        const controller = Object.create(ReadableByteStreamController.prototype);
  		        SetUpReadableByteStreamController(stream, controller, startAlgorithm, pullAlgorithm, cancelAlgorithm, 0, undefined);
  		        return stream;
  		    }
  		    function InitializeReadableStream(stream) {
  		        stream._state = 'readable';
  		        stream._reader = undefined;
  		        stream._storedError = undefined;
  		        stream._disturbed = false;
  		    }
  		    function IsReadableStream(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_readableStreamController')) {
  		            return false;
  		        }
  		        return x instanceof ReadableStream;
  		    }
  		    function IsReadableStreamLocked(stream) {
  		        if (stream._reader === undefined) {
  		            return false;
  		        }
  		        return true;
  		    }
  		    // ReadableStream API exposed for controllers.
  		    function ReadableStreamCancel(stream, reason) {
  		        stream._disturbed = true;
  		        if (stream._state === 'closed') {
  		            return promiseResolvedWith(undefined);
  		        }
  		        if (stream._state === 'errored') {
  		            return promiseRejectedWith(stream._storedError);
  		        }
  		        ReadableStreamClose(stream);
  		        const reader = stream._reader;
  		        if (reader !== undefined && IsReadableStreamBYOBReader(reader)) {
  		            reader._readIntoRequests.forEach(readIntoRequest => {
  		                readIntoRequest._closeSteps(undefined);
  		            });
  		            reader._readIntoRequests = new SimpleQueue();
  		        }
  		        const sourceCancelPromise = stream._readableStreamController[CancelSteps](reason);
  		        return transformPromiseWith(sourceCancelPromise, noop);
  		    }
  		    function ReadableStreamClose(stream) {
  		        stream._state = 'closed';
  		        const reader = stream._reader;
  		        if (reader === undefined) {
  		            return;
  		        }
  		        defaultReaderClosedPromiseResolve(reader);
  		        if (IsReadableStreamDefaultReader(reader)) {
  		            reader._readRequests.forEach(readRequest => {
  		                readRequest._closeSteps();
  		            });
  		            reader._readRequests = new SimpleQueue();
  		        }
  		    }
  		    function ReadableStreamError(stream, e) {
  		        stream._state = 'errored';
  		        stream._storedError = e;
  		        const reader = stream._reader;
  		        if (reader === undefined) {
  		            return;
  		        }
  		        defaultReaderClosedPromiseReject(reader, e);
  		        if (IsReadableStreamDefaultReader(reader)) {
  		            reader._readRequests.forEach(readRequest => {
  		                readRequest._errorSteps(e);
  		            });
  		            reader._readRequests = new SimpleQueue();
  		        }
  		        else {
  		            reader._readIntoRequests.forEach(readIntoRequest => {
  		                readIntoRequest._errorSteps(e);
  		            });
  		            reader._readIntoRequests = new SimpleQueue();
  		        }
  		    }
  		    // Helper functions for the ReadableStream.
  		    function streamBrandCheckException$1(name) {
  		        return new TypeError(`ReadableStream.prototype.${name} can only be used on a ReadableStream`);
  		    }

  		    function convertQueuingStrategyInit(init, context) {
  		        assertDictionary(init, context);
  		        const highWaterMark = init === null || init === void 0 ? void 0 : init.highWaterMark;
  		        assertRequiredField(highWaterMark, 'highWaterMark', 'QueuingStrategyInit');
  		        return {
  		            highWaterMark: convertUnrestrictedDouble(highWaterMark)
  		        };
  		    }

  		    // The size function must not have a prototype property nor be a constructor
  		    const byteLengthSizeFunction = (chunk) => {
  		        return chunk.byteLength;
  		    };
  		    try {
  		        Object.defineProperty(byteLengthSizeFunction, 'name', {
  		            value: 'size',
  		            configurable: true
  		        });
  		    }
  		    catch (_a) {
  		        // This property is non-configurable in older browsers, so ignore if this throws.
  		        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
  		    }
  		    /**
  		     * A queuing strategy that counts the number of bytes in each chunk.
  		     *
  		     * @public
  		     */
  		    class ByteLengthQueuingStrategy {
  		        constructor(options) {
  		            assertRequiredArgument(options, 1, 'ByteLengthQueuingStrategy');
  		            options = convertQueuingStrategyInit(options, 'First parameter');
  		            this._byteLengthQueuingStrategyHighWaterMark = options.highWaterMark;
  		        }
  		        /**
  		         * Returns the high water mark provided to the constructor.
  		         */
  		        get highWaterMark() {
  		            if (!IsByteLengthQueuingStrategy(this)) {
  		                throw byteLengthBrandCheckException('highWaterMark');
  		            }
  		            return this._byteLengthQueuingStrategyHighWaterMark;
  		        }
  		        /**
  		         * Measures the size of `chunk` by returning the value of its `byteLength` property.
  		         */
  		        get size() {
  		            if (!IsByteLengthQueuingStrategy(this)) {
  		                throw byteLengthBrandCheckException('size');
  		            }
  		            return byteLengthSizeFunction;
  		        }
  		    }
  		    Object.defineProperties(ByteLengthQueuingStrategy.prototype, {
  		        highWaterMark: { enumerable: true },
  		        size: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(ByteLengthQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'ByteLengthQueuingStrategy',
  		            configurable: true
  		        });
  		    }
  		    // Helper functions for the ByteLengthQueuingStrategy.
  		    function byteLengthBrandCheckException(name) {
  		        return new TypeError(`ByteLengthQueuingStrategy.prototype.${name} can only be used on a ByteLengthQueuingStrategy`);
  		    }
  		    function IsByteLengthQueuingStrategy(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_byteLengthQueuingStrategyHighWaterMark')) {
  		            return false;
  		        }
  		        return x instanceof ByteLengthQueuingStrategy;
  		    }

  		    // The size function must not have a prototype property nor be a constructor
  		    const countSizeFunction = () => {
  		        return 1;
  		    };
  		    try {
  		        Object.defineProperty(countSizeFunction, 'name', {
  		            value: 'size',
  		            configurable: true
  		        });
  		    }
  		    catch (_a) {
  		        // This property is non-configurable in older browsers, so ignore if this throws.
  		        // https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name#browser_compatibility
  		    }
  		    /**
  		     * A queuing strategy that counts the number of chunks.
  		     *
  		     * @public
  		     */
  		    class CountQueuingStrategy {
  		        constructor(options) {
  		            assertRequiredArgument(options, 1, 'CountQueuingStrategy');
  		            options = convertQueuingStrategyInit(options, 'First parameter');
  		            this._countQueuingStrategyHighWaterMark = options.highWaterMark;
  		        }
  		        /**
  		         * Returns the high water mark provided to the constructor.
  		         */
  		        get highWaterMark() {
  		            if (!IsCountQueuingStrategy(this)) {
  		                throw countBrandCheckException('highWaterMark');
  		            }
  		            return this._countQueuingStrategyHighWaterMark;
  		        }
  		        /**
  		         * Measures the size of `chunk` by always returning 1.
  		         * This ensures that the total queue size is a count of the number of chunks in the queue.
  		         */
  		        get size() {
  		            if (!IsCountQueuingStrategy(this)) {
  		                throw countBrandCheckException('size');
  		            }
  		            return countSizeFunction;
  		        }
  		    }
  		    Object.defineProperties(CountQueuingStrategy.prototype, {
  		        highWaterMark: { enumerable: true },
  		        size: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(CountQueuingStrategy.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'CountQueuingStrategy',
  		            configurable: true
  		        });
  		    }
  		    // Helper functions for the CountQueuingStrategy.
  		    function countBrandCheckException(name) {
  		        return new TypeError(`CountQueuingStrategy.prototype.${name} can only be used on a CountQueuingStrategy`);
  		    }
  		    function IsCountQueuingStrategy(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_countQueuingStrategyHighWaterMark')) {
  		            return false;
  		        }
  		        return x instanceof CountQueuingStrategy;
  		    }

  		    function convertTransformer(original, context) {
  		        assertDictionary(original, context);
  		        const flush = original === null || original === void 0 ? void 0 : original.flush;
  		        const readableType = original === null || original === void 0 ? void 0 : original.readableType;
  		        const start = original === null || original === void 0 ? void 0 : original.start;
  		        const transform = original === null || original === void 0 ? void 0 : original.transform;
  		        const writableType = original === null || original === void 0 ? void 0 : original.writableType;
  		        return {
  		            flush: flush === undefined ?
  		                undefined :
  		                convertTransformerFlushCallback(flush, original, `${context} has member 'flush' that`),
  		            readableType,
  		            start: start === undefined ?
  		                undefined :
  		                convertTransformerStartCallback(start, original, `${context} has member 'start' that`),
  		            transform: transform === undefined ?
  		                undefined :
  		                convertTransformerTransformCallback(transform, original, `${context} has member 'transform' that`),
  		            writableType
  		        };
  		    }
  		    function convertTransformerFlushCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (controller) => promiseCall(fn, original, [controller]);
  		    }
  		    function convertTransformerStartCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (controller) => reflectCall(fn, original, [controller]);
  		    }
  		    function convertTransformerTransformCallback(fn, original, context) {
  		        assertFunction(fn, context);
  		        return (chunk, controller) => promiseCall(fn, original, [chunk, controller]);
  		    }

  		    // Class TransformStream
  		    /**
  		     * A transform stream consists of a pair of streams: a {@link WritableStream | writable stream},
  		     * known as its writable side, and a {@link ReadableStream | readable stream}, known as its readable side.
  		     * In a manner specific to the transform stream in question, writes to the writable side result in new data being
  		     * made available for reading from the readable side.
  		     *
  		     * @public
  		     */
  		    class TransformStream {
  		        constructor(rawTransformer = {}, rawWritableStrategy = {}, rawReadableStrategy = {}) {
  		            if (rawTransformer === undefined) {
  		                rawTransformer = null;
  		            }
  		            const writableStrategy = convertQueuingStrategy(rawWritableStrategy, 'Second parameter');
  		            const readableStrategy = convertQueuingStrategy(rawReadableStrategy, 'Third parameter');
  		            const transformer = convertTransformer(rawTransformer, 'First parameter');
  		            if (transformer.readableType !== undefined) {
  		                throw new RangeError('Invalid readableType specified');
  		            }
  		            if (transformer.writableType !== undefined) {
  		                throw new RangeError('Invalid writableType specified');
  		            }
  		            const readableHighWaterMark = ExtractHighWaterMark(readableStrategy, 0);
  		            const readableSizeAlgorithm = ExtractSizeAlgorithm(readableStrategy);
  		            const writableHighWaterMark = ExtractHighWaterMark(writableStrategy, 1);
  		            const writableSizeAlgorithm = ExtractSizeAlgorithm(writableStrategy);
  		            let startPromise_resolve;
  		            const startPromise = newPromise(resolve => {
  		                startPromise_resolve = resolve;
  		            });
  		            InitializeTransformStream(this, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
  		            SetUpTransformStreamDefaultControllerFromTransformer(this, transformer);
  		            if (transformer.start !== undefined) {
  		                startPromise_resolve(transformer.start(this._transformStreamController));
  		            }
  		            else {
  		                startPromise_resolve(undefined);
  		            }
  		        }
  		        /**
  		         * The readable side of the transform stream.
  		         */
  		        get readable() {
  		            if (!IsTransformStream(this)) {
  		                throw streamBrandCheckException('readable');
  		            }
  		            return this._readable;
  		        }
  		        /**
  		         * The writable side of the transform stream.
  		         */
  		        get writable() {
  		            if (!IsTransformStream(this)) {
  		                throw streamBrandCheckException('writable');
  		            }
  		            return this._writable;
  		        }
  		    }
  		    Object.defineProperties(TransformStream.prototype, {
  		        readable: { enumerable: true },
  		        writable: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(TransformStream.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'TransformStream',
  		            configurable: true
  		        });
  		    }
  		    function InitializeTransformStream(stream, startPromise, writableHighWaterMark, writableSizeAlgorithm, readableHighWaterMark, readableSizeAlgorithm) {
  		        function startAlgorithm() {
  		            return startPromise;
  		        }
  		        function writeAlgorithm(chunk) {
  		            return TransformStreamDefaultSinkWriteAlgorithm(stream, chunk);
  		        }
  		        function abortAlgorithm(reason) {
  		            return TransformStreamDefaultSinkAbortAlgorithm(stream, reason);
  		        }
  		        function closeAlgorithm() {
  		            return TransformStreamDefaultSinkCloseAlgorithm(stream);
  		        }
  		        stream._writable = CreateWritableStream(startAlgorithm, writeAlgorithm, closeAlgorithm, abortAlgorithm, writableHighWaterMark, writableSizeAlgorithm);
  		        function pullAlgorithm() {
  		            return TransformStreamDefaultSourcePullAlgorithm(stream);
  		        }
  		        function cancelAlgorithm(reason) {
  		            TransformStreamErrorWritableAndUnblockWrite(stream, reason);
  		            return promiseResolvedWith(undefined);
  		        }
  		        stream._readable = CreateReadableStream(startAlgorithm, pullAlgorithm, cancelAlgorithm, readableHighWaterMark, readableSizeAlgorithm);
  		        // The [[backpressure]] slot is set to undefined so that it can be initialised by TransformStreamSetBackpressure.
  		        stream._backpressure = undefined;
  		        stream._backpressureChangePromise = undefined;
  		        stream._backpressureChangePromise_resolve = undefined;
  		        TransformStreamSetBackpressure(stream, true);
  		        stream._transformStreamController = undefined;
  		    }
  		    function IsTransformStream(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_transformStreamController')) {
  		            return false;
  		        }
  		        return x instanceof TransformStream;
  		    }
  		    // This is a no-op if both sides are already errored.
  		    function TransformStreamError(stream, e) {
  		        ReadableStreamDefaultControllerError(stream._readable._readableStreamController, e);
  		        TransformStreamErrorWritableAndUnblockWrite(stream, e);
  		    }
  		    function TransformStreamErrorWritableAndUnblockWrite(stream, e) {
  		        TransformStreamDefaultControllerClearAlgorithms(stream._transformStreamController);
  		        WritableStreamDefaultControllerErrorIfNeeded(stream._writable._writableStreamController, e);
  		        if (stream._backpressure) {
  		            // Pretend that pull() was called to permit any pending write() calls to complete. TransformStreamSetBackpressure()
  		            // cannot be called from enqueue() or pull() once the ReadableStream is errored, so this will will be the final time
  		            // _backpressure is set.
  		            TransformStreamSetBackpressure(stream, false);
  		        }
  		    }
  		    function TransformStreamSetBackpressure(stream, backpressure) {
  		        // Passes also when called during construction.
  		        if (stream._backpressureChangePromise !== undefined) {
  		            stream._backpressureChangePromise_resolve();
  		        }
  		        stream._backpressureChangePromise = newPromise(resolve => {
  		            stream._backpressureChangePromise_resolve = resolve;
  		        });
  		        stream._backpressure = backpressure;
  		    }
  		    // Class TransformStreamDefaultController
  		    /**
  		     * Allows control of the {@link ReadableStream} and {@link WritableStream} of the associated {@link TransformStream}.
  		     *
  		     * @public
  		     */
  		    class TransformStreamDefaultController {
  		        constructor() {
  		            throw new TypeError('Illegal constructor');
  		        }
  		        /**
  		         * Returns the desired size to fill the readable sides internal queue. It can be negative, if the queue is over-full.
  		         */
  		        get desiredSize() {
  		            if (!IsTransformStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException('desiredSize');
  		            }
  		            const readableController = this._controlledTransformStream._readable._readableStreamController;
  		            return ReadableStreamDefaultControllerGetDesiredSize(readableController);
  		        }
  		        enqueue(chunk = undefined) {
  		            if (!IsTransformStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException('enqueue');
  		            }
  		            TransformStreamDefaultControllerEnqueue(this, chunk);
  		        }
  		        /**
  		         * Errors both the readable side and the writable side of the controlled transform stream, making all future
  		         * interactions with it fail with the given error `e`. Any chunks queued for transformation will be discarded.
  		         */
  		        error(reason = undefined) {
  		            if (!IsTransformStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException('error');
  		            }
  		            TransformStreamDefaultControllerError(this, reason);
  		        }
  		        /**
  		         * Closes the readable side and errors the writable side of the controlled transform stream. This is useful when the
  		         * transformer only needs to consume a portion of the chunks written to the writable side.
  		         */
  		        terminate() {
  		            if (!IsTransformStreamDefaultController(this)) {
  		                throw defaultControllerBrandCheckException('terminate');
  		            }
  		            TransformStreamDefaultControllerTerminate(this);
  		        }
  		    }
  		    Object.defineProperties(TransformStreamDefaultController.prototype, {
  		        enqueue: { enumerable: true },
  		        error: { enumerable: true },
  		        terminate: { enumerable: true },
  		        desiredSize: { enumerable: true }
  		    });
  		    if (typeof SymbolPolyfill.toStringTag === 'symbol') {
  		        Object.defineProperty(TransformStreamDefaultController.prototype, SymbolPolyfill.toStringTag, {
  		            value: 'TransformStreamDefaultController',
  		            configurable: true
  		        });
  		    }
  		    // Transform Stream Default Controller Abstract Operations
  		    function IsTransformStreamDefaultController(x) {
  		        if (!typeIsObject(x)) {
  		            return false;
  		        }
  		        if (!Object.prototype.hasOwnProperty.call(x, '_controlledTransformStream')) {
  		            return false;
  		        }
  		        return x instanceof TransformStreamDefaultController;
  		    }
  		    function SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm) {
  		        controller._controlledTransformStream = stream;
  		        stream._transformStreamController = controller;
  		        controller._transformAlgorithm = transformAlgorithm;
  		        controller._flushAlgorithm = flushAlgorithm;
  		    }
  		    function SetUpTransformStreamDefaultControllerFromTransformer(stream, transformer) {
  		        const controller = Object.create(TransformStreamDefaultController.prototype);
  		        let transformAlgorithm = (chunk) => {
  		            try {
  		                TransformStreamDefaultControllerEnqueue(controller, chunk);
  		                return promiseResolvedWith(undefined);
  		            }
  		            catch (transformResultE) {
  		                return promiseRejectedWith(transformResultE);
  		            }
  		        };
  		        let flushAlgorithm = () => promiseResolvedWith(undefined);
  		        if (transformer.transform !== undefined) {
  		            transformAlgorithm = chunk => transformer.transform(chunk, controller);
  		        }
  		        if (transformer.flush !== undefined) {
  		            flushAlgorithm = () => transformer.flush(controller);
  		        }
  		        SetUpTransformStreamDefaultController(stream, controller, transformAlgorithm, flushAlgorithm);
  		    }
  		    function TransformStreamDefaultControllerClearAlgorithms(controller) {
  		        controller._transformAlgorithm = undefined;
  		        controller._flushAlgorithm = undefined;
  		    }
  		    function TransformStreamDefaultControllerEnqueue(controller, chunk) {
  		        const stream = controller._controlledTransformStream;
  		        const readableController = stream._readable._readableStreamController;
  		        if (!ReadableStreamDefaultControllerCanCloseOrEnqueue(readableController)) {
  		            throw new TypeError('Readable side is not in a state that permits enqueue');
  		        }
  		        // We throttle transform invocations based on the backpressure of the ReadableStream, but we still
  		        // accept TransformStreamDefaultControllerEnqueue() calls.
  		        try {
  		            ReadableStreamDefaultControllerEnqueue(readableController, chunk);
  		        }
  		        catch (e) {
  		            // This happens when readableStrategy.size() throws.
  		            TransformStreamErrorWritableAndUnblockWrite(stream, e);
  		            throw stream._readable._storedError;
  		        }
  		        const backpressure = ReadableStreamDefaultControllerHasBackpressure(readableController);
  		        if (backpressure !== stream._backpressure) {
  		            TransformStreamSetBackpressure(stream, true);
  		        }
  		    }
  		    function TransformStreamDefaultControllerError(controller, e) {
  		        TransformStreamError(controller._controlledTransformStream, e);
  		    }
  		    function TransformStreamDefaultControllerPerformTransform(controller, chunk) {
  		        const transformPromise = controller._transformAlgorithm(chunk);
  		        return transformPromiseWith(transformPromise, undefined, r => {
  		            TransformStreamError(controller._controlledTransformStream, r);
  		            throw r;
  		        });
  		    }
  		    function TransformStreamDefaultControllerTerminate(controller) {
  		        const stream = controller._controlledTransformStream;
  		        const readableController = stream._readable._readableStreamController;
  		        ReadableStreamDefaultControllerClose(readableController);
  		        const error = new TypeError('TransformStream terminated');
  		        TransformStreamErrorWritableAndUnblockWrite(stream, error);
  		    }
  		    // TransformStreamDefaultSink Algorithms
  		    function TransformStreamDefaultSinkWriteAlgorithm(stream, chunk) {
  		        const controller = stream._transformStreamController;
  		        if (stream._backpressure) {
  		            const backpressureChangePromise = stream._backpressureChangePromise;
  		            return transformPromiseWith(backpressureChangePromise, () => {
  		                const writable = stream._writable;
  		                const state = writable._state;
  		                if (state === 'erroring') {
  		                    throw writable._storedError;
  		                }
  		                return TransformStreamDefaultControllerPerformTransform(controller, chunk);
  		            });
  		        }
  		        return TransformStreamDefaultControllerPerformTransform(controller, chunk);
  		    }
  		    function TransformStreamDefaultSinkAbortAlgorithm(stream, reason) {
  		        // abort() is not called synchronously, so it is possible for abort() to be called when the stream is already
  		        // errored.
  		        TransformStreamError(stream, reason);
  		        return promiseResolvedWith(undefined);
  		    }
  		    function TransformStreamDefaultSinkCloseAlgorithm(stream) {
  		        // stream._readable cannot change after construction, so caching it across a call to user code is safe.
  		        const readable = stream._readable;
  		        const controller = stream._transformStreamController;
  		        const flushPromise = controller._flushAlgorithm();
  		        TransformStreamDefaultControllerClearAlgorithms(controller);
  		        // Return a promise that is fulfilled with undefined on success.
  		        return transformPromiseWith(flushPromise, () => {
  		            if (readable._state === 'errored') {
  		                throw readable._storedError;
  		            }
  		            ReadableStreamDefaultControllerClose(readable._readableStreamController);
  		        }, r => {
  		            TransformStreamError(stream, r);
  		            throw readable._storedError;
  		        });
  		    }
  		    // TransformStreamDefaultSource Algorithms
  		    function TransformStreamDefaultSourcePullAlgorithm(stream) {
  		        // Invariant. Enforced by the promises returned by start() and pull().
  		        TransformStreamSetBackpressure(stream, false);
  		        // Prevent the next pull() call until there is backpressure.
  		        return stream._backpressureChangePromise;
  		    }
  		    // Helper functions for the TransformStreamDefaultController.
  		    function defaultControllerBrandCheckException(name) {
  		        return new TypeError(`TransformStreamDefaultController.prototype.${name} can only be used on a TransformStreamDefaultController`);
  		    }
  		    // Helper functions for the TransformStream.
  		    function streamBrandCheckException(name) {
  		        return new TypeError(`TransformStream.prototype.${name} can only be used on a TransformStream`);
  		    }

  		    exports.ByteLengthQueuingStrategy = ByteLengthQueuingStrategy;
  		    exports.CountQueuingStrategy = CountQueuingStrategy;
  		    exports.ReadableByteStreamController = ReadableByteStreamController;
  		    exports.ReadableStream = ReadableStream;
  		    exports.ReadableStreamBYOBReader = ReadableStreamBYOBReader;
  		    exports.ReadableStreamBYOBRequest = ReadableStreamBYOBRequest;
  		    exports.ReadableStreamDefaultController = ReadableStreamDefaultController;
  		    exports.ReadableStreamDefaultReader = ReadableStreamDefaultReader;
  		    exports.TransformStream = TransformStream;
  		    exports.TransformStreamDefaultController = TransformStreamDefaultController;
  		    exports.WritableStream = WritableStream;
  		    exports.WritableStreamDefaultController = WritableStreamDefaultController;
  		    exports.WritableStreamDefaultWriter = WritableStreamDefaultWriter;

  		    Object.defineProperty(exports, '__esModule', { value: true });

  		})));
  		
  } (ponyfill_es2018, ponyfill_es2018.exports));
  	return ponyfill_es2018.exports;
  }

  /* c8 ignore start */

  // 64 KiB (same size chrome slice theirs blob into Uint8array's)
  const POOL_SIZE$1 = 65536;

  if (!globalThis.ReadableStream) {
    // `node:stream/web` got introduced in v16.5.0 as experimental
    // and it's preferred over the polyfilled version. So we also
    // suppress the warning that gets emitted by NodeJS for using it.
    try {
      const process = require('node:process');
      const { emitWarning } = process;
      try {
        process.emitWarning = () => {};
        Object.assign(globalThis, require('node:stream/web'));
        process.emitWarning = emitWarning;
      } catch (error) {
        process.emitWarning = emitWarning;
        throw error
      }
    } catch (error) {
      // fallback to polyfill implementation
      Object.assign(globalThis, requirePonyfill_es2018());
    }
  }

  try {
    // Don't use node: prefix for this, require+node: is not supported until node v14.14
    // Only `import()` can use prefix in 12.20 and later
    const { Blob } = require('buffer');
    if (Blob && !Blob.prototype.stream) {
      Blob.prototype.stream = function name (params) {
        let position = 0;
        const blob = this;

        return new ReadableStream({
          type: 'bytes',
          async pull (ctrl) {
            const chunk = blob.slice(position, Math.min(blob.size, position + POOL_SIZE$1));
            const buffer = await chunk.arrayBuffer();
            position += buffer.byteLength;
            ctrl.enqueue(new Uint8Array(buffer));

            if (position === blob.size) {
              ctrl.close();
            }
          }
        })
      };
    }
  } catch (error) {}

  /*! fetch-blob. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */

  // 64 KiB (same size chrome slice theirs blob into Uint8array's)
  const POOL_SIZE = 65536;

  /** @param {(Blob | Uint8Array)[]} parts */
  async function * toIterator (parts, clone = true) {
    for (const part of parts) {
      if ('stream' in part) {
        yield * (/** @type {AsyncIterableIterator<Uint8Array>} */ (part.stream()));
      } else if (ArrayBuffer.isView(part)) {
        if (clone) {
          let position = part.byteOffset;
          const end = part.byteOffset + part.byteLength;
          while (position !== end) {
            const size = Math.min(end - position, POOL_SIZE);
            const chunk = part.buffer.slice(position, position + size);
            position += chunk.byteLength;
            yield new Uint8Array(chunk);
          }
        } else {
          yield part;
        }
      /* c8 ignore next 10 */
      } else {
        // For blobs that have arrayBuffer but no stream method (nodes buffer.Blob)
        let position = 0, b = (/** @type {Blob} */ (part));
        while (position !== b.size) {
          const chunk = b.slice(position, Math.min(b.size, position + POOL_SIZE));
          const buffer = await chunk.arrayBuffer();
          position += buffer.byteLength;
          yield new Uint8Array(buffer);
        }
      }
    }
  }

  const _Blob = class Blob {
    /** @type {Array.<(Blob|Uint8Array)>} */
    #parts = []
    #type = ''
    #size = 0
    #endings = 'transparent'

    /**
     * The Blob() constructor returns a new Blob object. The content
     * of the blob consists of the concatenation of the values given
     * in the parameter array.
     *
     * @param {*} blobParts
     * @param {{ type?: string, endings?: string }} [options]
     */
    constructor (blobParts = [], options = {}) {
      if (typeof blobParts !== 'object' || blobParts === null) {
        throw new TypeError('Failed to construct \'Blob\': The provided value cannot be converted to a sequence.')
      }

      if (typeof blobParts[Symbol.iterator] !== 'function') {
        throw new TypeError('Failed to construct \'Blob\': The object must have a callable @@iterator property.')
      }

      if (typeof options !== 'object' && typeof options !== 'function') {
        throw new TypeError('Failed to construct \'Blob\': parameter 2 cannot convert to dictionary.')
      }

      if (options === null) options = {};

      const encoder = new TextEncoder();
      for (const element of blobParts) {
        let part;
        if (ArrayBuffer.isView(element)) {
          part = new Uint8Array(element.buffer.slice(element.byteOffset, element.byteOffset + element.byteLength));
        } else if (element instanceof ArrayBuffer) {
          part = new Uint8Array(element.slice(0));
        } else if (element instanceof Blob) {
          part = element;
        } else {
          part = encoder.encode(`${element}`);
        }

        this.#size += ArrayBuffer.isView(part) ? part.byteLength : part.size;
        this.#parts.push(part);
      }

      this.#endings = `${options.endings === undefined ? 'transparent' : options.endings}`;
      const type = options.type === undefined ? '' : String(options.type);
      this.#type = /^[\x20-\x7E]*$/.test(type) ? type : '';
    }

    /**
     * The Blob interface's size property returns the
     * size of the Blob in bytes.
     */
    get size () {
      return this.#size
    }

    /**
     * The type property of a Blob object returns the MIME type of the file.
     */
    get type () {
      return this.#type
    }

    /**
     * The text() method in the Blob interface returns a Promise
     * that resolves with a string containing the contents of
     * the blob, interpreted as UTF-8.
     *
     * @return {Promise<string>}
     */
    async text () {
      // More optimized than using this.arrayBuffer()
      // that requires twice as much ram
      const decoder = new TextDecoder();
      let str = '';
      for await (const part of toIterator(this.#parts, false)) {
        str += decoder.decode(part, { stream: true });
      }
      // Remaining
      str += decoder.decode();
      return str
    }

    /**
     * The arrayBuffer() method in the Blob interface returns a
     * Promise that resolves with the contents of the blob as
     * binary data contained in an ArrayBuffer.
     *
     * @return {Promise<ArrayBuffer>}
     */
    async arrayBuffer () {
      // Easier way... Just a unnecessary overhead
      // const view = new Uint8Array(this.size);
      // await this.stream().getReader({mode: 'byob'}).read(view);
      // return view.buffer;

      const data = new Uint8Array(this.size);
      let offset = 0;
      for await (const chunk of toIterator(this.#parts, false)) {
        data.set(chunk, offset);
        offset += chunk.length;
      }

      return data.buffer
    }

    stream () {
      const it = toIterator(this.#parts, true);

      return new globalThis.ReadableStream({
        // @ts-ignore
        type: 'bytes',
        async pull (ctrl) {
          const chunk = await it.next();
          chunk.done ? ctrl.close() : ctrl.enqueue(chunk.value);
        },

        async cancel () {
          await it.return();
        }
      })
    }

    /**
     * The Blob interface's slice() method creates and returns a
     * new Blob object which contains data from a subset of the
     * blob on which it's called.
     *
     * @param {number} [start]
     * @param {number} [end]
     * @param {string} [type]
     */
    slice (start = 0, end = this.size, type = '') {
      const { size } = this;

      let relativeStart = start < 0 ? Math.max(size + start, 0) : Math.min(start, size);
      let relativeEnd = end < 0 ? Math.max(size + end, 0) : Math.min(end, size);

      const span = Math.max(relativeEnd - relativeStart, 0);
      const parts = this.#parts;
      const blobParts = [];
      let added = 0;

      for (const part of parts) {
        // don't add the overflow to new blobParts
        if (added >= span) {
          break
        }

        const size = ArrayBuffer.isView(part) ? part.byteLength : part.size;
        if (relativeStart && size <= relativeStart) {
          // Skip the beginning and change the relative
          // start & end position as we skip the unwanted parts
          relativeStart -= size;
          relativeEnd -= size;
        } else {
          let chunk;
          if (ArrayBuffer.isView(part)) {
            chunk = part.subarray(relativeStart, Math.min(size, relativeEnd));
            added += chunk.byteLength;
          } else {
            chunk = part.slice(relativeStart, Math.min(size, relativeEnd));
            added += chunk.size;
          }
          relativeEnd -= size;
          blobParts.push(chunk);
          relativeStart = 0; // All next sequential parts should start at 0
        }
      }

      const blob = new Blob([], { type: String(type).toLowerCase() });
      blob.#size = span;
      blob.#parts = blobParts;

      return blob
    }

    get [Symbol.toStringTag] () {
      return 'Blob'
    }

    static [Symbol.hasInstance] (object) {
      return (
        object &&
        typeof object === 'object' &&
        typeof object.constructor === 'function' &&
        (
          typeof object.stream === 'function' ||
          typeof object.arrayBuffer === 'function'
        ) &&
        /^(Blob|File)$/.test(object[Symbol.toStringTag])
      )
    }
  };

  Object.defineProperties(_Blob.prototype, {
    size: { enumerable: true },
    type: { enumerable: true },
    slice: { enumerable: true }
  });

  /** @type {typeof globalThis.Blob} */
  const Blob = _Blob;

  const _File = class File extends Blob {
    #lastModified = 0
    #name = ''

    /**
     * @param {*[]} fileBits
     * @param {string} fileName
     * @param {{lastModified?: number, type?: string}} options
     */// @ts-ignore
    constructor (fileBits, fileName, options = {}) {
      if (arguments.length < 2) {
        throw new TypeError(`Failed to construct 'File': 2 arguments required, but only ${arguments.length} present.`)
      }
      super(fileBits, options);

      if (options === null) options = {};

      // Simulate WebIDL type casting for NaN value in lastModified option.
      const lastModified = options.lastModified === undefined ? Date.now() : Number(options.lastModified);
      if (!Number.isNaN(lastModified)) {
        this.#lastModified = lastModified;
      }

      this.#name = String(fileName);
    }

    get name () {
      return this.#name
    }

    get lastModified () {
      return this.#lastModified
    }

    get [Symbol.toStringTag] () {
      return 'File'
    }

    static [Symbol.hasInstance] (object) {
      return !!object && object instanceof Blob &&
        /^(File)$/.test(object[Symbol.toStringTag])
    }
  };

  /** @type {typeof globalThis.File} */// @ts-ignore
  const File = _File;

  /*! formdata-polyfill. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */

  var {toStringTag:t,iterator:i,hasInstance:h}=Symbol,
  r=Math.random,
  m='append,set,get,getAll,delete,keys,values,entries,forEach,constructor'.split(','),
  f$1=(a,b,c)=>(a+='',/^(Blob|File)$/.test(b && b[t])?[(c=c!==void 0?c+'':b[t]=='File'?b.name:'blob',a),b.name!==c||b[t]=='blob'?new File([b],c,b):b]:[a,b+'']),
  e=(c,f)=>(f?c:c.replace(/\r?\n|\r/g,'\r\n')).replace(/\n/g,'%0A').replace(/\r/g,'%0D').replace(/"/g,'%22'),
  x=(n, a, e)=>{if(a.length<e){throw new TypeError(`Failed to execute '${n}' on 'FormData': ${e} arguments required, but only ${a.length} present.`)}};

  /** @type {typeof globalThis.FormData} */
  const FormData = class FormData {
  #d=[];
  constructor(...a){if(a.length)throw new TypeError(`Failed to construct 'FormData': parameter 1 is not of type 'HTMLFormElement'.`)}
  get [t]() {return 'FormData'}
  [i](){return this.entries()}
  static [h](o) {return o&&typeof o==='object'&&o[t]==='FormData'&&!m.some(m=>typeof o[m]!='function')}
  append(...a){x('append',arguments,2);this.#d.push(f$1(...a));}
  delete(a){x('delete',arguments,1);a+='';this.#d=this.#d.filter(([b])=>b!==a);}
  get(a){x('get',arguments,1);a+='';for(var b=this.#d,l=b.length,c=0;c<l;c++)if(b[c][0]===a)return b[c][1];return null}
  getAll(a,b){x('getAll',arguments,1);b=[];a+='';this.#d.forEach(c=>c[0]===a&&b.push(c[1]));return b}
  has(a){x('has',arguments,1);a+='';return this.#d.some(b=>b[0]===a)}
  forEach(a,b){x('forEach',arguments,1);for(var [c,d]of this)a.call(b,d,c,this);}
  set(...a){x('set',arguments,2);var b=[],c=!0;a=f$1(...a);this.#d.forEach(d=>{d[0]===a[0]?c&&(c=!b.push(a)):b.push(d);});c&&b.push(a);this.#d=b;}
  *entries(){yield*this.#d;}
  *keys(){for(var[a]of this)yield a;}
  *values(){for(var[,a]of this)yield a;}};

  /** @param {FormData} F */
  function formDataToBlob (F,B=Blob){
  var b=`${r()}${r()}`.replace(/\./g, '').slice(-28).padStart(32, '-'),c=[],p=`--${b}\r\nContent-Disposition: form-data; name="`;
  F.forEach((v,n)=>typeof v=='string'
  ?c.push(p+e(n)+`"\r\n\r\n${v.replace(/\r(?!\n)|(?<!\r)\n/g, '\r\n')}\r\n`)
  :c.push(p+e(n)+`"; filename="${e(v.name, 1)}"\r\nContent-Type: ${v.type||"application/octet-stream"}\r\n\r\n`, v, '\r\n'));
  c.push(`--${b}--`);
  return new B(c,{type:"multipart/form-data; boundary="+b})}

  class FetchBaseError extends Error {
  	constructor(message, type) {
  		super(message);
  		// Hide custom error implementation details from end-users
  		Error.captureStackTrace(this, this.constructor);

  		this.type = type;
  	}

  	get name() {
  		return this.constructor.name;
  	}

  	get [Symbol.toStringTag]() {
  		return this.constructor.name;
  	}
  }

  /**
   * @typedef {{ address?: string, code: string, dest?: string, errno: number, info?: object, message: string, path?: string, port?: number, syscall: string}} SystemError
  */

  /**
   * FetchError interface for operational errors
   */
  class FetchError extends FetchBaseError {
  	/**
  	 * @param  {string} message -      Error message for human
  	 * @param  {string} [type] -        Error type for machine
  	 * @param  {SystemError} [systemError] - For Node.js system error
  	 */
  	constructor(message, type, systemError) {
  		super(message, type);
  		// When err.type is `system`, err.erroredSysCall contains system error and err.code contains system error code
  		if (systemError) {
  			// eslint-disable-next-line no-multi-assign
  			this.code = this.errno = systemError.code;
  			this.erroredSysCall = systemError.syscall;
  		}
  	}
  }

  /**
   * Is.js
   *
   * Object type checks.
   */

  const NAME = Symbol.toStringTag;

  /**
   * Check if `obj` is a URLSearchParams object
   * ref: https://github.com/node-fetch/node-fetch/issues/296#issuecomment-307598143
   * @param {*} object - Object to check for
   * @return {boolean}
   */
  const isURLSearchParameters = object => {
  	return (
  		typeof object === 'object' &&
  		typeof object.append === 'function' &&
  		typeof object.delete === 'function' &&
  		typeof object.get === 'function' &&
  		typeof object.getAll === 'function' &&
  		typeof object.has === 'function' &&
  		typeof object.set === 'function' &&
  		typeof object.sort === 'function' &&
  		object[NAME] === 'URLSearchParams'
  	);
  };

  /**
   * Check if `object` is a W3C `Blob` object (which `File` inherits from)
   * @param {*} object - Object to check for
   * @return {boolean}
   */
  const isBlob = object => {
  	return (
  		object &&
  		typeof object === 'object' &&
  		typeof object.arrayBuffer === 'function' &&
  		typeof object.type === 'string' &&
  		typeof object.stream === 'function' &&
  		typeof object.constructor === 'function' &&
  		/^(Blob|File)$/.test(object[NAME])
  	);
  };

  /**
   * Check if `obj` is an instance of AbortSignal.
   * @param {*} object - Object to check for
   * @return {boolean}
   */
  const isAbortSignal = object => {
  	return (
  		typeof object === 'object' && (
  			object[NAME] === 'AbortSignal' ||
  			object[NAME] === 'EventTarget'
  		)
  	);
  };

  /**
   * isDomainOrSubdomain reports whether sub is a subdomain (or exact match) of
   * the parent domain.
   *
   * Both domains must already be in canonical form.
   * @param {string|URL} original
   * @param {string|URL} destination
   */
  const isDomainOrSubdomain = (destination, original) => {
  	const orig = new URL(original).hostname;
  	const dest = new URL(destination).hostname;

  	return orig === dest || orig.endsWith(`.${dest}`);
  };

  /**
   * isSameProtocol reports whether the two provided URLs use the same protocol.
   *
   * Both domains must already be in canonical form.
   * @param {string|URL} original
   * @param {string|URL} destination
   */
  const isSameProtocol = (destination, original) => {
  	const orig = new URL(original).protocol;
  	const dest = new URL(destination).protocol;

  	return orig === dest;
  };

  const pipeline$1 = node_util.promisify(Stream__default["default"].pipeline);
  const INTERNALS$2 = Symbol('Body internals');

  /**
   * Body mixin
   *
   * Ref: https://fetch.spec.whatwg.org/#body
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */
  class Body {
  	constructor(body, {
  		size = 0
  	} = {}) {
  		let boundary = null;

  		if (body === null) {
  			// Body is undefined or null
  			body = null;
  		} else if (isURLSearchParameters(body)) {
  			// Body is a URLSearchParams
  			body = node_buffer.Buffer.from(body.toString());
  		} else if (isBlob(body)) ; else if (node_buffer.Buffer.isBuffer(body)) ; else if (node_util.types.isAnyArrayBuffer(body)) {
  			// Body is ArrayBuffer
  			body = node_buffer.Buffer.from(body);
  		} else if (ArrayBuffer.isView(body)) {
  			// Body is ArrayBufferView
  			body = node_buffer.Buffer.from(body.buffer, body.byteOffset, body.byteLength);
  		} else if (body instanceof Stream__default["default"]) ; else if (body instanceof FormData) {
  			// Body is FormData
  			body = formDataToBlob(body);
  			boundary = body.type.split('=')[1];
  		} else {
  			// None of the above
  			// coerce to string then buffer
  			body = node_buffer.Buffer.from(String(body));
  		}

  		let stream = body;

  		if (node_buffer.Buffer.isBuffer(body)) {
  			stream = Stream__default["default"].Readable.from(body);
  		} else if (isBlob(body)) {
  			stream = Stream__default["default"].Readable.from(body.stream());
  		}

  		this[INTERNALS$2] = {
  			body,
  			stream,
  			boundary,
  			disturbed: false,
  			error: null
  		};
  		this.size = size;

  		if (body instanceof Stream__default["default"]) {
  			body.on('error', error_ => {
  				const error = error_ instanceof FetchBaseError ?
  					error_ :
  					new FetchError(`Invalid response body while trying to fetch ${this.url}: ${error_.message}`, 'system', error_);
  				this[INTERNALS$2].error = error;
  			});
  		}
  	}

  	get body() {
  		return this[INTERNALS$2].stream;
  	}

  	get bodyUsed() {
  		return this[INTERNALS$2].disturbed;
  	}

  	/**
  	 * Decode response as ArrayBuffer
  	 *
  	 * @return  Promise
  	 */
  	async arrayBuffer() {
  		const {buffer, byteOffset, byteLength} = await consumeBody(this);
  		return buffer.slice(byteOffset, byteOffset + byteLength);
  	}

  	async formData() {
  		const ct = this.headers.get('content-type');

  		if (ct.startsWith('application/x-www-form-urlencoded')) {
  			const formData = new FormData();
  			const parameters = new URLSearchParams(await this.text());

  			for (const [name, value] of parameters) {
  				formData.append(name, value);
  			}

  			return formData;
  		}

  		const {toFormData} = await Promise.resolve().then(function () { return multipartParser; });
  		return toFormData(this.body, ct);
  	}

  	/**
  	 * Return raw response as Blob
  	 *
  	 * @return Promise
  	 */
  	async blob() {
  		const ct = (this.headers && this.headers.get('content-type')) || (this[INTERNALS$2].body && this[INTERNALS$2].body.type) || '';
  		const buf = await this.arrayBuffer();

  		return new Blob([buf], {
  			type: ct
  		});
  	}

  	/**
  	 * Decode response as json
  	 *
  	 * @return  Promise
  	 */
  	async json() {
  		const text = await this.text();
  		return JSON.parse(text);
  	}

  	/**
  	 * Decode response as text
  	 *
  	 * @return  Promise
  	 */
  	async text() {
  		const buffer = await consumeBody(this);
  		return new TextDecoder().decode(buffer);
  	}

  	/**
  	 * Decode response as buffer (non-spec api)
  	 *
  	 * @return  Promise
  	 */
  	buffer() {
  		return consumeBody(this);
  	}
  }

  Body.prototype.buffer = node_util.deprecate(Body.prototype.buffer, 'Please use \'response.arrayBuffer()\' instead of \'response.buffer()\'', 'node-fetch#buffer');

  // In browsers, all properties are enumerable.
  Object.defineProperties(Body.prototype, {
  	body: {enumerable: true},
  	bodyUsed: {enumerable: true},
  	arrayBuffer: {enumerable: true},
  	blob: {enumerable: true},
  	json: {enumerable: true},
  	text: {enumerable: true},
  	data: {get: node_util.deprecate(() => {},
  		'data doesn\'t exist, use json(), text(), arrayBuffer(), or body instead',
  		'https://github.com/node-fetch/node-fetch/issues/1000 (response)')}
  });

  /**
   * Consume and convert an entire Body to a Buffer.
   *
   * Ref: https://fetch.spec.whatwg.org/#concept-body-consume-body
   *
   * @return Promise
   */
  async function consumeBody(data) {
  	if (data[INTERNALS$2].disturbed) {
  		throw new TypeError(`body used already for: ${data.url}`);
  	}

  	data[INTERNALS$2].disturbed = true;

  	if (data[INTERNALS$2].error) {
  		throw data[INTERNALS$2].error;
  	}

  	const {body} = data;

  	// Body is null
  	if (body === null) {
  		return node_buffer.Buffer.alloc(0);
  	}

  	/* c8 ignore next 3 */
  	if (!(body instanceof Stream__default["default"])) {
  		return node_buffer.Buffer.alloc(0);
  	}

  	// Body is stream
  	// get ready to actually consume the body
  	const accum = [];
  	let accumBytes = 0;

  	try {
  		for await (const chunk of body) {
  			if (data.size > 0 && accumBytes + chunk.length > data.size) {
  				const error = new FetchError(`content size at ${data.url} over limit: ${data.size}`, 'max-size');
  				body.destroy(error);
  				throw error;
  			}

  			accumBytes += chunk.length;
  			accum.push(chunk);
  		}
  	} catch (error) {
  		const error_ = error instanceof FetchBaseError ? error : new FetchError(`Invalid response body while trying to fetch ${data.url}: ${error.message}`, 'system', error);
  		throw error_;
  	}

  	if (body.readableEnded === true || body._readableState.ended === true) {
  		try {
  			if (accum.every(c => typeof c === 'string')) {
  				return node_buffer.Buffer.from(accum.join(''));
  			}

  			return node_buffer.Buffer.concat(accum, accumBytes);
  		} catch (error) {
  			throw new FetchError(`Could not create Buffer from response body for ${data.url}: ${error.message}`, 'system', error);
  		}
  	} else {
  		throw new FetchError(`Premature close of server response while trying to fetch ${data.url}`);
  	}
  }

  /**
   * Clone body given Res/Req instance
   *
   * @param   Mixed   instance       Response or Request instance
   * @param   String  highWaterMark  highWaterMark for both PassThrough body streams
   * @return  Mixed
   */
  const clone = (instance, highWaterMark) => {
  	let p1;
  	let p2;
  	let {body} = instance[INTERNALS$2];

  	// Don't allow cloning a used body
  	if (instance.bodyUsed) {
  		throw new Error('cannot clone body after it is used');
  	}

  	// Check that body is a stream and not form-data object
  	// note: we can't clone the form-data object without having it as a dependency
  	if ((body instanceof Stream__default["default"]) && (typeof body.getBoundary !== 'function')) {
  		// Tee instance body
  		p1 = new Stream.PassThrough({highWaterMark});
  		p2 = new Stream.PassThrough({highWaterMark});
  		body.pipe(p1);
  		body.pipe(p2);
  		// Set instance body to teed body and return the other teed body
  		instance[INTERNALS$2].stream = p1;
  		body = p2;
  	}

  	return body;
  };

  const getNonSpecFormDataBoundary = node_util.deprecate(
  	body => body.getBoundary(),
  	'form-data doesn\'t follow the spec and requires special treatment. Use alternative package',
  	'https://github.com/node-fetch/node-fetch/issues/1167'
  );

  /**
   * Performs the operation "extract a `Content-Type` value from |object|" as
   * specified in the specification:
   * https://fetch.spec.whatwg.org/#concept-bodyinit-extract
   *
   * This function assumes that instance.body is present.
   *
   * @param {any} body Any options.body input
   * @returns {string | null}
   */
  const extractContentType = (body, request) => {
  	// Body is null or undefined
  	if (body === null) {
  		return null;
  	}

  	// Body is string
  	if (typeof body === 'string') {
  		return 'text/plain;charset=UTF-8';
  	}

  	// Body is a URLSearchParams
  	if (isURLSearchParameters(body)) {
  		return 'application/x-www-form-urlencoded;charset=UTF-8';
  	}

  	// Body is blob
  	if (isBlob(body)) {
  		return body.type || null;
  	}

  	// Body is a Buffer (Buffer, ArrayBuffer or ArrayBufferView)
  	if (node_buffer.Buffer.isBuffer(body) || node_util.types.isAnyArrayBuffer(body) || ArrayBuffer.isView(body)) {
  		return null;
  	}

  	if (body instanceof FormData) {
  		return `multipart/form-data; boundary=${request[INTERNALS$2].boundary}`;
  	}

  	// Detect form data input from form-data module
  	if (body && typeof body.getBoundary === 'function') {
  		return `multipart/form-data;boundary=${getNonSpecFormDataBoundary(body)}`;
  	}

  	// Body is stream - can't really do much about this
  	if (body instanceof Stream__default["default"]) {
  		return null;
  	}

  	// Body constructor defaults other things to string
  	return 'text/plain;charset=UTF-8';
  };

  /**
   * The Fetch Standard treats this as if "total bytes" is a property on the body.
   * For us, we have to explicitly get it with a function.
   *
   * ref: https://fetch.spec.whatwg.org/#concept-body-total-bytes
   *
   * @param {any} obj.body Body object from the Body instance.
   * @returns {number | null}
   */
  const getTotalBytes = request => {
  	const {body} = request[INTERNALS$2];

  	// Body is null or undefined
  	if (body === null) {
  		return 0;
  	}

  	// Body is Blob
  	if (isBlob(body)) {
  		return body.size;
  	}

  	// Body is Buffer
  	if (node_buffer.Buffer.isBuffer(body)) {
  		return body.length;
  	}

  	// Detect form data input from form-data module
  	if (body && typeof body.getLengthSync === 'function') {
  		return body.hasKnownLength && body.hasKnownLength() ? body.getLengthSync() : null;
  	}

  	// Body is stream
  	return null;
  };

  /**
   * Write a Body to a Node.js WritableStream (e.g. http.Request) object.
   *
   * @param {Stream.Writable} dest The stream to write to.
   * @param obj.body Body object from the Body instance.
   * @returns {Promise<void>}
   */
  const writeToStream = async (dest, {body}) => {
  	if (body === null) {
  		// Body is null
  		dest.end();
  	} else {
  		// Body is stream
  		await pipeline$1(body, dest);
  	}
  };

  /**
   * Headers.js
   *
   * Headers class offers convenient helpers
   */

  /* c8 ignore next 9 */
  const validateHeaderName = typeof http__default["default"].validateHeaderName === 'function' ?
  	http__default["default"].validateHeaderName :
  	name => {
  		if (!/^[\^`\-\w!#$%&'*+.|~]+$/.test(name)) {
  			const error = new TypeError(`Header name must be a valid HTTP token [${name}]`);
  			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_HTTP_TOKEN'});
  			throw error;
  		}
  	};

  /* c8 ignore next 9 */
  const validateHeaderValue = typeof http__default["default"].validateHeaderValue === 'function' ?
  	http__default["default"].validateHeaderValue :
  	(name, value) => {
  		if (/[^\t\u0020-\u007E\u0080-\u00FF]/.test(value)) {
  			const error = new TypeError(`Invalid character in header content ["${name}"]`);
  			Object.defineProperty(error, 'code', {value: 'ERR_INVALID_CHAR'});
  			throw error;
  		}
  	};

  /**
   * @typedef {Headers | Record<string, string> | Iterable<readonly [string, string]> | Iterable<Iterable<string>>} HeadersInit
   */

  /**
   * This Fetch API interface allows you to perform various actions on HTTP request and response headers.
   * These actions include retrieving, setting, adding to, and removing.
   * A Headers object has an associated header list, which is initially empty and consists of zero or more name and value pairs.
   * You can add to this using methods like append() (see Examples.)
   * In all methods of this interface, header names are matched by case-insensitive byte sequence.
   *
   */
  class Headers extends URLSearchParams {
  	/**
  	 * Headers class
  	 *
  	 * @constructor
  	 * @param {HeadersInit} [init] - Response headers
  	 */
  	constructor(init) {
  		// Validate and normalize init object in [name, value(s)][]
  		/** @type {string[][]} */
  		let result = [];
  		if (init instanceof Headers) {
  			const raw = init.raw();
  			for (const [name, values] of Object.entries(raw)) {
  				result.push(...values.map(value => [name, value]));
  			}
  		} else if (init == null) ; else if (typeof init === 'object' && !node_util.types.isBoxedPrimitive(init)) {
  			const method = init[Symbol.iterator];
  			// eslint-disable-next-line no-eq-null, eqeqeq
  			if (method == null) {
  				// Record<ByteString, ByteString>
  				result.push(...Object.entries(init));
  			} else {
  				if (typeof method !== 'function') {
  					throw new TypeError('Header pairs must be iterable');
  				}

  				// Sequence<sequence<ByteString>>
  				// Note: per spec we have to first exhaust the lists then process them
  				result = [...init]
  					.map(pair => {
  						if (
  							typeof pair !== 'object' || node_util.types.isBoxedPrimitive(pair)
  						) {
  							throw new TypeError('Each header pair must be an iterable object');
  						}

  						return [...pair];
  					}).map(pair => {
  						if (pair.length !== 2) {
  							throw new TypeError('Each header pair must be a name/value tuple');
  						}

  						return [...pair];
  					});
  			}
  		} else {
  			throw new TypeError('Failed to construct \'Headers\': The provided value is not of type \'(sequence<sequence<ByteString>> or record<ByteString, ByteString>)');
  		}

  		// Validate and lowercase
  		result =
  			result.length > 0 ?
  				result.map(([name, value]) => {
  					validateHeaderName(name);
  					validateHeaderValue(name, String(value));
  					return [String(name).toLowerCase(), String(value)];
  				}) :
  				undefined;

  		super(result);

  		// Returning a Proxy that will lowercase key names, validate parameters and sort keys
  		// eslint-disable-next-line no-constructor-return
  		return new Proxy(this, {
  			get(target, p, receiver) {
  				switch (p) {
  					case 'append':
  					case 'set':
  						return (name, value) => {
  							validateHeaderName(name);
  							validateHeaderValue(name, String(value));
  							return URLSearchParams.prototype[p].call(
  								target,
  								String(name).toLowerCase(),
  								String(value)
  							);
  						};

  					case 'delete':
  					case 'has':
  					case 'getAll':
  						return name => {
  							validateHeaderName(name);
  							return URLSearchParams.prototype[p].call(
  								target,
  								String(name).toLowerCase()
  							);
  						};

  					case 'keys':
  						return () => {
  							target.sort();
  							return new Set(URLSearchParams.prototype.keys.call(target)).keys();
  						};

  					default:
  						return Reflect.get(target, p, receiver);
  				}
  			}
  		});
  		/* c8 ignore next */
  	}

  	get [Symbol.toStringTag]() {
  		return this.constructor.name;
  	}

  	toString() {
  		return Object.prototype.toString.call(this);
  	}

  	get(name) {
  		const values = this.getAll(name);
  		if (values.length === 0) {
  			return null;
  		}

  		let value = values.join(', ');
  		if (/^content-encoding$/i.test(name)) {
  			value = value.toLowerCase();
  		}

  		return value;
  	}

  	forEach(callback, thisArg = undefined) {
  		for (const name of this.keys()) {
  			Reflect.apply(callback, thisArg, [this.get(name), name, this]);
  		}
  	}

  	* values() {
  		for (const name of this.keys()) {
  			yield this.get(name);
  		}
  	}

  	/**
  	 * @type {() => IterableIterator<[string, string]>}
  	 */
  	* entries() {
  		for (const name of this.keys()) {
  			yield [name, this.get(name)];
  		}
  	}

  	[Symbol.iterator]() {
  		return this.entries();
  	}

  	/**
  	 * Node-fetch non-spec method
  	 * returning all headers and their values as array
  	 * @returns {Record<string, string[]>}
  	 */
  	raw() {
  		return [...this.keys()].reduce((result, key) => {
  			result[key] = this.getAll(key);
  			return result;
  		}, {});
  	}

  	/**
  	 * For better console.log(headers) and also to convert Headers into Node.js Request compatible format
  	 */
  	[Symbol.for('nodejs.util.inspect.custom')]() {
  		return [...this.keys()].reduce((result, key) => {
  			const values = this.getAll(key);
  			// Http.request() only supports string as Host header.
  			// This hack makes specifying custom Host header possible.
  			if (key === 'host') {
  				result[key] = values[0];
  			} else {
  				result[key] = values.length > 1 ? values : values[0];
  			}

  			return result;
  		}, {});
  	}
  }

  /**
   * Re-shaping object for Web IDL tests
   * Only need to do it for overridden methods
   */
  Object.defineProperties(
  	Headers.prototype,
  	['get', 'entries', 'forEach', 'values'].reduce((result, property) => {
  		result[property] = {enumerable: true};
  		return result;
  	}, {})
  );

  /**
   * Create a Headers object from an http.IncomingMessage.rawHeaders, ignoring those that do
   * not conform to HTTP grammar productions.
   * @param {import('http').IncomingMessage['rawHeaders']} headers
   */
  function fromRawHeaders(headers = []) {
  	return new Headers(
  		headers
  			// Split into pairs
  			.reduce((result, value, index, array) => {
  				if (index % 2 === 0) {
  					result.push(array.slice(index, index + 2));
  				}

  				return result;
  			}, [])
  			.filter(([name, value]) => {
  				try {
  					validateHeaderName(name);
  					validateHeaderValue(name, String(value));
  					return true;
  				} catch {
  					return false;
  				}
  			})

  	);
  }

  const redirectStatus = new Set([301, 302, 303, 307, 308]);

  /**
   * Redirect code matching
   *
   * @param {number} code - Status code
   * @return {boolean}
   */
  const isRedirect = code => {
  	return redirectStatus.has(code);
  };

  /**
   * Response.js
   *
   * Response class provides content decoding
   */

  const INTERNALS$1 = Symbol('Response internals');

  /**
   * Response class
   *
   * Ref: https://fetch.spec.whatwg.org/#response-class
   *
   * @param   Stream  body  Readable stream
   * @param   Object  opts  Response options
   * @return  Void
   */
  class Response extends Body {
  	constructor(body = null, options = {}) {
  		super(body, options);

  		// eslint-disable-next-line no-eq-null, eqeqeq, no-negated-condition
  		const status = options.status != null ? options.status : 200;

  		const headers = new Headers(options.headers);

  		if (body !== null && !headers.has('Content-Type')) {
  			const contentType = extractContentType(body, this);
  			if (contentType) {
  				headers.append('Content-Type', contentType);
  			}
  		}

  		this[INTERNALS$1] = {
  			type: 'default',
  			url: options.url,
  			status,
  			statusText: options.statusText || '',
  			headers,
  			counter: options.counter,
  			highWaterMark: options.highWaterMark
  		};
  	}

  	get type() {
  		return this[INTERNALS$1].type;
  	}

  	get url() {
  		return this[INTERNALS$1].url || '';
  	}

  	get status() {
  		return this[INTERNALS$1].status;
  	}

  	/**
  	 * Convenience property representing if the request ended normally
  	 */
  	get ok() {
  		return this[INTERNALS$1].status >= 200 && this[INTERNALS$1].status < 300;
  	}

  	get redirected() {
  		return this[INTERNALS$1].counter > 0;
  	}

  	get statusText() {
  		return this[INTERNALS$1].statusText;
  	}

  	get headers() {
  		return this[INTERNALS$1].headers;
  	}

  	get highWaterMark() {
  		return this[INTERNALS$1].highWaterMark;
  	}

  	/**
  	 * Clone this response
  	 *
  	 * @return  Response
  	 */
  	clone() {
  		return new Response(clone(this, this.highWaterMark), {
  			type: this.type,
  			url: this.url,
  			status: this.status,
  			statusText: this.statusText,
  			headers: this.headers,
  			ok: this.ok,
  			redirected: this.redirected,
  			size: this.size,
  			highWaterMark: this.highWaterMark
  		});
  	}

  	/**
  	 * @param {string} url    The URL that the new response is to originate from.
  	 * @param {number} status An optional status code for the response (e.g., 302.)
  	 * @returns {Response}    A Response object.
  	 */
  	static redirect(url, status = 302) {
  		if (!isRedirect(status)) {
  			throw new RangeError('Failed to execute "redirect" on "response": Invalid status code');
  		}

  		return new Response(null, {
  			headers: {
  				location: new URL(url).toString()
  			},
  			status
  		});
  	}

  	static error() {
  		const response = new Response(null, {status: 0, statusText: ''});
  		response[INTERNALS$1].type = 'error';
  		return response;
  	}

  	get [Symbol.toStringTag]() {
  		return 'Response';
  	}
  }

  Object.defineProperties(Response.prototype, {
  	type: {enumerable: true},
  	url: {enumerable: true},
  	status: {enumerable: true},
  	ok: {enumerable: true},
  	redirected: {enumerable: true},
  	statusText: {enumerable: true},
  	headers: {enumerable: true},
  	clone: {enumerable: true}
  });

  const getSearch = parsedURL => {
  	if (parsedURL.search) {
  		return parsedURL.search;
  	}

  	const lastOffset = parsedURL.href.length - 1;
  	const hash = parsedURL.hash || (parsedURL.href[lastOffset] === '#' ? '#' : '');
  	return parsedURL.href[lastOffset - hash.length] === '?' ? '?' : '';
  };

  /**
   * @external URL
   * @see {@link https://developer.mozilla.org/en-US/docs/Web/API/URL|URL}
   */

  /**
   * @module utils/referrer
   * @private
   */

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#strip-url|Referrer Policy 8.4. Strip url for use as a referrer}
   * @param {string} URL
   * @param {boolean} [originOnly=false]
   */
  function stripURLForUseAsAReferrer(url, originOnly = false) {
  	// 1. If url is null, return no referrer.
  	if (url == null) { // eslint-disable-line no-eq-null, eqeqeq
  		return 'no-referrer';
  	}

  	url = new URL(url);

  	// 2. If url's scheme is a local scheme, then return no referrer.
  	if (/^(about|blob|data):$/.test(url.protocol)) {
  		return 'no-referrer';
  	}

  	// 3. Set url's username to the empty string.
  	url.username = '';

  	// 4. Set url's password to null.
  	// Note: `null` appears to be a mistake as this actually results in the password being `"null"`.
  	url.password = '';

  	// 5. Set url's fragment to null.
  	// Note: `null` appears to be a mistake as this actually results in the fragment being `"#null"`.
  	url.hash = '';

  	// 6. If the origin-only flag is true, then:
  	if (originOnly) {
  		// 6.1. Set url's path to null.
  		// Note: `null` appears to be a mistake as this actually results in the path being `"/null"`.
  		url.pathname = '';

  		// 6.2. Set url's query to null.
  		// Note: `null` appears to be a mistake as this actually results in the query being `"?null"`.
  		url.search = '';
  	}

  	// 7. Return url.
  	return url;
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#enumdef-referrerpolicy|enum ReferrerPolicy}
   */
  const ReferrerPolicy = new Set([
  	'',
  	'no-referrer',
  	'no-referrer-when-downgrade',
  	'same-origin',
  	'origin',
  	'strict-origin',
  	'origin-when-cross-origin',
  	'strict-origin-when-cross-origin',
  	'unsafe-url'
  ]);

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#default-referrer-policy|default referrer policy}
   */
  const DEFAULT_REFERRER_POLICY = 'strict-origin-when-cross-origin';

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#referrer-policies|Referrer Policy 3. Referrer Policies}
   * @param {string} referrerPolicy
   * @returns {string} referrerPolicy
   */
  function validateReferrerPolicy(referrerPolicy) {
  	if (!ReferrerPolicy.has(referrerPolicy)) {
  		throw new TypeError(`Invalid referrerPolicy: ${referrerPolicy}`);
  	}

  	return referrerPolicy;
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-origin-trustworthy|Referrer Policy 3.2. Is origin potentially trustworthy?}
   * @param {external:URL} url
   * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
   */
  function isOriginPotentiallyTrustworthy(url) {
  	// 1. If origin is an opaque origin, return "Not Trustworthy".
  	// Not applicable

  	// 2. Assert: origin is a tuple origin.
  	// Not for implementations

  	// 3. If origin's scheme is either "https" or "wss", return "Potentially Trustworthy".
  	if (/^(http|ws)s:$/.test(url.protocol)) {
  		return true;
  	}

  	// 4. If origin's host component matches one of the CIDR notations 127.0.0.0/8 or ::1/128 [RFC4632], return "Potentially Trustworthy".
  	const hostIp = url.host.replace(/(^\[)|(]$)/g, '');
  	const hostIPVersion = node_net.isIP(hostIp);

  	if (hostIPVersion === 4 && /^127\./.test(hostIp)) {
  		return true;
  	}

  	if (hostIPVersion === 6 && /^(((0+:){7})|(::(0+:){0,6}))0*1$/.test(hostIp)) {
  		return true;
  	}

  	// 5. If origin's host component is "localhost" or falls within ".localhost", and the user agent conforms to the name resolution rules in [let-localhost-be-localhost], return "Potentially Trustworthy".
  	// We are returning FALSE here because we cannot ensure conformance to
  	// let-localhost-be-loalhost (https://tools.ietf.org/html/draft-west-let-localhost-be-localhost)
  	if (url.host === 'localhost' || url.host.endsWith('.localhost')) {
  		return false;
  	}

  	// 6. If origin's scheme component is file, return "Potentially Trustworthy".
  	if (url.protocol === 'file:') {
  		return true;
  	}

  	// 7. If origin's scheme component is one which the user agent considers to be authenticated, return "Potentially Trustworthy".
  	// Not supported

  	// 8. If origin has been configured as a trustworthy origin, return "Potentially Trustworthy".
  	// Not supported

  	// 9. Return "Not Trustworthy".
  	return false;
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-secure-contexts/#is-url-trustworthy|Referrer Policy 3.3. Is url potentially trustworthy?}
   * @param {external:URL} url
   * @returns `true`: "Potentially Trustworthy", `false`: "Not Trustworthy"
   */
  function isUrlPotentiallyTrustworthy(url) {
  	// 1. If url is "about:blank" or "about:srcdoc", return "Potentially Trustworthy".
  	if (/^about:(blank|srcdoc)$/.test(url)) {
  		return true;
  	}

  	// 2. If url's scheme is "data", return "Potentially Trustworthy".
  	if (url.protocol === 'data:') {
  		return true;
  	}

  	// Note: The origin of blob: and filesystem: URLs is the origin of the context in which they were
  	// created. Therefore, blobs created in a trustworthy origin will themselves be potentially
  	// trustworthy.
  	if (/^(blob|filesystem):$/.test(url.protocol)) {
  		return true;
  	}

  	// 3. Return the result of executing 3.2 Is origin potentially trustworthy? on url's origin.
  	return isOriginPotentiallyTrustworthy(url);
  }

  /**
   * Modifies the referrerURL to enforce any extra security policy considerations.
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7
   * @callback module:utils/referrer~referrerURLCallback
   * @param {external:URL} referrerURL
   * @returns {external:URL} modified referrerURL
   */

  /**
   * Modifies the referrerOrigin to enforce any extra security policy considerations.
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}, step 7
   * @callback module:utils/referrer~referrerOriginCallback
   * @param {external:URL} referrerOrigin
   * @returns {external:URL} modified referrerOrigin
   */

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#determine-requests-referrer|Referrer Policy 8.3. Determine request's Referrer}
   * @param {Request} request
   * @param {object} o
   * @param {module:utils/referrer~referrerURLCallback} o.referrerURLCallback
   * @param {module:utils/referrer~referrerOriginCallback} o.referrerOriginCallback
   * @returns {external:URL} Request's referrer
   */
  function determineRequestsReferrer(request, {referrerURLCallback, referrerOriginCallback} = {}) {
  	// There are 2 notes in the specification about invalid pre-conditions.  We return null, here, for
  	// these cases:
  	// > Note: If request's referrer is "no-referrer", Fetch will not call into this algorithm.
  	// > Note: If request's referrer policy is the empty string, Fetch will not call into this
  	// > algorithm.
  	if (request.referrer === 'no-referrer' || request.referrerPolicy === '') {
  		return null;
  	}

  	// 1. Let policy be request's associated referrer policy.
  	const policy = request.referrerPolicy;

  	// 2. Let environment be request's client.
  	// not applicable to node.js

  	// 3. Switch on request's referrer:
  	if (request.referrer === 'about:client') {
  		return 'no-referrer';
  	}

  	// "a URL": Let referrerSource be request's referrer.
  	const referrerSource = request.referrer;

  	// 4. Let request's referrerURL be the result of stripping referrerSource for use as a referrer.
  	let referrerURL = stripURLForUseAsAReferrer(referrerSource);

  	// 5. Let referrerOrigin be the result of stripping referrerSource for use as a referrer, with the
  	//    origin-only flag set to true.
  	let referrerOrigin = stripURLForUseAsAReferrer(referrerSource, true);

  	// 6. If the result of serializing referrerURL is a string whose length is greater than 4096, set
  	//    referrerURL to referrerOrigin.
  	if (referrerURL.toString().length > 4096) {
  		referrerURL = referrerOrigin;
  	}

  	// 7. The user agent MAY alter referrerURL or referrerOrigin at this point to enforce arbitrary
  	//    policy considerations in the interests of minimizing data leakage. For example, the user
  	//    agent could strip the URL down to an origin, modify its host, replace it with an empty
  	//    string, etc.
  	if (referrerURLCallback) {
  		referrerURL = referrerURLCallback(referrerURL);
  	}

  	if (referrerOriginCallback) {
  		referrerOrigin = referrerOriginCallback(referrerOrigin);
  	}

  	// 8.Execute the statements corresponding to the value of policy:
  	const currentURL = new URL(request.url);

  	switch (policy) {
  		case 'no-referrer':
  			return 'no-referrer';

  		case 'origin':
  			return referrerOrigin;

  		case 'unsafe-url':
  			return referrerURL;

  		case 'strict-origin':
  			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
  			//    potentially trustworthy URL, then return no referrer.
  			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
  				return 'no-referrer';
  			}

  			// 2. Return referrerOrigin.
  			return referrerOrigin.toString();

  		case 'strict-origin-when-cross-origin':
  			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
  			//    return referrerURL.
  			if (referrerURL.origin === currentURL.origin) {
  				return referrerURL;
  			}

  			// 2. If referrerURL is a potentially trustworthy URL and request's current URL is not a
  			//    potentially trustworthy URL, then return no referrer.
  			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
  				return 'no-referrer';
  			}

  			// 3. Return referrerOrigin.
  			return referrerOrigin;

  		case 'same-origin':
  			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
  			//    return referrerURL.
  			if (referrerURL.origin === currentURL.origin) {
  				return referrerURL;
  			}

  			// 2. Return no referrer.
  			return 'no-referrer';

  		case 'origin-when-cross-origin':
  			// 1. If the origin of referrerURL and the origin of request's current URL are the same, then
  			//    return referrerURL.
  			if (referrerURL.origin === currentURL.origin) {
  				return referrerURL;
  			}

  			// Return referrerOrigin.
  			return referrerOrigin;

  		case 'no-referrer-when-downgrade':
  			// 1. If referrerURL is a potentially trustworthy URL and request's current URL is not a
  			//    potentially trustworthy URL, then return no referrer.
  			if (isUrlPotentiallyTrustworthy(referrerURL) && !isUrlPotentiallyTrustworthy(currentURL)) {
  				return 'no-referrer';
  			}

  			// 2. Return referrerURL.
  			return referrerURL;

  		default:
  			throw new TypeError(`Invalid referrerPolicy: ${policy}`);
  	}
  }

  /**
   * @see {@link https://w3c.github.io/webappsec-referrer-policy/#parse-referrer-policy-from-header|Referrer Policy 8.1. Parse a referrer policy from a Referrer-Policy header}
   * @param {Headers} headers Response headers
   * @returns {string} policy
   */
  function parseReferrerPolicyFromHeader(headers) {
  	// 1. Let policy-tokens be the result of extracting header list values given `Referrer-Policy`
  	//    and responses header list.
  	const policyTokens = (headers.get('referrer-policy') || '').split(/[,\s]+/);

  	// 2. Let policy be the empty string.
  	let policy = '';

  	// 3. For each token in policy-tokens, if token is a referrer policy and token is not the empty
  	//    string, then set policy to token.
  	// Note: This algorithm loops over multiple policy values to allow deployment of new policy
  	// values with fallbacks for older user agents, as described in  11.1 Unknown Policy Values.
  	for (const token of policyTokens) {
  		if (token && ReferrerPolicy.has(token)) {
  			policy = token;
  		}
  	}

  	// 4. Return policy.
  	return policy;
  }

  /**
   * Request.js
   *
   * Request class contains server only options
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  const INTERNALS = Symbol('Request internals');

  /**
   * Check if `obj` is an instance of Request.
   *
   * @param  {*} object
   * @return {boolean}
   */
  const isRequest = object => {
  	return (
  		typeof object === 'object' &&
  		typeof object[INTERNALS] === 'object'
  	);
  };

  const doBadDataWarn = node_util.deprecate(() => {},
  	'.data is not a valid RequestInit property, use .body instead',
  	'https://github.com/node-fetch/node-fetch/issues/1000 (request)');

  /**
   * Request class
   *
   * Ref: https://fetch.spec.whatwg.org/#request-class
   *
   * @param   Mixed   input  Url or Request instance
   * @param   Object  init   Custom options
   * @return  Void
   */
  class Request extends Body {
  	constructor(input, init = {}) {
  		let parsedURL;

  		// Normalize input and force URL to be encoded as UTF-8 (https://github.com/node-fetch/node-fetch/issues/245)
  		if (isRequest(input)) {
  			parsedURL = new URL(input.url);
  		} else {
  			parsedURL = new URL(input);
  			input = {};
  		}

  		if (parsedURL.username !== '' || parsedURL.password !== '') {
  			throw new TypeError(`${parsedURL} is an url with embedded credentials.`);
  		}

  		let method = init.method || input.method || 'GET';
  		if (/^(delete|get|head|options|post|put)$/i.test(method)) {
  			method = method.toUpperCase();
  		}

  		if (!isRequest(init) && 'data' in init) {
  			doBadDataWarn();
  		}

  		// eslint-disable-next-line no-eq-null, eqeqeq
  		if ((init.body != null || (isRequest(input) && input.body !== null)) &&
  			(method === 'GET' || method === 'HEAD')) {
  			throw new TypeError('Request with GET/HEAD method cannot have body');
  		}

  		const inputBody = init.body ?
  			init.body :
  			(isRequest(input) && input.body !== null ?
  				clone(input) :
  				null);

  		super(inputBody, {
  			size: init.size || input.size || 0
  		});

  		const headers = new Headers(init.headers || input.headers || {});

  		if (inputBody !== null && !headers.has('Content-Type')) {
  			const contentType = extractContentType(inputBody, this);
  			if (contentType) {
  				headers.set('Content-Type', contentType);
  			}
  		}

  		let signal = isRequest(input) ?
  			input.signal :
  			null;
  		if ('signal' in init) {
  			signal = init.signal;
  		}

  		// eslint-disable-next-line no-eq-null, eqeqeq
  		if (signal != null && !isAbortSignal(signal)) {
  			throw new TypeError('Expected signal to be an instanceof AbortSignal or EventTarget');
  		}

  		// 5.4, Request constructor steps, step 15.1
  		// eslint-disable-next-line no-eq-null, eqeqeq
  		let referrer = init.referrer == null ? input.referrer : init.referrer;
  		if (referrer === '') {
  			// 5.4, Request constructor steps, step 15.2
  			referrer = 'no-referrer';
  		} else if (referrer) {
  			// 5.4, Request constructor steps, step 15.3.1, 15.3.2
  			const parsedReferrer = new URL(referrer);
  			// 5.4, Request constructor steps, step 15.3.3, 15.3.4
  			referrer = /^about:(\/\/)?client$/.test(parsedReferrer) ? 'client' : parsedReferrer;
  		} else {
  			referrer = undefined;
  		}

  		this[INTERNALS] = {
  			method,
  			redirect: init.redirect || input.redirect || 'follow',
  			headers,
  			parsedURL,
  			signal,
  			referrer
  		};

  		// Node-fetch-only options
  		this.follow = init.follow === undefined ? (input.follow === undefined ? 20 : input.follow) : init.follow;
  		this.compress = init.compress === undefined ? (input.compress === undefined ? true : input.compress) : init.compress;
  		this.counter = init.counter || input.counter || 0;
  		this.agent = init.agent || input.agent;
  		this.highWaterMark = init.highWaterMark || input.highWaterMark || 16384;
  		this.insecureHTTPParser = init.insecureHTTPParser || input.insecureHTTPParser || false;

  		// 5.4, Request constructor steps, step 16.
  		// Default is empty string per https://fetch.spec.whatwg.org/#concept-request-referrer-policy
  		this.referrerPolicy = init.referrerPolicy || input.referrerPolicy || '';
  	}

  	/** @returns {string} */
  	get method() {
  		return this[INTERNALS].method;
  	}

  	/** @returns {string} */
  	get url() {
  		return node_url.format(this[INTERNALS].parsedURL);
  	}

  	/** @returns {Headers} */
  	get headers() {
  		return this[INTERNALS].headers;
  	}

  	get redirect() {
  		return this[INTERNALS].redirect;
  	}

  	/** @returns {AbortSignal} */
  	get signal() {
  		return this[INTERNALS].signal;
  	}

  	// https://fetch.spec.whatwg.org/#dom-request-referrer
  	get referrer() {
  		if (this[INTERNALS].referrer === 'no-referrer') {
  			return '';
  		}

  		if (this[INTERNALS].referrer === 'client') {
  			return 'about:client';
  		}

  		if (this[INTERNALS].referrer) {
  			return this[INTERNALS].referrer.toString();
  		}

  		return undefined;
  	}

  	get referrerPolicy() {
  		return this[INTERNALS].referrerPolicy;
  	}

  	set referrerPolicy(referrerPolicy) {
  		this[INTERNALS].referrerPolicy = validateReferrerPolicy(referrerPolicy);
  	}

  	/**
  	 * Clone this request
  	 *
  	 * @return  Request
  	 */
  	clone() {
  		return new Request(this);
  	}

  	get [Symbol.toStringTag]() {
  		return 'Request';
  	}
  }

  Object.defineProperties(Request.prototype, {
  	method: {enumerable: true},
  	url: {enumerable: true},
  	headers: {enumerable: true},
  	redirect: {enumerable: true},
  	clone: {enumerable: true},
  	signal: {enumerable: true},
  	referrer: {enumerable: true},
  	referrerPolicy: {enumerable: true}
  });

  /**
   * Convert a Request to Node.js http request options.
   *
   * @param {Request} request - A Request instance
   * @return The options object to be passed to http.request
   */
  const getNodeRequestOptions = request => {
  	const {parsedURL} = request[INTERNALS];
  	const headers = new Headers(request[INTERNALS].headers);

  	// Fetch step 1.3
  	if (!headers.has('Accept')) {
  		headers.set('Accept', '*/*');
  	}

  	// HTTP-network-or-cache fetch steps 2.4-2.7
  	let contentLengthValue = null;
  	if (request.body === null && /^(post|put)$/i.test(request.method)) {
  		contentLengthValue = '0';
  	}

  	if (request.body !== null) {
  		const totalBytes = getTotalBytes(request);
  		// Set Content-Length if totalBytes is a number (that is not NaN)
  		if (typeof totalBytes === 'number' && !Number.isNaN(totalBytes)) {
  			contentLengthValue = String(totalBytes);
  		}
  	}

  	if (contentLengthValue) {
  		headers.set('Content-Length', contentLengthValue);
  	}

  	// 4.1. Main fetch, step 2.6
  	// > If request's referrer policy is the empty string, then set request's referrer policy to the
  	// > default referrer policy.
  	if (request.referrerPolicy === '') {
  		request.referrerPolicy = DEFAULT_REFERRER_POLICY;
  	}

  	// 4.1. Main fetch, step 2.7
  	// > If request's referrer is not "no-referrer", set request's referrer to the result of invoking
  	// > determine request's referrer.
  	if (request.referrer && request.referrer !== 'no-referrer') {
  		request[INTERNALS].referrer = determineRequestsReferrer(request);
  	} else {
  		request[INTERNALS].referrer = 'no-referrer';
  	}

  	// 4.5. HTTP-network-or-cache fetch, step 6.9
  	// > If httpRequest's referrer is a URL, then append `Referer`/httpRequest's referrer, serialized
  	// >  and isomorphic encoded, to httpRequest's header list.
  	if (request[INTERNALS].referrer instanceof URL) {
  		headers.set('Referer', request.referrer);
  	}

  	// HTTP-network-or-cache fetch step 2.11
  	if (!headers.has('User-Agent')) {
  		headers.set('User-Agent', 'node-fetch');
  	}

  	// HTTP-network-or-cache fetch step 2.15
  	if (request.compress && !headers.has('Accept-Encoding')) {
  		headers.set('Accept-Encoding', 'gzip, deflate, br');
  	}

  	let {agent} = request;
  	if (typeof agent === 'function') {
  		agent = agent(parsedURL);
  	}

  	if (!headers.has('Connection') && !agent) {
  		headers.set('Connection', 'close');
  	}

  	// HTTP-network fetch step 4.2
  	// chunked encoding is handled by Node.js

  	const search = getSearch(parsedURL);

  	// Pass the full URL directly to request(), but overwrite the following
  	// options:
  	const options = {
  		// Overwrite search to retain trailing ? (issue #776)
  		path: parsedURL.pathname + search,
  		// The following options are not expressed in the URL
  		method: request.method,
  		headers: headers[Symbol.for('nodejs.util.inspect.custom')](),
  		insecureHTTPParser: request.insecureHTTPParser,
  		agent
  	};

  	return {
  		/** @type {URL} */
  		parsedURL,
  		options
  	};
  };

  /**
   * AbortError interface for cancelled requests
   */
  class AbortError extends FetchBaseError {
  	constructor(message, type = 'aborted') {
  		super(message, type);
  	}
  }

  /*! node-domexception. MIT License. Jimmy Wrting <https://jimmy.warting.se/opensource> */

  if (!globalThis.DOMException) {
    try {
      const { MessageChannel } = require('worker_threads'),
      port = new MessageChannel().port1,
      ab = new ArrayBuffer();
      port.postMessage(ab, [ab, ab]);
    } catch (err) {
      err.constructor.name === 'DOMException' && (
        globalThis.DOMException = err.constructor
      );
    }
  }

  /**
   * Index.js
   *
   * a request API compatible with window.fetch
   *
   * All spec algorithm step numbers are based on https://fetch.spec.whatwg.org/commit-snapshots/ae716822cb3a61843226cd090eefc6589446c1d2/.
   */

  const supportedSchemas = new Set(['data:', 'http:', 'https:']);

  /**
   * Fetch function
   *
   * @param   {string | URL | import('./request').default} url - Absolute url or Request instance
   * @param   {*} [options_] - Fetch options
   * @return  {Promise<import('./response').default>}
   */
  async function fetch(url, options_) {
  	return new Promise((resolve, reject) => {
  		// Build request object
  		const request = new Request(url, options_);
  		const {parsedURL, options} = getNodeRequestOptions(request);
  		if (!supportedSchemas.has(parsedURL.protocol)) {
  			throw new TypeError(`node-fetch cannot load ${url}. URL scheme "${parsedURL.protocol.replace(/:$/, '')}" is not supported.`);
  		}

  		if (parsedURL.protocol === 'data:') {
  			const data = dataUriToBuffer(request.url);
  			const response = new Response(data, {headers: {'Content-Type': data.typeFull}});
  			resolve(response);
  			return;
  		}

  		// Wrap http.request into fetch
  		const send = (parsedURL.protocol === 'https:' ? https__default["default"] : http__default["default"]).request;
  		const {signal} = request;
  		let response = null;

  		const abort = () => {
  			const error = new AbortError('The operation was aborted.');
  			reject(error);
  			if (request.body && request.body instanceof Stream__default["default"].Readable) {
  				request.body.destroy(error);
  			}

  			if (!response || !response.body) {
  				return;
  			}

  			response.body.emit('error', error);
  		};

  		if (signal && signal.aborted) {
  			abort();
  			return;
  		}

  		const abortAndFinalize = () => {
  			abort();
  			finalize();
  		};

  		// Send request
  		const request_ = send(parsedURL.toString(), options);

  		if (signal) {
  			signal.addEventListener('abort', abortAndFinalize);
  		}

  		const finalize = () => {
  			request_.abort();
  			if (signal) {
  				signal.removeEventListener('abort', abortAndFinalize);
  			}
  		};

  		request_.on('error', error => {
  			reject(new FetchError(`request to ${request.url} failed, reason: ${error.message}`, 'system', error));
  			finalize();
  		});

  		fixResponseChunkedTransferBadEnding(request_, error => {
  			if (response && response.body) {
  				response.body.destroy(error);
  			}
  		});

  		/* c8 ignore next 18 */
  		if (process.version < 'v14') {
  			// Before Node.js 14, pipeline() does not fully support async iterators and does not always
  			// properly handle when the socket close/end events are out of order.
  			request_.on('socket', s => {
  				let endedWithEventsCount;
  				s.prependListener('end', () => {
  					endedWithEventsCount = s._eventsCount;
  				});
  				s.prependListener('close', hadError => {
  					// if end happened before close but the socket didn't emit an error, do it now
  					if (response && endedWithEventsCount < s._eventsCount && !hadError) {
  						const error = new Error('Premature close');
  						error.code = 'ERR_STREAM_PREMATURE_CLOSE';
  						response.body.emit('error', error);
  					}
  				});
  			});
  		}

  		request_.on('response', response_ => {
  			request_.setTimeout(0);
  			const headers = fromRawHeaders(response_.rawHeaders);

  			// HTTP fetch step 5
  			if (isRedirect(response_.statusCode)) {
  				// HTTP fetch step 5.2
  				const location = headers.get('Location');

  				// HTTP fetch step 5.3
  				let locationURL = null;
  				try {
  					locationURL = location === null ? null : new URL(location, request.url);
  				} catch {
  					// error here can only be invalid URL in Location: header
  					// do not throw when options.redirect == manual
  					// let the user extract the errorneous redirect URL
  					if (request.redirect !== 'manual') {
  						reject(new FetchError(`uri requested responds with an invalid redirect URL: ${location}`, 'invalid-redirect'));
  						finalize();
  						return;
  					}
  				}

  				// HTTP fetch step 5.5
  				switch (request.redirect) {
  					case 'error':
  						reject(new FetchError(`uri requested responds with a redirect, redirect mode is set to error: ${request.url}`, 'no-redirect'));
  						finalize();
  						return;
  					case 'manual':
  						// Nothing to do
  						break;
  					case 'follow': {
  						// HTTP-redirect fetch step 2
  						if (locationURL === null) {
  							break;
  						}

  						// HTTP-redirect fetch step 5
  						if (request.counter >= request.follow) {
  							reject(new FetchError(`maximum redirect reached at: ${request.url}`, 'max-redirect'));
  							finalize();
  							return;
  						}

  						// HTTP-redirect fetch step 6 (counter increment)
  						// Create a new Request object.
  						const requestOptions = {
  							headers: new Headers(request.headers),
  							follow: request.follow,
  							counter: request.counter + 1,
  							agent: request.agent,
  							compress: request.compress,
  							method: request.method,
  							body: clone(request),
  							signal: request.signal,
  							size: request.size,
  							referrer: request.referrer,
  							referrerPolicy: request.referrerPolicy
  						};

  						// when forwarding sensitive headers like "Authorization",
  						// "WWW-Authenticate", and "Cookie" to untrusted targets,
  						// headers will be ignored when following a redirect to a domain
  						// that is not a subdomain match or exact match of the initial domain.
  						// For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
  						// will forward the sensitive headers, but a redirect to "bar.com" will not.
  						// headers will also be ignored when following a redirect to a domain using
  						// a different protocol. For example, a redirect from "https://foo.com" to "http://foo.com"
  						// will not forward the sensitive headers
  						if (!isDomainOrSubdomain(request.url, locationURL) || !isSameProtocol(request.url, locationURL)) {
  							for (const name of ['authorization', 'www-authenticate', 'cookie', 'cookie2']) {
  								requestOptions.headers.delete(name);
  							}
  						}

  						// HTTP-redirect fetch step 9
  						if (response_.statusCode !== 303 && request.body && options_.body instanceof Stream__default["default"].Readable) {
  							reject(new FetchError('Cannot follow redirect with body being a readable stream', 'unsupported-redirect'));
  							finalize();
  							return;
  						}

  						// HTTP-redirect fetch step 11
  						if (response_.statusCode === 303 || ((response_.statusCode === 301 || response_.statusCode === 302) && request.method === 'POST')) {
  							requestOptions.method = 'GET';
  							requestOptions.body = undefined;
  							requestOptions.headers.delete('content-length');
  						}

  						// HTTP-redirect fetch step 14
  						const responseReferrerPolicy = parseReferrerPolicyFromHeader(headers);
  						if (responseReferrerPolicy) {
  							requestOptions.referrerPolicy = responseReferrerPolicy;
  						}

  						// HTTP-redirect fetch step 15
  						resolve(fetch(new Request(locationURL, requestOptions)));
  						finalize();
  						return;
  					}

  					default:
  						return reject(new TypeError(`Redirect option '${request.redirect}' is not a valid value of RequestRedirect`));
  				}
  			}

  			// Prepare response
  			if (signal) {
  				response_.once('end', () => {
  					signal.removeEventListener('abort', abortAndFinalize);
  				});
  			}

  			let body = Stream.pipeline(response_, new Stream.PassThrough(), error => {
  				if (error) {
  					reject(error);
  				}
  			});
  			// see https://github.com/nodejs/node/pull/29376
  			/* c8 ignore next 3 */
  			if (process.version < 'v12.10') {
  				response_.on('aborted', abortAndFinalize);
  			}

  			const responseOptions = {
  				url: request.url,
  				status: response_.statusCode,
  				statusText: response_.statusMessage,
  				headers,
  				size: request.size,
  				counter: request.counter,
  				highWaterMark: request.highWaterMark
  			};

  			// HTTP-network fetch step 12.1.1.3
  			const codings = headers.get('Content-Encoding');

  			// HTTP-network fetch step 12.1.1.4: handle content codings

  			// in following scenarios we ignore compression support
  			// 1. compression support is disabled
  			// 2. HEAD request
  			// 3. no Content-Encoding header
  			// 4. no content response (204)
  			// 5. content not modified response (304)
  			if (!request.compress || request.method === 'HEAD' || codings === null || response_.statusCode === 204 || response_.statusCode === 304) {
  				response = new Response(body, responseOptions);
  				resolve(response);
  				return;
  			}

  			// For Node v6+
  			// Be less strict when decoding compressed responses, since sometimes
  			// servers send slightly invalid responses that are still accepted
  			// by common browsers.
  			// Always using Z_SYNC_FLUSH is what cURL does.
  			const zlibOptions = {
  				flush: zlib__default["default"].Z_SYNC_FLUSH,
  				finishFlush: zlib__default["default"].Z_SYNC_FLUSH
  			};

  			// For gzip
  			if (codings === 'gzip' || codings === 'x-gzip') {
  				body = Stream.pipeline(body, zlib__default["default"].createGunzip(zlibOptions), error => {
  					if (error) {
  						reject(error);
  					}
  				});
  				response = new Response(body, responseOptions);
  				resolve(response);
  				return;
  			}

  			// For deflate
  			if (codings === 'deflate' || codings === 'x-deflate') {
  				// Handle the infamous raw deflate response from old servers
  				// a hack for old IIS and Apache servers
  				const raw = Stream.pipeline(response_, new Stream.PassThrough(), error => {
  					if (error) {
  						reject(error);
  					}
  				});
  				raw.once('data', chunk => {
  					// See http://stackoverflow.com/questions/37519828
  					if ((chunk[0] & 0x0F) === 0x08) {
  						body = Stream.pipeline(body, zlib__default["default"].createInflate(), error => {
  							if (error) {
  								reject(error);
  							}
  						});
  					} else {
  						body = Stream.pipeline(body, zlib__default["default"].createInflateRaw(), error => {
  							if (error) {
  								reject(error);
  							}
  						});
  					}

  					response = new Response(body, responseOptions);
  					resolve(response);
  				});
  				raw.once('end', () => {
  					// Some old IIS servers return zero-length OK deflate responses, so
  					// 'data' is never emitted. See https://github.com/node-fetch/node-fetch/pull/903
  					if (!response) {
  						response = new Response(body, responseOptions);
  						resolve(response);
  					}
  				});
  				return;
  			}

  			// For br
  			if (codings === 'br') {
  				body = Stream.pipeline(body, zlib__default["default"].createBrotliDecompress(), error => {
  					if (error) {
  						reject(error);
  					}
  				});
  				response = new Response(body, responseOptions);
  				resolve(response);
  				return;
  			}

  			// Otherwise, use response as-is
  			response = new Response(body, responseOptions);
  			resolve(response);
  		});

  		// eslint-disable-next-line promise/prefer-await-to-then
  		writeToStream(request_, request).catch(reject);
  	});
  }

  function fixResponseChunkedTransferBadEnding(request, errorCallback) {
  	const LAST_CHUNK = node_buffer.Buffer.from('0\r\n\r\n');

  	let isChunkedTransfer = false;
  	let properLastChunkReceived = false;
  	let previousChunk;

  	request.on('response', response => {
  		const {headers} = response;
  		isChunkedTransfer = headers['transfer-encoding'] === 'chunked' && !headers['content-length'];
  	});

  	request.on('socket', socket => {
  		const onSocketClose = () => {
  			if (isChunkedTransfer && !properLastChunkReceived) {
  				const error = new Error('Premature close');
  				error.code = 'ERR_STREAM_PREMATURE_CLOSE';
  				errorCallback(error);
  			}
  		};

  		const onData = buf => {
  			properLastChunkReceived = node_buffer.Buffer.compare(buf.slice(-5), LAST_CHUNK) === 0;

  			// Sometimes final 0-length chunk and end of message code are in separate packets
  			if (!properLastChunkReceived && previousChunk) {
  				properLastChunkReceived = (
  					node_buffer.Buffer.compare(previousChunk.slice(-3), LAST_CHUNK.slice(0, 3)) === 0 &&
  					node_buffer.Buffer.compare(buf.slice(-2), LAST_CHUNK.slice(3)) === 0
  				);
  			}

  			previousChunk = buf;
  		};

  		socket.prependListener('close', onSocketClose);
  		socket.on('data', onData);

  		request.on('close', () => {
  			socket.removeListener('close', onSocketClose);
  			socket.removeListener('data', onData);
  		});
  	});
  }

  async function fetchImproved(...args) {
    const result = await fetch(...args);
    const body = await result.json();

    return { status: result.status, body }
  }

  const { attemptP, Future } = F$1;

  const fletch = ({url, options} = {}) => attemptP(() => fetchImproved(url, options));

  const promiseFunToFutureFun = (futurizePromFun) => (...input) => attemptP(() => futurizePromFun(...input));


  /*
  const {  pipe, fork } = F

  const ffletch = ffletchMaker([
    {
      input: {url: 'customerRef/F3456789'},
      output: {
        status: 200,
        body: {name:'jose'}
      }
    },
    {
      input: {url: 'customerRef/F3456789'},
      output: {
        status: 200,
        body: {name:'jose'}
      }
    }
  ], 50) // Last paramater is the delay to resolve the promise.

  ffletch({url: 'customerRef/F3456789'}).pipe(fork(console.log)(console.log))

  */

  function ffletchMaker(fetchsDef, delay) {

    //[{input:{url},output:{status,body}]
    let urlToResponse = fetchsDef.reduce(
      (acum, {input, output}) => {
        acum[JSON.stringify(input)] = output;
        return acum
      },
      {}
    );

    function ffletch(input) {

      const key = JSON.stringify(input);


      const ffletchResolution = (resolve, reject) => {
        if (urlToResponse[key] === undefined) {
          reject(new Error(`Fake Response not found for Request with key: ${key} in ${urlToResponse}`));
          return
        }
        if (urlToResponse[key].status >= 600) {
          reject(new Error(JSON.stringify(urlToResponse[key].body), null, 2));
          return
        }


        resolve({
          status: urlToResponse[key].status,
          body: urlToResponse[key].body,
        });

        return
      };

      return Future(
        (reject, resolve) => {
          setTimeout(
            () => ffletchResolution(resolve, reject),
            parseInt(delay, 10) || 0
          );

          return function onCancel () {
            // Clearing the timeout releases the resources we were holding.
            //clearTimeout (timeoutId)
          }

        }
      )


    }


    return ffletch
  }

  var loglevel$1 = {exports: {}};

  /*
  * loglevel - https://github.com/pimterry/loglevel
  *
  * Copyright (c) 2013 Tim Perry
  * Licensed under the MIT license.
  */

  (function (module) {
  	(function (root, definition) {
  	    if (module.exports) {
  	        module.exports = definition();
  	    } else {
  	        root.log = definition();
  	    }
  	}(commonjsGlobal, function () {

  	    // Slightly dubious tricks to cut down minimized file size
  	    var noop = function() {};
  	    var undefinedType = "undefined";
  	    var isIE = (typeof window !== undefinedType) && (typeof window.navigator !== undefinedType) && (
  	        /Trident\/|MSIE /.test(window.navigator.userAgent)
  	    );

  	    var logMethods = [
  	        "trace",
  	        "debug",
  	        "info",
  	        "warn",
  	        "error"
  	    ];

  	    // Cross-browser bind equivalent that works at least back to IE6
  	    function bindMethod(obj, methodName) {
  	        var method = obj[methodName];
  	        if (typeof method.bind === 'function') {
  	            return method.bind(obj);
  	        } else {
  	            try {
  	                return Function.prototype.bind.call(method, obj);
  	            } catch (e) {
  	                // Missing bind shim or IE8 + Modernizr, fallback to wrapping
  	                return function() {
  	                    return Function.prototype.apply.apply(method, [obj, arguments]);
  	                };
  	            }
  	        }
  	    }

  	    // Trace() doesn't print the message in IE, so for that case we need to wrap it
  	    function traceForIE() {
  	        if (console.log) {
  	            if (console.log.apply) {
  	                console.log.apply(console, arguments);
  	            } else {
  	                // In old IE, native console methods themselves don't have apply().
  	                Function.prototype.apply.apply(console.log, [console, arguments]);
  	            }
  	        }
  	        if (console.trace) console.trace();
  	    }

  	    // Build the best logging method possible for this env
  	    // Wherever possible we want to bind, not wrap, to preserve stack traces
  	    function realMethod(methodName) {
  	        if (methodName === 'debug') {
  	            methodName = 'log';
  	        }

  	        if (typeof console === undefinedType) {
  	            return false; // No method possible, for now - fixed later by enableLoggingWhenConsoleArrives
  	        } else if (methodName === 'trace' && isIE) {
  	            return traceForIE;
  	        } else if (console[methodName] !== undefined) {
  	            return bindMethod(console, methodName);
  	        } else if (console.log !== undefined) {
  	            return bindMethod(console, 'log');
  	        } else {
  	            return noop;
  	        }
  	    }

  	    // These private functions always need `this` to be set properly

  	    function replaceLoggingMethods(level, loggerName) {
  	        /*jshint validthis:true */
  	        for (var i = 0; i < logMethods.length; i++) {
  	            var methodName = logMethods[i];
  	            this[methodName] = (i < level) ?
  	                noop :
  	                this.methodFactory(methodName, level, loggerName);
  	        }

  	        // Define log.log as an alias for log.debug
  	        this.log = this.debug;
  	    }

  	    // In old IE versions, the console isn't present until you first open it.
  	    // We build realMethod() replacements here that regenerate logging methods
  	    function enableLoggingWhenConsoleArrives(methodName, level, loggerName) {
  	        return function () {
  	            if (typeof console !== undefinedType) {
  	                replaceLoggingMethods.call(this, level, loggerName);
  	                this[methodName].apply(this, arguments);
  	            }
  	        };
  	    }

  	    // By default, we use closely bound real methods wherever possible, and
  	    // otherwise we wait for a console to appear, and then try again.
  	    function defaultMethodFactory(methodName, level, loggerName) {
  	        /*jshint validthis:true */
  	        return realMethod(methodName) ||
  	               enableLoggingWhenConsoleArrives.apply(this, arguments);
  	    }

  	    function Logger(name, defaultLevel, factory) {
  	      var self = this;
  	      var currentLevel;
  	      defaultLevel = defaultLevel == null ? "WARN" : defaultLevel;

  	      var storageKey = "loglevel";
  	      if (typeof name === "string") {
  	        storageKey += ":" + name;
  	      } else if (typeof name === "symbol") {
  	        storageKey = undefined;
  	      }

  	      function persistLevelIfPossible(levelNum) {
  	          var levelName = (logMethods[levelNum] || 'silent').toUpperCase();

  	          if (typeof window === undefinedType || !storageKey) return;

  	          // Use localStorage if available
  	          try {
  	              window.localStorage[storageKey] = levelName;
  	              return;
  	          } catch (ignore) {}

  	          // Use session cookie as fallback
  	          try {
  	              window.document.cookie =
  	                encodeURIComponent(storageKey) + "=" + levelName + ";";
  	          } catch (ignore) {}
  	      }

  	      function getPersistedLevel() {
  	          var storedLevel;

  	          if (typeof window === undefinedType || !storageKey) return;

  	          try {
  	              storedLevel = window.localStorage[storageKey];
  	          } catch (ignore) {}

  	          // Fallback to cookies if local storage gives us nothing
  	          if (typeof storedLevel === undefinedType) {
  	              try {
  	                  var cookie = window.document.cookie;
  	                  var location = cookie.indexOf(
  	                      encodeURIComponent(storageKey) + "=");
  	                  if (location !== -1) {
  	                      storedLevel = /^([^;]+)/.exec(cookie.slice(location))[1];
  	                  }
  	              } catch (ignore) {}
  	          }

  	          // If the stored level is not valid, treat it as if nothing was stored.
  	          if (self.levels[storedLevel] === undefined) {
  	              storedLevel = undefined;
  	          }

  	          return storedLevel;
  	      }

  	      function clearPersistedLevel() {
  	          if (typeof window === undefinedType || !storageKey) return;

  	          // Use localStorage if available
  	          try {
  	              window.localStorage.removeItem(storageKey);
  	              return;
  	          } catch (ignore) {}

  	          // Use session cookie as fallback
  	          try {
  	              window.document.cookie =
  	                encodeURIComponent(storageKey) + "=; expires=Thu, 01 Jan 1970 00:00:00 UTC";
  	          } catch (ignore) {}
  	      }

  	      /*
  	       *
  	       * Public logger API - see https://github.com/pimterry/loglevel for details
  	       *
  	       */

  	      self.name = name;

  	      self.levels = { "TRACE": 0, "DEBUG": 1, "INFO": 2, "WARN": 3,
  	          "ERROR": 4, "SILENT": 5};

  	      self.methodFactory = factory || defaultMethodFactory;

  	      self.getLevel = function () {
  	          return currentLevel;
  	      };

  	      self.setLevel = function (level, persist) {
  	          if (typeof level === "string" && self.levels[level.toUpperCase()] !== undefined) {
  	              level = self.levels[level.toUpperCase()];
  	          }
  	          if (typeof level === "number" && level >= 0 && level <= self.levels.SILENT) {
  	              currentLevel = level;
  	              if (persist !== false) {  // defaults to true
  	                  persistLevelIfPossible(level);
  	              }
  	              replaceLoggingMethods.call(self, level, name);
  	              if (typeof console === undefinedType && level < self.levels.SILENT) {
  	                  return "No console available for logging";
  	              }
  	          } else {
  	              throw "log.setLevel() called with invalid level: " + level;
  	          }
  	      };

  	      self.setDefaultLevel = function (level) {
  	          defaultLevel = level;
  	          if (!getPersistedLevel()) {
  	              self.setLevel(level, false);
  	          }
  	      };

  	      self.resetLevel = function () {
  	          self.setLevel(defaultLevel, false);
  	          clearPersistedLevel();
  	      };

  	      self.enableAll = function(persist) {
  	          self.setLevel(self.levels.TRACE, persist);
  	      };

  	      self.disableAll = function(persist) {
  	          self.setLevel(self.levels.SILENT, persist);
  	      };

  	      // Initialize with the right level
  	      var initialLevel = getPersistedLevel();
  	      if (initialLevel == null) {
  	          initialLevel = defaultLevel;
  	      }
  	      self.setLevel(initialLevel, false);
  	    }

  	    /*
  	     *
  	     * Top-level API
  	     *
  	     */

  	    var defaultLogger = new Logger();

  	    var _loggersByName = {};
  	    defaultLogger.getLogger = function getLogger(name) {
  	        if ((typeof name !== "symbol" && typeof name !== "string") || name === "") {
  	          throw new TypeError("You must supply a name when creating a logger.");
  	        }

  	        var logger = _loggersByName[name];
  	        if (!logger) {
  	          logger = _loggersByName[name] = new Logger(
  	            name, defaultLogger.getLevel(), defaultLogger.methodFactory);
  	        }
  	        return logger;
  	    };

  	    // Grab the current global log variable in case of overwrite
  	    var _log = (typeof window !== undefinedType) ? window.log : undefined;
  	    defaultLogger.noConflict = function() {
  	        if (typeof window !== undefinedType &&
  	               window.log === defaultLogger) {
  	            window.log = _log;
  	        }

  	        return defaultLogger;
  	    };

  	    defaultLogger.getLoggers = function getLoggers() {
  	        return _loggersByName;
  	    };

  	    // ES6 default export, for compatibility
  	    defaultLogger['default'] = defaultLogger;

  	    return defaultLogger;
  	}));
  } (loglevel$1));

  var loglevel = loglevel$1.exports;

  // log acts as a bridge with some ehancements to loglelvel

  const log = logAsProxyOfLogLevel();

  function logAsProxyOfLogLevel() {
    const formattedDate = formatDate('$YYYY-$MM-$DD $hh:$mm:$ss', new Date());

    const logBridge = {
      get: function (target, prop, receiver) {
        const addPrefix = {
          apply: function (target, thisArg, listOfArg) {
            return target(`${formattedDate} ${listOfArg.join(' ')} `)
          }
        };

        if (typeof target[prop] === 'function' && ['trace', 'debug', 'info', 'warn', 'error', 'log'].includes(prop)) return new Proxy(target[prop], addPrefix)
        else if (logBridge[prop] !== undefined) return logBridge[prop]
        else return target[prop]
      },

      set: function (obj, prop, value) {
        if (logBridge[prop] !== undefined) logBridge[prop] = value;
        else obj[prop] = value;
        return true
      }
    };

    return new Proxy(loglevel, logBridge)
  }



  //log.LEVEL_NUMBER_TO_NAME = ['TRACE', 'DEBUG','INFO','WARN','ERROR', 'SILENT']
  log.LEVEL_NUMBER_TO_NAME = Object.entries(loglevel.levels).map(elem => elem[0]);

  //log.NAME_TO_LEVEL_NUMBER={ 'TRACE': 0, 'DEBUG': 1, 'INFO': 2, 'WARN': 3, 'ERROR': 4, 'SILENT': 5}
  log.NAME_TO_LEVEL_NUMBER = { ...loglevel.levels };

  function levelName(levelNameOrLevelNumber) {
    if (typeof levelNameOrLevelNumber === 'number') return log.LEVEL_NUMBER_TO_NAME[levelNameOrLevelNumber]

    return levelNameOrLevelNumber
  }

  function levelNumber(levelNameOrLevelNumber) {
    if (typeof levelNameOrLevelNumber === 'string') return log.NAME_TO_LEVEL_NUMBER[levelNameOrLevelNumber.toUpperCase()]

    return levelNameOrLevelNumber
  }

  log.levelName = levelName;
  log.levelNumber = levelNumber;

  const convertPathToStackPath = 
    path => 
      path.map(
        (el, index) => {
          if( index === 0 ) return 0

          return parseInt(el,10)
        }
      );

  function generateStack(plan)
  {
    let stack = [];

    const reviver = 
      (nodeRef, currentPath, parent) => {
       if(typeof nodeRef === 'function')
          stack.push({value: nodeRef, path:  convertPathToStackPath(currentPath)});
      
        return undefined
      };

    traverse$1(
      plan,
      reviver,
    );

    stack.push({value:identity, path:[1]});

    return stack
  }

          
  const isAncestorOf = 
    son => 
      parent => 
        son?.length > parent?.length && _.isEqual(parent, son.slice(0, parent.length));


  const isSiblingOf = 
    sibling1 => 
      sibling2 => 
        _.isEqual(
          sibling1?.slice(0,-1),
          sibling2?.slice(0,-1)
        );

  function getDescendants(stack)
  { 
    return path => 
      stack.filter(
        el => 
          path.length < el.path.length &&
          _.isEqual(
            el.path.slice(0, path.length),
            path
          )
      )
  }

  function areRelativeFrom(ancestorInCommon)
  {
    if(ancestorInCommon === undefined || ancestorInCommon.length === 0) return false

    return familyMember1 => familyMember2 => 
      _.isEqual(ancestorInCommon, familyMember1?.slice(0, ancestorInCommon.length)) &&
      _.isEqual(ancestorInCommon, familyMember2?.slice(0, ancestorInCommon.length))
  }

  areRelativeFrom([0,0])([0,0,0,0])([0,0]); //?

  const stackSiblingsReducer = 
    (acum, el, index$1) => {
      if(
        isSiblingOf(last(acum)?.path)(el.path)
      ) 
      { 
        acum[acum.length - 1].value = pipe(last(acum).value, el.value);
      }else
      {
        acum.push(el);
      }

      return acum
    };

  function acumSiblings(stack)
  {
    return stack.reduce( 
      stackSiblingsReducer,
      []
    )
  }

  const stackParallelReducer = function(numberOfThreads){
    let accruingParallel = false;
    let stackItemsToParallelize = [];

    return (acum, el, index$1, stack) => {
      const elParent = el.path.slice(0,-1);
      const elGrandparent = elParent?.slice(0,-1);
      const nextToEl = stack[index$1+1]?.path;
      const nextToElParent = nextToEl?.slice(0,-1);
      const nextToElGrandparent = nextToElParent?.slice(0,-1);
      const previousToEl = stack[index$1-1]?.path;
      previousToEl?.slice(0,-2);

      let isElToAccrue = 
        el.path.length >= 3 &&
        _.isEqual(elGrandparent, nextToElGrandparent) && 
        // el is the only child of parent
        _.isEqual(getDescendants(stack)(elParent), [el]) &&
        // If previous was not accrued we dont want this to be desdendent of the current grandParent unless previous
        // is a brother of the parent (function header of subsequent parellel functions).
        (
         accruingParallel || 
         isAncestorOf(previousToEl)(elGrandparent) === false ||
         ( isAncestorOf(previousToEl)(elGrandparent) === true  && previousToEl.length < el.path.length )
        );

      if(isElToAccrue === true)
      {
        accruingParallel = true;
        stackItemsToParallelize.push(el);
      }
      
      if(isElToAccrue === false && accruingParallel === true) {
        // In cases we stopped because next element is more nested than our current parallelization
        // even though it has the grandParent as ancestor, then we need to cancel accruing and 
        // restore all elements to acum.
        if( nextToEl?.length > el.path.length && isAncestorOf(nextToEl)(elGrandparent) )
        {
          acum.push(...stackItemsToParallelize);
          acum.push(el);
          accruingParallel = false;
          stackItemsToParallelize = [];

          return acum
        }

        // Rest of cases we need to follow with parallelization including current element.
        stackItemsToParallelize.push(el);
        acum.push(
          {
            value: runFunctionsSyncOrParallel(numberOfThreads)(pluck('value',stackItemsToParallelize)),
            path: el.path.slice(0,-1)
          }
        );
      }
      
      if(isElToAccrue === false &&  accruingParallel === false)
      {
        acum.push(el);
      }

      if(isElToAccrue === false)
      {
        accruingParallel = false;
        stackItemsToParallelize = [];
      }

      return acum
    }
  };

  const acumParallel = numberOfThreads => stack =>
  {
    return stack.reduce( 
      stackParallelReducer(numberOfThreads),
      []
    )
  };


  const reduceNesting = (stack)=> 
  {
    let biggerLengthIndex;
    let biggerLengthValue = -1;

    repeat$1(stack.length).times(
      index => {
        if(stack[index]?.path?.length > stack[index+1]?.path?.length)
        {
          if(biggerLengthValue < stack[index]?.path?.length)
          {
            biggerLengthValue = stack[index]?.path?.length;
            biggerLengthIndex = index;
          }
        }
      }
    );

    let newStack = stack;

    if(biggerLengthIndex !== undefined)
    {
      newStack = [...stack];
      newStack[biggerLengthIndex] =         
        {
          value: newStack[biggerLengthIndex].value,
          path: newStack[biggerLengthIndex].path.slice(0,-1)
        };
    }

    return newStack
  };


  const extractFinalValue = x => x[0]?.value ?? x?.value;


  const lengthStackPrevLessThanCurr = function ()
  {
    let prevStack;
    
    return [
      function funCond(stack) {
        const result = (stack?.length < prevStack?.length) || prevStack === undefined;
        prevStack = stack;
        return result
      },
      function ini(){
        prevStack = undefined;
      }
    ]
  };

  function changeFunWithMockupsObj(mockupsObj)
  {
    return stack => {
      if (!mockupsObj) return stack

      return stack.map(
        ({path, value}) => {
          if(mockupsObj?.[value.name] !== undefined)
          {
            if(typeof mockupsObj[value.name] === 'function') {
              return {
                value:mockupsObj[value.name],
                path
              }
            }

            return {
              value: () =>  mockupsObj[value.name],
              path
            }      
          }

          return {value:value, path}
        }
      )
    }
  }

  function plan(plan, {numberOfThreads, mockupsObj} = {numberOfThreads: Infinity, mockupsObj: {}})
  {

    return pipe(
      generateStack,
      changeFunWithMockupsObj(mockupsObj),
      pipeWhile(stack => stack.length > 1)(
        pipeWhile(...lengthStackPrevLessThanCurr())
        (
          acumSiblings,
          acumParallel(numberOfThreads),
        ),
        reduceNesting,
      ),
      extractFinalValue,
    )(plan)
  }

  const lengthSanitizer = (_, value) => {
    if(typeof value !== 'string' || value.length < 1) return value

    const lengthString = 'length=' + value.length;

    if(value.length >= lengthString.length) {
      
      const numberOfRightAsteriscs = Math.floor((value.length - lengthString.length) / 2);
      
      return lengthString
        .padEnd(
          lengthString.length + numberOfRightAsteriscs, '*'
        )
        .padStart(value.length, '*')
    }

    return ''.padEnd(value.length,'*')

  };

  const bearerSanitizer = (_, bearerToken) => bearerToken.substring(0, 7) + lengthSanitizer(undefined, bearerToken.substring(7));


  const sanitizedGroups = {
    ibmApis: [
      { value: /^Bearer .*$/i, replacer: bearerSanitizer },
      { field: /^client_secret$/i, replacer: lengthSanitizer },
      { field: /^x-ibm-client-secret$/i, replacer: lengthSanitizer },
      { field: /.*token$/i, replacer: lengthSanitizer },
      { field: /^jwt$/i, replacer: lengthSanitizer },
      { field: /^authorization$/i, replacer: lengthSanitizer },
      { field: /^deviceId$/i, replacer: lengthSanitizer },
    ],

    pushNotification: [
      { field: /^body$/i, type: 'string', replacer: lengthSanitizer },
      { field: /^title$/i, replacer: lengthSanitizer },
      {
        sanitizer: (key, value) => {
          return key?.toLowerCase() === 'customer'
            ? 'F' + lengthSanitizer(undefined, value.substring(1))
            : value
        }
      }
    ]

  };

  function isRegExp(obj) {
    if (typeof obj === 'object' && obj.constructor.name === 'RegExp') return true

    return false
  }

  function validateDefinition(sanitizer) {

    const validateOneDef = elem => {

      let options = { rule: undefined, ops: 0, name: undefined };

      if (elem.sanitizer !== undefined) {
        options.ops = options.ops + 1;
        options.rule = elem.sanitizer;
        options.name = 'sanitizer';
      }

      if (elem.field !== undefined) {
        options.ops = options.ops + 2;
        options.rule = elem.field;
        options.name = 'field';
      }

      if (elem.value !== undefined) {
        options.ops = options.ops + 4;
        options.rule = elem.value;
        options.name = 'value';
      }

      if (options.name === undefined)
        throw new CustomError('SANITIZER_DEF_ERROR', 'Expected at least one filled property of: value, field or sanitizer.', elem)

      if (options.name === 'field' && typeof options.rule !== 'string' && isRegExp(options.rule) === false)
        throw new CustomError('SANITIZER_DEF_ERROR', 'field property must be of string type', elem)

      if (elem.type !== undefined && ['string', 'object', 'number', 'boolean'].indexOf(elem.type) === -1)
        throw new CustomError('SANITIZER_DEF_ERROR', 'type property must be of a valid type: string, object, number or boolean', elem)

      if (options.name === 'sanitizer' && typeof options.rule !== 'function')
        throw new CustomError('SANITIZER_DEF_ERROR', 'sanitizer property must be a function.', elem)

      if ([3, 5, 6, 7].indexOf(options.ops) !== -1)
        throw new CustomError(
          'SANITIZER_DEF_ERROR',
          `${options > 6 ? 3 : 2} properties informed and only one allowed between: sanitizer, value or field.`,
          elem
        )

      if (elem.replacer === undefined && elem.sanitizer === undefined)
        throw new CustomError(
          'SANITIZER_DEF_ERROR',
          `Replacer OR sanitizer property must be defined.`,
          elem
        )

      if (elem.replacer !== undefined && elem.sanitizer !== undefined)
        throw new CustomError(
          'SANITIZER_DEF_ERROR',
          `Replacer AND sanitizer cannot be used together`,
          elem
        )
    };

    sanitizer.forEach(validateOneDef);
  }

  function consolidateGroups(sanitizers) {
    return sanitizers.flatMap(
      sanitizer => {

        let toReturn;
        if (typeof sanitizer === 'string') toReturn = sanitizedGroups[sanitizer];
        else toReturn = sanitizer;

        validateDefinition(toReturn);
        return toReturn
      })
  }

  function sanitize(obj, sanitizers = ['ibmApis'], noSanitzedUptoLogLevel) {


    const indexLevel = log.levelNumber(noSanitzedUptoLogLevel);

    if (indexLevel !== undefined && log.getLevel() <= indexLevel) return obj;

    const allGroupsConsolidated = consolidateGroups(sanitizers);

    return _.cloneDeepWith(obj, customizer)

    function isToReplace(fieldOrValue, key, val, keyOrVal) {
      if (typeof fieldOrValue === 'function')
        return fieldOrValue(key, val)

      if (isRegExp(fieldOrValue) && typeof keyOrVal === 'string')
        return keyOrVal?.match(fieldOrValue)

      return _.isEqual(fieldOrValue, keyOrVal)
    }

    function toReplace(replacer, key, val) {
      if (typeof replacer === 'function') return replacer(key, val)
      else return replacer
    }

    function typeMet(value, type) {
      if (type === undefined || typeof value === type) return true
      else return false
    }

    function customizer(obj, parentKey, parentObj) {
      if (obj === null || obj === undefined || obj === {}) return undefined

      for (let { field, value, type, sanitizer, replacer } of allGroupsConsolidated) {
        if (typeMet(obj, type) === false) return undefined
        if (sanitizer !== undefined) return sanitizer(parentKey, obj)
        if (field !== undefined && isToReplace(field, parentKey, obj, parentKey)) return toReplace(replacer, parentKey, obj)
        if (value !== undefined && isToReplace(value, parentKey, obj, obj)) return toReplace(replacer, parentKey, obj)
      }

    }

  }

  const Transformer = function(options = {}, handler){
    this.options = options;
    if(options.consume === undefined || options.consume === null){
      this.options.consume = false;
    }
    this.options.objectMode = true;
    if(options.parallel === undefined || options.parallel === null){
      this.options.parallel = 100;
    }
    if(options.params === undefined || options.params === null){
      options.params = null;
    }
    this.handler = handler;
    stream__default["default"].Transform.call(this, this.options);
    this.state = {
      running: 0,
      started: 0,
      finished: 0
    };
    return this;
  };

  util__default["default"].inherits(Transformer, stream__default["default"].Transform);

  Transformer.prototype._transform = function(chunk, encoding, cb){
    this.state.started++;
    this.state.running++;
    if(this.state.running < this.options.parallel){
      cb();
      cb = null; // Cancel further callback execution
    }
    try {
      let l = this.handler.length;
      if(this.options.params !== null){  
        l--;
      }
      if(l === 1){ // sync
        this.__done(null, [this.handler.call(this, chunk, this.options.params)], cb);
      }else if(l === 2){ // async
        const callback = (err, ...chunks) =>
          this.__done(err, chunks, cb);
        this.handler.call(this, chunk, callback, this.options.params);
      }else {
        throw Error('Invalid handler arguments');
      }
      return false;
    }
    catch (err) {
      this.__done(err);
    }
  };
  Transformer.prototype._flush = function(cb){
    if(this.state.running === 0){
      cb();
    }else {
      this._ending = function(){
        cb();
      };
    }
  };
  Transformer.prototype.__done = function(err, chunks, cb){
    this.state.running--;
    if(err){
      return this.emit('error', err);
    }
    this.state.finished++;
    for(let chunk of chunks){
      if (typeof chunk === 'number'){
        chunk = `${chunk}`;
      }
      // We dont push empty string
      // See https://nodejs.org/api/stream.html#stream_readable_push
      if(chunk !== undefined && chunk !== null && chunk !== ''){
        this.push(chunk);
      }
    }
    if(cb){
      cb();
    }
    if(this._ending && this.state.running === 0){
      this._ending();
    }
  };
  const transform = function(){
    let options = {};
    let callback, handler, records;
    for(let i = 0; i< arguments.length; i++){
      const argument = arguments[i];
      let type = typeof argument;
      if(argument === null){
        type = 'null';
      }else if(type === 'object' && Array.isArray(argument)){
        type = 'array';
      }
      if(type === 'array'){
        records = argument;
      }else if(type === 'object'){
        options = {...argument};
      }else if(type === 'function'){
        if (handler && i === arguments.length - 1) {
          callback = argument;
        } else {
          handler = argument;
        }
      }else if(type !== 'null'){
        throw new Error(`Invalid Arguments: got ${JSON.stringify(argument)} at position ${i}`);
      }
    }
    const transformer = new Transformer(options, handler);
    let error = false;
    if (records) {
      const writer = function(){
        for(const record of records){
          if(error) break;
          transformer.write(record);
        }
        transformer.end();
      };
      // Support Deno, Rollup doesnt provide a shim for setImmediate
      if(typeof setImmediate === 'function'){
        setImmediate(writer);
      }else {
        setTimeout(writer, 0);
      }
    }
    if(callback || options.consume) {
      const result = [];
      transformer.on('readable', function(){
        let record; while((record = transformer.read()) !== null){
          if(callback){
            result.push(record);
          }
        }
      });
      transformer.on('error', function(err){
        error = true;
        if (callback) callback(err);
      });
      transformer.on('end', function(){
        if (callback && !error) callback(null, result);
      });
    }
    return transformer;
  };

  const pipeline = util__default["default"].promisify(stream__default["default"].pipeline);

  const filterStream = (filterFunc) => 
    transform(
      function(record, callback)
      {
        if(filterFunc(record)) {
          if(typeof record === 'object') record = {...record};
          callback(null, record);
        }else callback(null, undefined);
      }
    );

  const mapStream = (mapFunc) => 
    transform(
      function(record, callback)
      {
        callback(null, mapFunc(record));
      }
    );


  const filterMapStream = (filterFunc, mapFunc) => 
    transform(
      function(record, callback)
      {
        if(typeof record === 'object') record = {...record};
        if(filterFunc === undefined && mapFunc === undefined) throw new Error('filterMap called without parameters. filterFunc or mapFunc needed')
        if(filterFunc === undefined) {
          callback(null, mapFunc(record));
          return
        }

        if(mapFunc === undefined) 
        {
          if(filterFunc(record)) callback(null, record);
          else callback(null, undefined);
          return
        }

        if(filterFunc(record)) callback(null, mapFunc(record));
        else callback(null, undefined);
      }
    );


  const fsWriteFilePromise = util__default["default"].promisify(fs__default["default"].writeFile);

  let s = 0;
  const S = {
  	START_BOUNDARY: s++,
  	HEADER_FIELD_START: s++,
  	HEADER_FIELD: s++,
  	HEADER_VALUE_START: s++,
  	HEADER_VALUE: s++,
  	HEADER_VALUE_ALMOST_DONE: s++,
  	HEADERS_ALMOST_DONE: s++,
  	PART_DATA_START: s++,
  	PART_DATA: s++,
  	END: s++
  };

  let f = 1;
  const F = {
  	PART_BOUNDARY: f,
  	LAST_BOUNDARY: f *= 2
  };

  const LF = 10;
  const CR = 13;
  const SPACE = 32;
  const HYPHEN = 45;
  const COLON = 58;
  const A = 97;
  const Z = 122;

  const lower = c => c | 0x20;

  const noop = () => {};

  class MultipartParser {
  	/**
  	 * @param {string} boundary
  	 */
  	constructor(boundary) {
  		this.index = 0;
  		this.flags = 0;

  		this.onHeaderEnd = noop;
  		this.onHeaderField = noop;
  		this.onHeadersEnd = noop;
  		this.onHeaderValue = noop;
  		this.onPartBegin = noop;
  		this.onPartData = noop;
  		this.onPartEnd = noop;

  		this.boundaryChars = {};

  		boundary = '\r\n--' + boundary;
  		const ui8a = new Uint8Array(boundary.length);
  		for (let i = 0; i < boundary.length; i++) {
  			ui8a[i] = boundary.charCodeAt(i);
  			this.boundaryChars[ui8a[i]] = true;
  		}

  		this.boundary = ui8a;
  		this.lookbehind = new Uint8Array(this.boundary.length + 8);
  		this.state = S.START_BOUNDARY;
  	}

  	/**
  	 * @param {Uint8Array} data
  	 */
  	write(data) {
  		let i = 0;
  		const length_ = data.length;
  		let previousIndex = this.index;
  		let {lookbehind, boundary, boundaryChars, index, state, flags} = this;
  		const boundaryLength = this.boundary.length;
  		const boundaryEnd = boundaryLength - 1;
  		const bufferLength = data.length;
  		let c;
  		let cl;

  		const mark = name => {
  			this[name + 'Mark'] = i;
  		};

  		const clear = name => {
  			delete this[name + 'Mark'];
  		};

  		const callback = (callbackSymbol, start, end, ui8a) => {
  			if (start === undefined || start !== end) {
  				this[callbackSymbol](ui8a && ui8a.subarray(start, end));
  			}
  		};

  		const dataCallback = (name, clear) => {
  			const markSymbol = name + 'Mark';
  			if (!(markSymbol in this)) {
  				return;
  			}

  			if (clear) {
  				callback(name, this[markSymbol], i, data);
  				delete this[markSymbol];
  			} else {
  				callback(name, this[markSymbol], data.length, data);
  				this[markSymbol] = 0;
  			}
  		};

  		for (i = 0; i < length_; i++) {
  			c = data[i];

  			switch (state) {
  				case S.START_BOUNDARY:
  					if (index === boundary.length - 2) {
  						if (c === HYPHEN) {
  							flags |= F.LAST_BOUNDARY;
  						} else if (c !== CR) {
  							return;
  						}

  						index++;
  						break;
  					} else if (index - 1 === boundary.length - 2) {
  						if (flags & F.LAST_BOUNDARY && c === HYPHEN) {
  							state = S.END;
  							flags = 0;
  						} else if (!(flags & F.LAST_BOUNDARY) && c === LF) {
  							index = 0;
  							callback('onPartBegin');
  							state = S.HEADER_FIELD_START;
  						} else {
  							return;
  						}

  						break;
  					}

  					if (c !== boundary[index + 2]) {
  						index = -2;
  					}

  					if (c === boundary[index + 2]) {
  						index++;
  					}

  					break;
  				case S.HEADER_FIELD_START:
  					state = S.HEADER_FIELD;
  					mark('onHeaderField');
  					index = 0;
  					// falls through
  				case S.HEADER_FIELD:
  					if (c === CR) {
  						clear('onHeaderField');
  						state = S.HEADERS_ALMOST_DONE;
  						break;
  					}

  					index++;
  					if (c === HYPHEN) {
  						break;
  					}

  					if (c === COLON) {
  						if (index === 1) {
  							// empty header field
  							return;
  						}

  						dataCallback('onHeaderField', true);
  						state = S.HEADER_VALUE_START;
  						break;
  					}

  					cl = lower(c);
  					if (cl < A || cl > Z) {
  						return;
  					}

  					break;
  				case S.HEADER_VALUE_START:
  					if (c === SPACE) {
  						break;
  					}

  					mark('onHeaderValue');
  					state = S.HEADER_VALUE;
  					// falls through
  				case S.HEADER_VALUE:
  					if (c === CR) {
  						dataCallback('onHeaderValue', true);
  						callback('onHeaderEnd');
  						state = S.HEADER_VALUE_ALMOST_DONE;
  					}

  					break;
  				case S.HEADER_VALUE_ALMOST_DONE:
  					if (c !== LF) {
  						return;
  					}

  					state = S.HEADER_FIELD_START;
  					break;
  				case S.HEADERS_ALMOST_DONE:
  					if (c !== LF) {
  						return;
  					}

  					callback('onHeadersEnd');
  					state = S.PART_DATA_START;
  					break;
  				case S.PART_DATA_START:
  					state = S.PART_DATA;
  					mark('onPartData');
  					// falls through
  				case S.PART_DATA:
  					previousIndex = index;

  					if (index === 0) {
  						// boyer-moore derrived algorithm to safely skip non-boundary data
  						i += boundaryEnd;
  						while (i < bufferLength && !(data[i] in boundaryChars)) {
  							i += boundaryLength;
  						}

  						i -= boundaryEnd;
  						c = data[i];
  					}

  					if (index < boundary.length) {
  						if (boundary[index] === c) {
  							if (index === 0) {
  								dataCallback('onPartData', true);
  							}

  							index++;
  						} else {
  							index = 0;
  						}
  					} else if (index === boundary.length) {
  						index++;
  						if (c === CR) {
  							// CR = part boundary
  							flags |= F.PART_BOUNDARY;
  						} else if (c === HYPHEN) {
  							// HYPHEN = end boundary
  							flags |= F.LAST_BOUNDARY;
  						} else {
  							index = 0;
  						}
  					} else if (index - 1 === boundary.length) {
  						if (flags & F.PART_BOUNDARY) {
  							index = 0;
  							if (c === LF) {
  								// unset the PART_BOUNDARY flag
  								flags &= ~F.PART_BOUNDARY;
  								callback('onPartEnd');
  								callback('onPartBegin');
  								state = S.HEADER_FIELD_START;
  								break;
  							}
  						} else if (flags & F.LAST_BOUNDARY) {
  							if (c === HYPHEN) {
  								callback('onPartEnd');
  								state = S.END;
  								flags = 0;
  							} else {
  								index = 0;
  							}
  						} else {
  							index = 0;
  						}
  					}

  					if (index > 0) {
  						// when matching a possible boundary, keep a lookbehind reference
  						// in case it turns out to be a false lead
  						lookbehind[index - 1] = c;
  					} else if (previousIndex > 0) {
  						// if our boundary turned out to be rubbish, the captured lookbehind
  						// belongs to partData
  						const _lookbehind = new Uint8Array(lookbehind.buffer, lookbehind.byteOffset, lookbehind.byteLength);
  						callback('onPartData', 0, previousIndex, _lookbehind);
  						previousIndex = 0;
  						mark('onPartData');

  						// reconsider the current character even so it interrupted the sequence
  						// it could be the beginning of a new sequence
  						i--;
  					}

  					break;
  				case S.END:
  					break;
  				default:
  					throw new Error(`Unexpected state entered: ${state}`);
  			}
  		}

  		dataCallback('onHeaderField');
  		dataCallback('onHeaderValue');
  		dataCallback('onPartData');

  		// Update properties for the next call
  		this.index = index;
  		this.state = state;
  		this.flags = flags;
  	}

  	end() {
  		if ((this.state === S.HEADER_FIELD_START && this.index === 0) ||
  			(this.state === S.PART_DATA && this.index === this.boundary.length)) {
  			this.onPartEnd();
  		} else if (this.state !== S.END) {
  			throw new Error('MultipartParser.end(): stream ended unexpectedly');
  		}
  	}
  }

  function _fileName(headerValue) {
  	// matches either a quoted-string or a token (RFC 2616 section 19.5.1)
  	const m = headerValue.match(/\bfilename=("(.*?)"|([^()<>@,;:\\"/[\]?={}\s\t]+))($|;\s)/i);
  	if (!m) {
  		return;
  	}

  	const match = m[2] || m[3] || '';
  	let filename = match.slice(match.lastIndexOf('\\') + 1);
  	filename = filename.replace(/%22/g, '"');
  	filename = filename.replace(/&#(\d{4});/g, (m, code) => {
  		return String.fromCharCode(code);
  	});
  	return filename;
  }

  async function toFormData(Body, ct) {
  	if (!/multipart/i.test(ct)) {
  		throw new TypeError('Failed to fetch');
  	}

  	const m = ct.match(/boundary=(?:"([^"]+)"|([^;]+))/i);

  	if (!m) {
  		throw new TypeError('no or bad content-type header, no multipart boundary');
  	}

  	const parser = new MultipartParser(m[1] || m[2]);

  	let headerField;
  	let headerValue;
  	let entryValue;
  	let entryName;
  	let contentType;
  	let filename;
  	const entryChunks = [];
  	const formData = new FormData();

  	const onPartData = ui8a => {
  		entryValue += decoder.decode(ui8a, {stream: true});
  	};

  	const appendToFile = ui8a => {
  		entryChunks.push(ui8a);
  	};

  	const appendFileToFormData = () => {
  		const file = new File(entryChunks, filename, {type: contentType});
  		formData.append(entryName, file);
  	};

  	const appendEntryToFormData = () => {
  		formData.append(entryName, entryValue);
  	};

  	const decoder = new TextDecoder('utf-8');
  	decoder.decode();

  	parser.onPartBegin = function () {
  		parser.onPartData = onPartData;
  		parser.onPartEnd = appendEntryToFormData;

  		headerField = '';
  		headerValue = '';
  		entryValue = '';
  		entryName = '';
  		contentType = '';
  		filename = null;
  		entryChunks.length = 0;
  	};

  	parser.onHeaderField = function (ui8a) {
  		headerField += decoder.decode(ui8a, {stream: true});
  	};

  	parser.onHeaderValue = function (ui8a) {
  		headerValue += decoder.decode(ui8a, {stream: true});
  	};

  	parser.onHeaderEnd = function () {
  		headerValue += decoder.decode();
  		headerField = headerField.toLowerCase();

  		if (headerField === 'content-disposition') {
  			// matches either a quoted-string or a token (RFC 2616 section 19.5.1)
  			const m = headerValue.match(/\bname=("([^"]*)"|([^()<>@,;:\\"/[\]?={}\s\t]+))/i);

  			if (m) {
  				entryName = m[2] || m[3] || '';
  			}

  			filename = _fileName(headerValue);

  			if (filename) {
  				parser.onPartData = appendToFile;
  				parser.onPartEnd = appendFileToFormData;
  			}
  		} else if (headerField === 'content-type') {
  			contentType = headerValue;
  		}

  		headerValue = '';
  		headerField = '';
  	};

  	for await (const chunk of Body) {
  		parser.write(chunk);
  	}

  	parser.end();

  	return formData;
  }

  var multipartParser = /*#__PURE__*/Object.freeze({
    __proto__: null,
    toFormData: toFormData
  });

  exports.Chrono = Chrono;
  exports.CustomError = CustomError;
  exports.Enum = Enum;
  exports.EnumMap = EnumMap;
  exports.F = F$1;
  exports.R = index;
  exports.RE = RE;
  exports.RLog = RLog;
  exports.YYYY_MM_DD_hh_mm_ss_ToUtcDate = YYYY_MM_DD_hh_mm_ss_ToUtcDate;
  exports._ = _;
  exports.anonymize = anonymize;
  exports.arrayOfObjectsToObject = arrayOfObjectsToObject;
  exports.arraySorter = arraySorter;
  exports.arrayToObject = arrayToObject;
  exports.bearerSanitizer = bearerSanitizer;
  exports.between = between;
  exports.cleanString = cleanString;
  exports.cloneCopy = cloneCopy;
  exports.colorByStatus = colorByStatus;
  exports.colorMessage = colorMessage;
  exports.colorMessageByStatus = colorMessageByStatus;
  exports.colors = colors;
  exports.copyPropsWithValue = copyPropsWithValue;
  exports.copyPropsWithValueUsingRules = copyPropsWithValueUsingRules;
  exports.dateFormatter = dateFormatter;
  exports.dateToObj = dateToObj;
  exports.deepFreeze = deepFreeze;
  exports.diffInDaysYYYY_MM_DD = diffInDaysYYYY_MM_DD;
  exports.fetch = fetch;
  exports.fetchImproved = fetchImproved;
  exports.ffletchMaker = ffletchMaker;
  exports.fillWith = fillWith;
  exports.filterFlatMap = filterFlatMap;
  exports.filterMap = filterMap;
  exports.filterMapStream = filterMapStream;
  exports.filterStream = filterStream;
  exports.findDeepKey = findDeepKey;
  exports.findSolution = findSolution;
  exports.firstCapital = firstCapital;
  exports.fletch = fletch;
  exports.formatDate = formatDate;
  exports.fsWriteFilePromise = fsWriteFilePromise;
  exports.getSameDateOrPreviousFridayForWeekends = getSameDateOrPreviousFridayForWeekends;
  exports.getValueAtPath = getValueAtPath;
  exports.groupByWithCalc = groupByWithCalc;
  exports.indexOfNthMatch = indexOfNthMatch;
  exports.innerRightJoinWith = innerRightJoinWith;
  exports.isDate = isDate;
  exports.isEmpty = isEmpty$1;
  exports.isPromise = isPromise;
  exports.isStringADate = isStringADate;
  exports.lengthSanitizer = lengthSanitizer;
  exports.log = log;
  exports.logWithPrefix = logWithPrefix;
  exports.loopIndexGenerator = loopIndexGenerator;
  exports.mapStream = mapStream;
  exports.mapWithNext = mapWithNext;
  exports.mapWithPrevious = mapWithPrevious;
  exports.matchByPropId = matchByPropId;
  exports.memoize = memoize;
  exports.mergeArrayOfObjectsRenamingProps = mergeArrayOfObjectsRenamingProps;
  exports.notTo = notTo;
  exports.parallel = parallel;
  exports.partialAtPos = partialAtPos;
  exports.pickPaths = pickPaths;
  exports.pipe = pipe;
  exports.pipeWhile = pipeWhile;
  exports.pipeWithChain = pipeWithChain;
  exports.pipeline = pipeline;
  exports.plan = plan;
  exports.previousDayOfWeek = previousDayOfWeek;
  exports.processExit = processExit;
  exports.promiseAll = promiseAll;
  exports.promiseFunToFutureFun = promiseFunToFutureFun;
  exports.pushUniqueKey = pushUniqueKey;
  exports.pushUniqueKeyOrChange = pushUniqueKeyOrChange;
  exports.queryObjToStr = queryObjToStr;
  exports.removeDuplicates = removeDuplicates;
  exports.repeat = repeat$1;
  exports.replaceAll = replaceAll;
  exports.retryWithSleep = retryWithSleep;
  exports.runEvery = runEvery;
  exports.runFunctionsSyncOrParallel = runFunctionsSyncOrParallel;
  exports.runFutureFunctionsInParallel = runFutureFunctionsInParallel;
  exports.sanitize = sanitize;
  exports.setValueAtPath = setValueAtPath;
  exports.sleep = sleep;
  exports.sleepWithFunction = sleepWithFunction;
  exports.sleepWithValue = sleepWithValue;
  exports.something = something;
  exports.sorterByPaths = sorterByPaths;
  exports.splitCond = splitCond;
  exports.subtractDays = subtractDays;
  exports.transition = transition;
  exports.traverse = traverse$1;
  exports.uncurry = uncurry;
  exports.unionWithHashKeys = unionWithHashKeys;
  exports.updateWithHashKeys = updateWithHashKeys;
  exports.urlCompose = urlCompose;
  exports.urlDecompose = urlDecompose;
  exports.varSubsDoubleBracket = varSubsDoubleBracket;
  exports.wildcardToRegExp = wildcardToRegExp;

  Object.defineProperty(exports, '__esModule', { value: true });

}));
